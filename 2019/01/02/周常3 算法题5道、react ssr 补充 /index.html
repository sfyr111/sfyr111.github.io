<!doctype html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge">
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    
    <title>周常3 算法题5道、react ssr 补充 | Minimalist</title>
    
    <link rel="alternative" href="/atom.xml" title="Minimalist" type="application/atom+xml">
    
    
<link rel="stylesheet" href="/css/style.css">

    
    <link rel="stylesheet" href="/libs/fancybox/jquery.fancybox.css" charset="utf-8">
    
    <!--[if lt IE 9]>
    <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
    <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
<meta name="generator" content="Hexo 6.3.0"></head>
<body class="site">
    <header class="site-header">
        <h1 class="site-title"><a href="/">Minimalist</a></h1>
        <nav class="site-nav">
            <ul class="nav">
                
                <li><a href="/archives">Archives</a></li>
                
                
                <li><a target="_blank" rel="noopener" href="https://github.com/sfyr111" title="git">GITHUB</a></li>
                
                <li><a class="toggle-search" href="#search">search</a></li>
            </ul>
        </nav>
        <div class="site-search" id="search">
            <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
        </div>
        
            <div class="site-header-background" style="background-image:url(http://reumia.github.io/hexo-theme-zzoman2015/images/background-zzoman2015.jpg)"></div>
        
    </header>
    <div class="site-body">
        <div class="global-width">
    <article class="article" data-layout="post" data-slug="周常3 算法题5道、react ssr 补充 ">
        <div class="article-content">
            
            
            <header class="article-header">
                <div class="article-meta">
                    <a href="/2019/01/02/%E5%91%A8%E5%B8%B83%20%E7%AE%97%E6%B3%95%E9%A2%985%E9%81%93%E3%80%81react%20ssr%20%E8%A1%A5%E5%85%85%20/" class="article-date">
  <time datetime="2019-01-02T13:17:00.000Z">2019-01-02</time>
</a>
                    
                    
                </div>
                
    <h1 class="article-title" itemprop="name">
      <a href="/2019/01/02/%E5%91%A8%E5%B8%B83%20%E7%AE%97%E6%B3%95%E9%A2%985%E9%81%93%E3%80%81react%20ssr%20%E8%A1%A5%E5%85%85%20/">周常3 算法题5道、react ssr 补充</a>
    </h1>

            </header>
            
            <div class="article-body">
                <h2 id="周常"><a href="#周常" class="headerlink" title="周常"></a>周常</h2><ul>
<li><p>算法题 java 实现<br>1.调整数组顺序使奇数位于偶数前面<br>2.链表中倒数第k个结点<br>3.翻转链表<br>4.合并两个排序的链表<br>5.树的子结构</p>
</li>
<li><p>react ssr 补充</p>
</li>
</ul>
<h2 id="算法题"><a href="#算法题" class="headerlink" title="算法题"></a>算法题</h2><h3 id="调整数组顺序使奇数位于偶数前面"><a href="#调整数组顺序使奇数位于偶数前面" class="headerlink" title="调整数组顺序使奇数位于偶数前面"></a>调整数组顺序使奇数位于偶数前面</h3><p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变</p>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>1.前后两个指针从头尾出发<br>2.判断两个指针序号的奇偶数<br>3.左右指针不接触时进行运算<br>4.左指针序号自增直到找到偶数，右指针序号自减直到找到奇数。<br>5.左指针序号小于右指针序号则两者未接触，交换位置。</p>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public class ReorderArray &#123;</span><br><span class="line"></span><br><span class="line">	public void reorderArray(int[] arr) &#123;</span><br><span class="line">		int left = 0;</span><br><span class="line">		int right = arr.length - 1;</span><br><span class="line"></span><br><span class="line">		while (left &lt; right) &#123;</span><br><span class="line">			while (left &lt; right &amp;&amp; (arr[left] % 2 != 0))</span><br><span class="line">				left++;</span><br><span class="line">			while (left &lt; right &amp;&amp; (arr[right] % 2 == 0))</span><br><span class="line">				right--;</span><br><span class="line">			if (left &lt; right)</span><br><span class="line">				swap(left, right, arr);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	private void swap(int n, int m, int[] arr) &#123;</span><br><span class="line">		int temp = arr[n];</span><br><span class="line">		arr[n] = arr[m];</span><br><span class="line">		arr[m] = temp;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		int[] arr = &#123;1, 3, 54, 1, 4, 65, 546, 2, 3, 5, 6&#125;;</span><br><span class="line">		new ReorderArray().reorderArray(arr);</span><br><span class="line">		for (int anArr : arr) System.out.print(anArr + &quot; &quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="链表中倒数第k个结点"><a href="#链表中倒数第k个结点" class="headerlink" title="链表中倒数第k个结点"></a>链表中倒数第k个结点</h3><p>链表中倒数第k个节点</p>
<h4 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h4><p>用两个链表使用双指针解法<br>1.第一个指针先走 k 步<br>2.第二个指针和第一个指针同时走，当第一个指针走到最后一位时一起停止<br>3.这时候第二个指针还有 k 步没走，第二个指针当前的位置就是倒数的 k 的位置</p>
<h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public class FindKthToTail &#123;</span><br><span class="line"></span><br><span class="line">	private class ListNode &#123;</span><br><span class="line">		int val;</span><br><span class="line">		ListNode next;</span><br><span class="line">		ListNode(int x) &#123; val = x; &#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public ListNode findKthToTail(ListNode head, int k) &#123;</span><br><span class="line">		if (head == null || k &lt;= 0)</span><br><span class="line">			return null;</span><br><span class="line"></span><br><span class="line">		ListNode nodeP = head;</span><br><span class="line">		ListNode nodeQ = head;</span><br><span class="line"></span><br><span class="line">		// k - 1 是因为 遍历到 k - 2 下个节点 next 并不为 null 赋值后刚好是 k - 1位置</span><br><span class="line">		for (int i = 0; i &lt; k - 1; i++) &#123;</span><br><span class="line">			if (nodeP.next != null)</span><br><span class="line">				nodeP = nodeP.next;</span><br><span class="line">			else</span><br><span class="line">				return null;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		while (nodeP.next != null) &#123;</span><br><span class="line">			nodeP = nodeP.next;</span><br><span class="line">			nodeQ = nodeQ.next;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		return nodeQ;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="翻转链表"><a href="#翻转链表" class="headerlink" title="翻转链表"></a>翻转链表</h3><p>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL<br>输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</p>
<h4 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h4><p>1.创建一个 null 链表 pre<br>2.每次把原链表 cur 的第一位放在pre 的第一位<br>3.直到原链表 cur 为 null 时</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 第一次</span><br><span class="line">cur: 2-&gt;3-&gt;4-&gt;5-&gt;NULL</span><br><span class="line">pre: 1-&gt;NULL</span><br><span class="line">// 第二次</span><br><span class="line">cur: 3-&gt;4-&gt;5-&gt;NULL</span><br><span class="line">pre: 2-&gt;1-&gt;NULL</span><br><span class="line">// 第三次</span><br><span class="line">cur: 4-&gt;5-&gt;NULL</span><br><span class="line">pre: 3-&gt;2-&gt;1-&gt;NULL</span><br><span class="line">// 第四次</span><br><span class="line">cur: 5-&gt;NULL</span><br><span class="line">pre: 4-&gt;3-&gt;2-&gt;1-&gt;NULL</span><br><span class="line">// 第五次</span><br><span class="line">cur: NULL</span><br><span class="line">pre: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</span><br><span class="line">// 返回 pre</span><br></pre></td></tr></table></figure>

<h4 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class ReverseList &#123;</span><br><span class="line"></span><br><span class="line"> public class ListNode &#123;</span><br><span class="line">   int val;</span><br><span class="line">   ListNode next;</span><br><span class="line">   ListNode(int x) &#123; val = x; &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">  public ListNode reverseList(ListNode head) &#123;</span><br><span class="line">    ListNode pre = null;</span><br><span class="line">    ListNode cur = head;</span><br><span class="line"></span><br><span class="line">    while (cur != null) &#123;</span><br><span class="line">      ListNode temp = cur.next; // 保留除 cur 第1位的链表 2 -&gt; 3 -&gt; 4 ，cur 还没变</span><br><span class="line">      cur.next = pre; // cur.next 指向 pre 截断 cur 当前第1位 1 -&gt; null, 此处截断原链表生成新链表</span><br><span class="line">      pre = cur; // pre 变成 1 -&gt; null</span><br><span class="line">      cur = temp; // 去除 cur 第1位, cur 变成 2 -&gt; 3 -&gt; 4</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return pre;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="合并两个排序的链表"><a href="#合并两个排序的链表" class="headerlink" title="合并两个排序的链表"></a>合并两个排序的链表</h2><h3 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>解法1 使用循环<br>1.创建虚拟头 dummy<br>2.dummy 引用赋值给 cur<br>3.当 l1 l2 都不为 null 时循环<br>4.比较 l1.val 和 l2.val 谁小谁接入到 cur.next 上，ln &#x3D; ln.next 继续比较下一个</li>
</ul>
<ol start="5">
<li>cur &#x3D; cur.next 同时向下准备介接入</li>
<li>当l1 或 l2 其中一个为空时 cur.next 为剩下不为空的链表<br>7.最后返回 dummy 引用的 dummy.next</li>
</ol>
<ul>
<li>解法2 使用递归<br>1.基础问题：当其中一个链表为空时，剩下的节点肯定来自另一个链表<br>2.基本问题：比较 l1.val 和 l2.val，谁小谁的 next 就递归比较其 next 节点与另一个链表的合并.</li>
</ul>
<h3 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">public class MergeTwoSortedLists &#123;</span><br><span class="line"></span><br><span class="line">	public class ListNode &#123;</span><br><span class="line">		int val;</span><br><span class="line">		ListNode next;</span><br><span class="line">		ListNode(int x) &#123; val = x; &#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public ListNode mergeTwoLists1(ListNode l1, ListNode l2) &#123;</span><br><span class="line">		ListNode dummy = new ListNode(-1);</span><br><span class="line">		ListNode cur = dummy;</span><br><span class="line"></span><br><span class="line">		while (l1 != null &amp;&amp; l2 != null) &#123;</span><br><span class="line">			if (l1.val &lt; l2.val) &#123;</span><br><span class="line">				cur.next = l1;</span><br><span class="line">				l1 = l1.next;</span><br><span class="line">			&#125; else &#123;</span><br><span class="line">				cur.next = l2;</span><br><span class="line">				l2 = l2.next;</span><br><span class="line">			&#125;</span><br><span class="line">			cur = cur.next;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		cur.next = (l1 != null) ? l1 : l2;</span><br><span class="line">		return dummy.next;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public ListNode mergeTwoLists2(ListNode l1, ListNode l2) &#123;</span><br><span class="line">		// 当其中一个链表为空时，剩下的节点肯定来自另一个链表</span><br><span class="line">		if (l1 == null) return l2;</span><br><span class="line">		if (l2 == null) return l1;</span><br><span class="line">		// 开始递归</span><br><span class="line">		if (l1.val &lt; l2.val) &#123; // l1 后面应该接节点</span><br><span class="line">			l1.next = mergeTwoLists2(l1.next, l2); // 传入 l1.next l2, 决定 l1.next l2 如果合并</span><br><span class="line">			return l1;</span><br><span class="line">		&#125; else &#123; // l1.val &gt;= l2.val</span><br><span class="line">			l2.next = mergeTwoLists2(l1, l2.next);</span><br><span class="line">			return l2;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="树的子结构"><a href="#树的子结构" class="headerlink" title="树的子结构"></a>树的子结构</h3><p>给定两个非空二叉树 s 和 t，检验 s 中是否包含和 t 具有相同结构和节点值的子树。s 的一个子树包括 s 的一个节点和这个节点的所有子孙。s 也可以看做它自身的一棵子树。</p>
<h4 id="解题思路-4"><a href="#解题思路-4" class="headerlink" title="解题思路"></a>解题思路</h4><p>1.创建 equals 函数，比较两个 TreeNode， 比较两个 TreeNode 的 val，如果相等递归比较 left 和 right 节点<br>2.创建 traverse 函数，这个函数用来在 s 的每个节点中比较 t ，同时进行比较当前节点， 递归的在 s 的 left 和 right 里比较 t</p>
<h4 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public class SubtreeOfAnotherTree &#123;</span><br><span class="line"></span><br><span class="line">	public class TreeNode &#123;</span><br><span class="line">		int val;</span><br><span class="line">		TreeNode left;</span><br><span class="line">		TreeNode right;</span><br><span class="line"></span><br><span class="line">		TreeNode(int x) &#123;</span><br><span class="line">			val = x;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public boolean isSubtree(TreeNode s, TreeNode t) &#123;</span><br><span class="line">		return traverse(s, t); // 此函数用来递归遍历树</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// 这个函数用来在 s 的每个节点中比较 t ，同时进行比较当前节点</span><br><span class="line">	private boolean traverse(TreeNode s, TreeNode t) &#123;</span><br><span class="line">		return s != null // 主树不为空</span><br><span class="line">				&amp;&amp; (</span><br><span class="line">				  equals(s, t) // 两个树一样</span><br><span class="line">					|| traverse(s.left, t) // 从左子节点开始比较</span><br><span class="line">					|| traverse(s.right, t) // 从右子节点开始比较</span><br><span class="line">		);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	private boolean equals(TreeNode x, TreeNode y) &#123;</span><br><span class="line">		if (x == null &amp;&amp; y == null) // base 基础条件，比较到最后都没子节点了 true</span><br><span class="line">			return true;</span><br><span class="line">		if (x == null || y == null) // base 基础条件，还有子节点 false</span><br><span class="line">			return false;</span><br><span class="line">		// 递归实际比较</span><br><span class="line">		return x.val == y.val &amp;&amp; equals(x.left, y.left) &amp;&amp; equals(x.right, y.right);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="react-ssr-补充"><a href="#react-ssr-补充" class="headerlink" title="react ssr 补充"></a>react ssr 补充</h2><h2 id="node-server-中间层"><a href="#node-server-中间层" class="headerlink" title="node server 中间层"></a>node server 中间层</h2><p>之前的代码在渲染时 node server 请求了一次 api 返回了数据插入到页面上，client 的代码在 componentDidMount 里也是请求了 api ，这次改造成 client 请求 node server，node server 再去请求 api，让 node server 只做代理而不是客户端还去请求外部服务。</p>
<h3 id="使用-express-http-proxy"><a href="#使用-express-http-proxy" class="headerlink" title="使用 express-http-proxy"></a>使用 express-http-proxy</h3><p>设置代理 client 请求本地服务 &#x2F;api&#x2F;news.json?secret&#x3D;abcd 时代理到 <a target="_blank" rel="noopener" href="http://47.95.113.63/ssr/api/news.json?secret=abcd">http://47.95.113.63/ssr/api/news.json?secret=abcd</a> 下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import proxy from &#x27;express-http-proxy&#x27;;</span><br><span class="line"></span><br><span class="line">app.use(&#x27;/api&#x27;, proxy(&#x27;http://47.95.113.63&#x27;, &#123;</span><br><span class="line">  proxyReqPathResolver: function (req) &#123;</span><br><span class="line">    return &#x27;/ssr/api&#x27; + req.url;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure>

<h3 id="区分-server-client-axios-请求的-baseURL"><a href="#区分-server-client-axios-请求的-baseURL" class="headerlink" title="区分 server client axios 请求的 baseURL"></a>区分 server client axios 请求的 baseURL</h3><ul>
<li><p>server client axios 配置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// client</span><br><span class="line">import axios from &#x27;axios&#x27;;</span><br><span class="line"></span><br><span class="line">const instance = axios.create(&#123;</span><br><span class="line">	baseURL: &#x27;/&#x27;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">export default instance;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// server</span><br><span class="line">import axios from &#x27;axios&#x27;;</span><br><span class="line"></span><br><span class="line">const createInstance = (req) =&gt; axios.create(&#123;</span><br><span class="line">	baseURL: &#x27;http://47.95.113.63/ssr&#x27;,</span><br><span class="line">	headers: &#123;</span><br><span class="line">		cookie: req.get(&#x27;cookie&#x27;) || &#x27;&#x27;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">export default createInstance;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 thunk.withExtraArgument</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">export const getStore = (req) =&gt; &#123;</span><br><span class="line">	// 改变服务器端store的内容，那么就一定要使用serverAxios</span><br><span class="line">	return createStore(reducer, applyMiddleware(thunk.withExtraArgument(serverAxios(req))));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export const getClientStore = () =&gt; &#123;</span><br><span class="line">	const defaultState = window.context.state;</span><br><span class="line">	// 改变客户端store的内容，一定要使用clientAxios</span><br><span class="line">	return createStore(reducer, defaultState, applyMiddleware(thunk.withExtraArgument(clientAxios)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>action 上就会增加额外的参数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// action</span><br><span class="line">export const getHomeList = () =&gt; &#123;</span><br><span class="line">	return (dispatch, getState, axiosInstance) =&gt; &#123;</span><br><span class="line">		return axiosInstance.get(&#x27;/api/news.json?secret=abcd&#x27;)</span><br><span class="line">			.then((res) =&gt; &#123;</span><br><span class="line">				const list = res.data.data;</span><br><span class="line">				dispatch(changeList(list))</span><br><span class="line">			&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
</li>
<li><p>或者使用 webpack.DefinePlugin 插件，给server 端代码增加环境变量</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 通过插件传递的环境变量只在 server 打包的代码里使用</span><br><span class="line">const baseUrl = process.env.API_BASE || &#x27;&#x27;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// webpack.server.js</span><br><span class="line">  plugins: [</span><br><span class="line">    new webpack.DefinePlugin(&#123;</span><br><span class="line">      &#x27;process.env.API_BASE&#x27;: &#x27;&quot;http://127.0.0.1:3333&quot;&#x27;</span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="多层路由展示"><a href="#多层路由展示" class="headerlink" title="多层路由展示"></a>多层路由展示</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// Routes.js</span><br><span class="line">export default [&#123;</span><br><span class="line">  path: &#x27;/&#x27;,</span><br><span class="line">  component: App,</span><br><span class="line">  loadData: App.loadData,</span><br><span class="line">  routes: [</span><br><span class="line">    &#123; </span><br><span class="line">      path: &#x27;/&#x27;,</span><br><span class="line">      component: Home,</span><br><span class="line">      exact: true,</span><br><span class="line">      loadData: Home.loadData,</span><br><span class="line">      key: &#x27;home&#x27;</span><br><span class="line">    &#125;, &#123; </span><br><span class="line">      path: &#x27;/translation&#x27;,</span><br><span class="line">      component: Translation,</span><br><span class="line">      loadData: Translation.loadData,</span><br><span class="line">      exact: true,</span><br><span class="line">      key: &#x27;translation&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">import &#123; renderRoutes &#125; from &#x27;react-router-config&#x27;;</span><br><span class="line"></span><br><span class="line">// client</span><br><span class="line">const App = () =&gt; &#123;</span><br><span class="line">	return (</span><br><span class="line">		&lt;Provider store=&#123;store&#125;&gt;</span><br><span class="line">			&lt;BrowserRouter&gt;</span><br><span class="line">				&lt;div&gt;</span><br><span class="line">					&#123;renderRoutes(routes)&#125;</span><br><span class="line">	    	&lt;/div&gt;</span><br><span class="line">			&lt;/BrowserRouter&gt;</span><br><span class="line">		&lt;/Provider&gt;</span><br><span class="line">	)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// server</span><br><span class="line">export const render = (store, routes, req) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">		const content = renderToString((</span><br><span class="line">			&lt;Provider store=&#123;store&#125;&gt;</span><br><span class="line">				&lt;StaticRouter location=&#123;req.path&#125; context=&#123;&#123;&#125;&#125;&gt;</span><br><span class="line">					&lt;div&gt;</span><br><span class="line">						&#123;renderRoutes(routes)&#125;</span><br><span class="line">	    		&lt;/div&gt;</span><br><span class="line">				&lt;/StaticRouter&gt;</span><br><span class="line">			&lt;/Provider&gt;</span><br><span class="line">		));</span><br><span class="line">		// return ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一级路由组件要渲染二级路由 routes 子路由数组</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">routes: [</span><br><span class="line">    &#123; </span><br><span class="line">      path: &#x27;/&#x27;,</span><br><span class="line">      component: Home,</span><br><span class="line">      exact: true,</span><br><span class="line">      loadData: Home.loadData,</span><br><span class="line">      key: &#x27;home&#x27;</span><br><span class="line">    &#125;, &#123; </span><br><span class="line">      path: &#x27;/translation&#x27;,</span><br><span class="line">      component: Translation,</span><br><span class="line">      loadData: Translation.loadData,</span><br><span class="line">      exact: true,</span><br><span class="line">      key: &#x27;translation&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br></pre></td></tr></table></figure>
<p>一级路由组件渲染后 route 属性可以在 props 里获取到，在一级路由组件里使用 renderRoutes 渲染一级路由的 props.route.routes</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 一级路由的组件</span><br><span class="line">// client server 端共用</span><br><span class="line">const App = (props) =&gt; &#123;</span><br><span class="line">	return (</span><br><span class="line">		&lt;div&gt;</span><br><span class="line">			&lt;Header /&gt;</span><br><span class="line">			&#123;renderRoutes(props.route.routes)&#125;</span><br><span class="line">		&lt;/div&gt;</span><br><span class="line">	)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">App.loadData = (store) =&gt; &#123;</span><br><span class="line">	return store.dispatch(actions.getHeaderInfo());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解决-cookie-携带问题"><a href="#解决-cookie-携带问题" class="headerlink" title="解决 cookie 携带问题"></a>解决 cookie 携带问题</h3><p>当浏览器请求本地 node 服务时(携带 cookie)<br>node server 进行服务端渲染转发浏览器的请求<br>node server 请求 api server 获取数据(cookie 需要手动携带)<br>express-http-proxy 中间件 只转发了请求路径，请求内容最终还是 axios 请求的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">app.use(&#x27;/api&#x27;, proxy(&#x27;http://47.95.113.63&#x27;, &#123;</span><br><span class="line">  proxyReqPathResolver: function (req) &#123;</span><br><span class="line">    return &#x27;/ssr/api&#x27; + req.url;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure>
<p>通过把 express req 对象传递给 getStore 最后改造 createInstance 为高阶函数，这样cookie 就可以给 axios 获取cookie了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">app.get(&#x27;*&#x27;, function (req, res) &#123;</span><br><span class="line">	const store = getStore(req);</span><br><span class="line">	// ..</span><br><span class="line">&#125;</span><br><span class="line">export const getStore = (req) =&gt; &#123;</span><br><span class="line">	// 改变服务器端store的内容，那么就一定要使用serverAxios</span><br><span class="line">	return createStore(reducer, applyMiddleware(thunk.withExtraArgument(serverAxios(req))));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// axios 实例</span><br><span class="line">import axios from &#x27;axios&#x27;;</span><br><span class="line"></span><br><span class="line">const createInstance = (req) =&gt; axios.create(&#123;</span><br><span class="line">	baseURL: &#x27;http://47.95.113.63/ssr&#x27;,</span><br><span class="line">	headers: &#123;</span><br><span class="line">		cookie: req.get(&#x27;cookie&#x27;) || &#x27;&#x27;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">export default createInstance;</span><br></pre></td></tr></table></figure>

<h2 id="生成404页面"><a href="#生成404页面" class="headerlink" title="生成404页面"></a>生成404页面</h2><p>路由配置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">export default [&#123;</span><br><span class="line">  path: &#x27;/&#x27;,</span><br><span class="line">  component: App,</span><br><span class="line">  loadData: App.loadData,</span><br><span class="line">  routes: [</span><br><span class="line">    &#123; </span><br><span class="line">      path: &#x27;/&#x27;,</span><br><span class="line">      component: Home,</span><br><span class="line">      exact: true,</span><br><span class="line">      loadData: Home.loadData,</span><br><span class="line">      key: &#x27;home&#x27;</span><br><span class="line">    &#125;, &#123; </span><br><span class="line">      path: &#x27;/translation&#x27;,</span><br><span class="line">      component: Translation,</span><br><span class="line">      loadData: Translation.loadData,</span><br><span class="line">      exact: true,</span><br><span class="line">      key: &#x27;translation&#x27;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      component: NotFound</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>

<h3 id="解决请求返回的页面-status-404-返回"><a href="#解决请求返回的页面-status-404-返回" class="headerlink" title="解决请求返回的页面 status 404 返回"></a>解决请求返回的页面 status 404 返回</h3><p>在 server 使用 StaticRouter 传递 context, context 可以从 props.staticContext 中获取</p>
<p>修改 server ssr 路由配置，给 render 函数传递 context</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">app.get(&#x27;*&#x27;, function (req, res) &#123;</span><br><span class="line">	Promise.all(promises).then(() =&gt; &#123;</span><br><span class="line">		const context = &#123;&#125;;</span><br><span class="line">		const html = render(store, routes, req, context);</span><br><span class="line">        res.send(html)</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>给 render 函数增加 context 参数传递到 StaticRouter 组件中，等到 props.staticContext 使用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">export const render = (store, routes, req, context) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">		const content = renderToString((</span><br><span class="line">			&lt;Provider store=&#123;store&#125;&gt;</span><br><span class="line">				&lt;StaticRouter location=&#123;req.path&#125; context=&#123;context&#125;&gt;</span><br><span class="line">					&lt;div&gt;</span><br><span class="line">						&#123;renderRoutes(routes)&#125;</span><br><span class="line">	    		&lt;/div&gt;</span><br><span class="line">				&lt;/StaticRouter&gt;</span><br><span class="line">			&lt;/Provider&gt;</span><br><span class="line">		));</span><br><span class="line">        return `...`</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>修改 NotFound 页面, 当没有匹配路由访问到 NotFound 页面时，staticContext 增加 NOT_FOUND<br>因为 server client 都会执行，client 不存在 staticContext 记得判断一下防止报错</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; Component &#125; from &#x27;react&#x27;;</span><br><span class="line"></span><br><span class="line">class NotFound extends Component &#123;</span><br><span class="line"></span><br><span class="line">	componentWillMount() &#123;</span><br><span class="line">		const &#123; staticContext &#125; = this.props;</span><br><span class="line">		staticContext &amp;&amp; (staticContext.NOT_FOUND = true);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	render() &#123;</span><br><span class="line">		return &lt;div&gt;404, sorry, page not found&lt;/div&gt;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default NotFound;</span><br></pre></td></tr></table></figure>
<p>这样我们可以通过判断 context.NOT_FOUND 来判断设置 status 404再返回页面</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">app.get(&#x27;*&#x27;, function (req, res) &#123;</span><br><span class="line">	Promise.all(promises).then(() =&gt; &#123;</span><br><span class="line">		const context = &#123;&#125;;</span><br><span class="line">		const html = render(store, routes, req, context);</span><br><span class="line">        if (context.NOT_FOUND) &#123;</span><br><span class="line">			res.status(404);</span><br><span class="line">			res.send(html);</span><br><span class="line">		&#125;else &#123;</span><br><span class="line">			res.send(html);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="实现-301-重定向"><a href="#实现-301-重定向" class="headerlink" title="实现 301 重定向"></a>实现 301 重定向</h3><p>没登录的情况下访问需要授权的页面 虽然 client 的逻辑重定向了，但是server 端代码没有重定向。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// client 页面执行的 Redirect</span><br><span class="line">	render() &#123;</span><br><span class="line">		return this.props.login ? (</span><br><span class="line">			&lt;div&gt;</span><br><span class="line">				&#123;this.getList()&#125;</span><br><span class="line">			&lt;/div&gt;</span><br><span class="line">		) : &lt;Redirect to=&#x27;/&#x27;/&gt;;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>不过 renderRoutes 方法在发现 Redirect 组件执行时，就是在 server 上发现时会帮我们的 context 上塞一段数据用来判断</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// context: &#123; url: &#x27;&#x27;, action: &#x27;&#x27;, location: &#123; pathname: &#x27;&#x27;, search: &#x27;&#x27;, hash: &#x27;&#x27;, state: undefined &#125; &#125;</span><br><span class="line">app.get(&#x27;*&#x27;, function (req, res) &#123;</span><br><span class="line">	Promise.all(promises).then(() =&gt; &#123;</span><br><span class="line">		const context = &#123;&#125;;</span><br><span class="line">		const html = render(store, routes, req, context);</span><br><span class="line">		if (context.action === &#x27;REPLACE&#x27;) &#123;</span><br><span class="line">			res.redirect(301, context.url)</span><br><span class="line">		&#125;else if (context.NOT_FOUND) &#123;</span><br><span class="line">			res.status(404);</span><br><span class="line">			res.send(html);</span><br><span class="line">		&#125;else &#123;</span><br><span class="line">			res.send(html);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样就可以实现301了</p>
<h3 id="错误获取"><a href="#错误获取" class="headerlink" title="错误获取"></a>错误获取</h3><p>当 node server 代理的请求报错时页面就崩溃了，我们喜欢 node server 代理的请求有错时还是能返回没报错的数据同时把页面渲染出来</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">app.get(&#x27;*&#x27;, function (req, res) &#123;</span><br><span class="line">	const store = getStore(req);</span><br><span class="line">	const matchedRoutes = matchRoutes(routes, req.path);</span><br><span class="line">	const promises = [];</span><br><span class="line">	matchedRoutes.forEach(item =&gt; &#123;</span><br><span class="line">		if (item.route.loadData) &#123;</span><br><span class="line">		    // 封装一个 promise，当 loadData catch 时也能让外层的 promise 返回 resolve 能继续执行，保证返回页面的 promise.all 能继续执行</span><br><span class="line">			const promise = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">				item.route.loadData(store).then(resolve).catch(resolve);</span><br><span class="line">			&#125;)</span><br><span class="line">			promises.push(promise);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;)</span><br><span class="line">	Promise.all(promises).then(() =&gt; &#123;</span><br><span class="line">		const context = &#123;&#125;;</span><br><span class="line">		const html = render(store, routes, req, context);</span><br><span class="line">		if (context.action === &#x27;REPLACE&#x27;) &#123;</span><br><span class="line">			res.redirect(301, context.url)</span><br><span class="line">		&#125;else if (context.NOT_FOUND) &#123;</span><br><span class="line">			res.status(404);</span><br><span class="line">			res.send(html);</span><br><span class="line">		&#125;else &#123;</span><br><span class="line">			res.send(html);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="处理-CSS"><a href="#处理-CSS" class="headerlink" title="处理 CSS"></a>处理 CSS</h2><h3 id="server-打包-处理-css"><a href="#server-打包-处理-css" class="headerlink" title="server 打包 处理 css"></a>server 打包 处理 css</h3><p>使用isomorphic-style-loader, 处理样式的 loader 需要 window 对象，server 端是没有 window 的，使用同构样式的 loader, 这里使用 modules 模式需要执行 JS 才有样式，会有白屏问题</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">rules: [&#123;</span><br><span class="line">	test: /\.css?$/,</span><br><span class="line">	use: [&#x27;isomorphic-style-loader&#x27;, &#123;</span><br><span class="line">		loader: &#x27;css-loader&#x27;,</span><br><span class="line">		options: &#123;</span><br><span class="line">			importLoaders: 1,</span><br><span class="line">			modules: true,</span><br><span class="line">			localIdentName: &#x27;[name]_[local]_[hash:base64:5]&#x27;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="实现-ssr-样式"><a href="#实现-ssr-样式" class="headerlink" title="实现 ssr 样式"></a>实现 ssr 样式</h3><ul>
<li>创建传递 styles.getCss() 对象到 staticContext.css 里的高阶组件<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; Component &#125; from &#x27;react&#x27;;</span><br><span class="line"></span><br><span class="line">export default (DecoratedComponent, styles) =&gt; &#123;</span><br><span class="line">	</span><br><span class="line">	return class NewComponent extends Component &#123;</span><br><span class="line"></span><br><span class="line">		componentWillMount() &#123;</span><br><span class="line">			if (this.props.staticContext) &#123;</span><br><span class="line">				this.props.staticContext.css.push(styles._getCss());</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		render() &#123;</span><br><span class="line">			return &lt;DecoratedComponent &#123;...this.props&#125; /&gt;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>ssr 样式的页面使用高阶组件<br>这里同时把 loadData 挂载到到处的页面对象上。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const ExportHome = connect(mapStateToProps, mapDispatchToProps)(withStyle(Home, styles)); // 使用 withStyle</span><br><span class="line"></span><br><span class="line">ExportHome.loadData = (store) =&gt; &#123;</span><br><span class="line">	return store.dispatch(getHomeList())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default ExportHome;</span><br></pre></td></tr></table></figure></li>
<li>最后在 server 里修改返回的模板<br>通过传入的 staticContext 对象里找到 css 对象数组，转换成字符串后，插入到 head 里<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">export const render = (store, routes, req, context) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">		const content = renderToString((</span><br><span class="line">			&lt;Provider store=&#123;store&#125;&gt;</span><br><span class="line">				&lt;StaticRouter location=&#123;req.path&#125; context=&#123;context&#125;&gt;</span><br><span class="line">					&lt;div&gt;</span><br><span class="line">						&#123;renderRoutes(routes)&#125;</span><br><span class="line">	    		&lt;/div&gt;</span><br><span class="line">				&lt;/StaticRouter&gt;</span><br><span class="line">			&lt;/Provider&gt;</span><br><span class="line">		));</span><br><span class="line"></span><br><span class="line">		const cssStr = context.css.length ? context.css.join(&#x27;\n&#x27;) : &#x27;&#x27;;</span><br><span class="line"></span><br><span class="line">		return `</span><br><span class="line">			&lt;html&gt;</span><br><span class="line">				&lt;head&gt;</span><br><span class="line">					&lt;title&gt;ssr&lt;/title&gt;</span><br><span class="line">					&lt;style&gt;$&#123;cssStr&#125;&lt;/style&gt;</span><br><span class="line">				&lt;/head&gt;</span><br><span class="line">				&lt;body&gt;</span><br><span class="line">					&lt;div id=&quot;root&quot;&gt;$&#123;content&#125;&lt;/div&gt;</span><br><span class="line">					&lt;script&gt;</span><br><span class="line">						window.context = &#123;</span><br><span class="line">							state: $&#123;JSON.stringify(store.getState())&#125;</span><br><span class="line">						&#125;</span><br><span class="line">					&lt;/script&gt;</span><br><span class="line">					&lt;script src=&#x27;/index.js&#x27;&gt;&lt;/script&gt;</span><br><span class="line">				&lt;/body&gt;</span><br><span class="line">			&lt;/html&gt;</span><br><span class="line">	  `;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="SEO"><a href="#SEO" class="headerlink" title="SEO"></a>SEO</h2><h3 id="Title-和-Description"><a href="#Title-和-Description" class="headerlink" title="Title 和 Description"></a>Title 和 Description</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;title&gt; 标题</span><br><span class="line">&lt;meta name=&quot;Description&quot; content=&quot;搜索踹的简介&quot;&gt;</span><br></pre></td></tr></table></figure>

<h3 id="React-Helment"><a href="#React-Helment" class="headerlink" title="React-Helment"></a>React-Helment</h3><ul>
<li>page 上使用<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// pages/home.js</span><br><span class="line">import &#123; Helmet &#125; from &quot;react-helmet&quot;;</span><br><span class="line"></span><br><span class="line">class Home extends Component &#123;</span><br><span class="line">	render() &#123;</span><br><span class="line">		return (</span><br><span class="line">			&lt;Fragment&gt;</span><br><span class="line">				&lt;Helmet&gt;</span><br><span class="line">					&lt;title&gt;新闻页面 - 丰富多彩的资讯&lt;/title&gt;</span><br><span class="line">					&lt;meta name=&quot;description&quot; content=&quot;新闻页面 - 丰富多彩的资讯&quot; /&gt;</span><br><span class="line">				&lt;/Helmet&gt;</span><br><span class="line">				&lt;div className=&#123;styles.container&#125;&gt;</span><br><span class="line">					&#123;list&#125;</span><br><span class="line">				&lt;/div&gt;</span><br><span class="line">			&lt;/Fragment&gt;</span><br><span class="line">		)</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>node server 上使用<br>注意要在 react.renderToString() 后使用 const helmet &#x3D; Helmet.renderStatic(); 来获取每个 page 中 react 组件设置的 Helmet 对象<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">import &#123; Helmet &#125; from &quot;react-helmet&quot;;</span><br><span class="line"></span><br><span class="line">export const render = (store, routes, req, context) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">		const content = renderToString((</span><br><span class="line">			&lt;Provider store=&#123;store&#125;&gt;</span><br><span class="line">				&lt;StaticRouter location=&#123;req.path&#125; context=&#123;context&#125;&gt;</span><br><span class="line">					&lt;div&gt;</span><br><span class="line">						&#123;renderRoutes(routes)&#125;</span><br><span class="line">	    		&lt;/div&gt;</span><br><span class="line">				&lt;/StaticRouter&gt;</span><br><span class="line">			&lt;/Provider&gt;</span><br><span class="line">		));</span><br><span class="line">		const helmet = Helmet.renderStatic();</span><br><span class="line"></span><br><span class="line">		const cssStr = context.css.length ? context.css.join(&#x27;\n&#x27;) : &#x27;&#x27;;</span><br><span class="line"></span><br><span class="line">		return `</span><br><span class="line">			&lt;html&gt;</span><br><span class="line">				&lt;head&gt;</span><br><span class="line">					$&#123;helmet.title.toString()&#125;</span><br><span class="line">          $&#123;helmet.meta.toString()&#125;</span><br><span class="line">					&lt;style&gt;$&#123;cssStr&#125;&lt;/style&gt;</span><br><span class="line">				&lt;/head&gt;</span><br><span class="line">				&lt;body&gt;</span><br><span class="line">					&lt;div id=&quot;root&quot;&gt;$&#123;content&#125;&lt;/div&gt;</span><br><span class="line">					&lt;script&gt;</span><br><span class="line">						window.context = &#123;</span><br><span class="line">							state: $&#123;JSON.stringify(store.getState())&#125;</span><br><span class="line">						&#125;</span><br><span class="line">					&lt;/script&gt;</span><br><span class="line">					&lt;script src=&#x27;/index.js&#x27;&gt;&lt;/script&gt;</span><br><span class="line">				&lt;/body&gt;</span><br><span class="line">			&lt;/html&gt;</span><br><span class="line">	  `;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="预渲染解决-SEO"><a href="#预渲染解决-SEO" class="headerlink" title="预渲染解决 SEO"></a>预渲染解决 SEO</h3><p>访问一个普通 react 项目链接，爬虫蜘蛛也访问项目链接<br>可以通过识别爬虫蜘蛛访问的时候预渲染 dom 返回给爬虫。</p>
<h3 id="prerender-模块"><a href="#prerender-模块" class="headerlink" title="prerender 模块"></a>prerender 模块</h3><ul>
<li><p>创建 prerender 服务器<br>访问时加上查询参数 ?url&#x3D;${url} 预渲染服务就会先去访问 url 再返回给爬虫</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const prerender = require(&#x27;prerender&#x27;);</span><br><span class="line">const server = prerender(&#123;</span><br><span class="line">	port: 8000</span><br><span class="line">&#125;);</span><br><span class="line">server.start();</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 nginx 识别用户和爬虫<br>nginx 识别爬虫就访问 prerender，识别是人就访问 react 项目</p>
</li>
<li><p>prerender 官网参考</p>
</li>
</ul>
<blockquote>
<p>引用</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://prerender.io/">https://prerender.io/</a></p>

            </div>
        </div>
    </article>

    
    
<nav class="article-nav">
  
    <a href="/2019/01/14/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E3%80%81TCP%7CIP%20%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%20/" id="article-nav-newer" class="article-nav-link-wrap prev">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          网络基础、TCP/IP 三次握手和四次挥手
        
      </div>
    </a>
  
  
    <a href="/2018/12/23/%E5%91%A8%E5%B8%B82%20%E7%AE%97%E6%B3%95%E9%A2%984%E9%81%93%E3%80%81react%20ssr%20%E5%8E%9F%E7%90%86%E5%AE%9E%E8%B7%B5%E3%80%81koa-router%20%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/" id="article-nav-older" class="article-nav-link-wrap next">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">周常2 算法题4道、react ssr 原理实践、koa-router 源码阅读</div>
    </a>
  
</nav>

    

    
</div>
    </div>
    <footer class="site-footer">
        <div class="global-width">
            <ul class="site-widget">
                
                <li class="widget widget-tag">
                    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget-body">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/JavaScript/" rel="tag">JavaScript</a><span class="tag-list-count">6</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/React/" rel="tag">React</a><span class="tag-list-count">5</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/React-Tips/" rel="tag">React Tips</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Redux/" rel="tag">Redux</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Vue/" rel="tag">Vue</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/css/" rel="tag">css</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/dom/" rel="tag">dom</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/http/" rel="tag">http</a><span class="tag-list-count">8</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/nodejs/" rel="tag">nodejs</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/react/" rel="tag">react</a><span class="tag-list-count">6</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/sftp/" rel="tag">sftp</a><span class="tag-list-count">1</span></li></ul>
    </div>
  </div>

                </li>
                
                <li class="widget widget-category">
                    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget-body">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Font-End-Basis/">Font-End Basis</a><span class="category-list-count">11</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/React/">React</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Vue/">Vue</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/css/">css</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/http/">http</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/network/">network</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/nodejs/">nodejs</a><span class="category-list-count">2</span></li></ul>
    </div>
  </div>

                </li>
                
                <li class="widget widget-recent_posts">
                    
  <div class="widget-wrap">
    <h3 class="widget-title">Recents</h3>
    <div class="widget-body">
      <ul>
        
          <li>
            <a href="/2019/08/23/React%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%20-%20commitRoot%20%E6%9B%B4%E6%96%B0%E4%BB%BB%E5%8A%A1%20dom%20%E8%8A%82%E7%82%B9%20/">React 源码解析 - commitRoot 更新任务 dom 节点</a>
          </li>
        
          <li>
            <a href="/2019/06/21/React%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%20-%20renderRoot%20%E5%AE%8C%E6%88%90%E8%8A%82%E7%82%B9%E6%9B%B4%E6%96%B0%E4%BB%BB%E5%8A%A1%20/">React 源码解析 - renderRoot 完成节点更新任务</a>
          </li>
        
          <li>
            <a href="/2019/06/03/React%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%20-%20%E6%9B%B4%E6%96%B0%E6%B5%81%E7%A8%8B%20renderRoot%20%E6%B8%B2%E6%9F%93%E9%98%B6%E6%AE%B5%20/">React 源码解析 - 更新流程 renderRoot 渲染阶段</a>
          </li>
        
          <li>
            <a href="/2019/05/21/TCP%20%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/">TCP 拥塞控制</a>
          </li>
        
          <li>
            <a href="/2019/02/27/React%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%20-%20reactScheduler%20%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%20/">React 源码解析 - reactScheduler 异步任务调度</a>
          </li>
        
      </ul>
    </div>
  </div>

                </li>
                
            </ul>
        </div>
        <div class="site-info">
            <address>
                &copy; 2014 <a href="http://yoursite.com">Minimalist</a> All Right Reserved. <br/>
                Powered by <a target="_blank" rel="noopener" href="http://hexo.io">Hexo</a>. Theme by <a target="_blank" rel="noopener" href="http://zzoman.com">ZZOMAN</a>
            </address>
        </div>
    </footer>
    
    <script src="/libs/jquery-1.11.3.min.js" type="text/javascript"></script>
    
    <script src="/libs/fancybox/jquery.fancybox.js" type="text/javascript"></script>
    
    <script src="/js/site_init.js" type="text/javascript"></script>
    
</body>
</html>
<!doctype html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge">
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    
    <title>React 源码解析 - reactScheduler 异步任务调度 | Minimalist</title>
    
    <link rel="alternative" href="/atom.xml" title="Minimalist" type="application/atom+xml">
    
    
<link rel="stylesheet" href="/css/style.css">

    
    <link rel="stylesheet" href="/libs/fancybox/jquery.fancybox.css" charset="utf-8">
    
    <!--[if lt IE 9]>
    <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
    <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
<meta name="generator" content="Hexo 6.3.0"></head>
<body class="site">
    <header class="site-header">
        <h1 class="site-title"><a href="/">Minimalist</a></h1>
        <nav class="site-nav">
            <ul class="nav">
                
                <li><a href="/archives">Archives</a></li>
                
                
                <li><a target="_blank" rel="noopener" href="https://github.com/sfyr111" title="git">GITHUB</a></li>
                
                <li><a class="toggle-search" href="#search">search</a></li>
            </ul>
        </nav>
        <div class="site-search" id="search">
            <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
        </div>
        
            <div class="site-header-background" style="background-image:url(http://reumia.github.io/hexo-theme-zzoman2015/images/background-zzoman2015.jpg)"></div>
        
    </header>
    <div class="site-body">
        <div class="global-width">
    <article class="article" data-layout="post" data-slug="React 源码解析 - reactScheduler 异步任务调度 ">
        <div class="article-content">
            
            
            <header class="article-header">
                <div class="article-meta">
                    <a href="/2019/02/27/React%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%20-%20reactScheduler%20%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%20/" class="article-date">
  <time datetime="2019-02-27T14:07:11.000Z">2019-02-27</time>
</a>
                    
                    
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/react/" rel="tag">react</a></li></ul>

                </div>
                
    <h1 class="article-title" itemprop="name">
      <a href="/2019/02/27/React%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%20-%20reactScheduler%20%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%20/">React 源码解析 - reactScheduler 异步任务调度</a>
    </h1>

            </header>
            
            <div class="article-body">
                <h2 id="reactScheduler-异步调度"><a href="#reactScheduler-异步调度" class="headerlink" title="reactScheduler 异步调度"></a>reactScheduler 异步调度</h2><h3 id="核心功能"><a href="#核心功能" class="headerlink" title="核心功能"></a>核心功能</h3><ul>
<li>维护时间片</li>
<li>模拟浏览器 requestldleCallback API (会等待浏览器执行完其他任务后有空闲时再回来执行回调)<br><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestIdleCallback">[requestIdleCallback MDN]</a>, <a target="_blank" rel="noopener" href="http://www.zhangyunling.com/702.html">[requestIdleCallback 后台任务调度]</a></li>
<li>调度列表和超时判断</li>
</ul>
<h3 id="时间片概念"><a href="#时间片概念" class="headerlink" title="时间片概念"></a>时间片概念</h3><p>用户感觉流畅界面至少需要 1秒30帧的刷新频率，每一帧只有 33ms 来执行。</p>
<ul>
<li>一帧 33ms，react 更新需要 20ms, 浏览器执行动画或用户反馈的时间只有 13ms，但是这一帧仍然是可以执行浏览器的动作。</li>
<li>如果 react 更新需要 43ms, 还需要向下一帧借用 10ms， 浏览器在这第一帧中就没有时间去执行自己的任务，就会造成卡顿。</li>
<li>requestldleCallback API 会在浏览器空闲时依次调用函数，让浏览器在每一帧里都有足够的时间去执行动画或用户反馈，防止 react 更新占用掉一帧的所有时间。</li>
</ul>
<h2 id="scheduleCallbackWithExpirationTime-异步任务调度"><a href="#scheduleCallbackWithExpirationTime-异步任务调度" class="headerlink" title="scheduleCallbackWithExpirationTime 异步任务调度"></a>scheduleCallbackWithExpirationTime 异步任务调度</h2><h3 id="进入-scheduleCallbackWithExpirationTime"><a href="#进入-scheduleCallbackWithExpirationTime" class="headerlink" title="进入 scheduleCallbackWithExpirationTime"></a>进入 scheduleCallbackWithExpirationTime</h3><p>在 requestWork 中如果判断是异步调度的方法就会执行 scheduleCallbackWithExpirationTime</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function requestWork(root: FiberRoot, expirationTime: ExpirationTime) &#123;</span><br><span class="line">  // ...</span><br><span class="line">  if (expirationTime === Sync) &#123; // 同步的调用 js 代码</span><br><span class="line">    performSyncWork();</span><br><span class="line">  &#125; else &#123; // 异步调度 独立的 react 模块包，利用浏览器有空闲的时候进行执行，设置 deadline 在此之前执行</span><br><span class="line">    scheduleCallbackWithExpirationTime(root, expirationTime); // 在 secheduler 文件夹下的单独模块</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="scheduleCallbackWithExpirationTime-源码"><a href="#scheduleCallbackWithExpirationTime-源码" class="headerlink" title="scheduleCallbackWithExpirationTime 源码"></a>scheduleCallbackWithExpirationTime 源码</h3><ul>
<li>把 FiberRoot 加入调度<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">// scheduler 调度</span><br><span class="line">function scheduleCallbackWithExpirationTime(</span><br><span class="line">  root: FiberRoot,</span><br><span class="line">  expirationTime: ExpirationTime,</span><br><span class="line">) &#123;</span><br><span class="line">  // callbackExpirationTime 是上一次调度的任务优先级</span><br><span class="line">  if (callbackExpirationTime !== NoWork) &#123;</span><br><span class="line">    // A callback is already scheduled. Check its expiration time (timeout).</span><br><span class="line">    if (expirationTime &gt; callbackExpirationTime) &#123; // 当前优先级比之前正在执行的优先级低就停止</span><br><span class="line">      // Existing callback has sufficient timeout. Exit.</span><br><span class="line">      return;</span><br><span class="line">    &#125; else &#123; // 当前优先级更高</span><br><span class="line">      if (callbackID !== null) &#123;</span><br><span class="line">        // Existing callback has insufficient timeout. Cancel and schedule a</span><br><span class="line">        // new one. // 退出了</span><br><span class="line">        cancelDeferredCallback(callbackID);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // The request callback timer is already running. Don&#x27;t start a new one.</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    startRequestCallbackTimer(); // 不看</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  callbackExpirationTime = expirationTime; // 保存当前任务</span><br><span class="line">  const currentMs = now() - originalStartTimeMs; // originalStartTimeMs 是 react 加载的最初时间, 记录当前时间差</span><br><span class="line">  const expirationTimeMs = expirationTimeToMs(expirationTime); // 转化成 ms</span><br><span class="line">  const timeout = expirationTimeMs - currentMs; // 过期时间</span><br><span class="line">  callbackID = scheduleDeferredCallback(performAsyncWork, &#123;timeout&#125;); // 赖在 Scheduler 模块 返回 id 用来 cancel</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>timeout 为当前任务的延迟过期时间，由过期时间 - 当前任务创建时间得出，超过时代表任务过期需要强制更新</li>
<li>通过 scheduleDeferredCallback 生成一个 callbackID，用于关闭任务</li>
</ul>
<h2 id="scheduleCallback"><a href="#scheduleCallback" class="headerlink" title="scheduleCallback"></a>scheduleCallback</h2><p>Scheduler 包中的 scheduleCallback</p>
<h3 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a>实现细节</h3><ul>
<li>维护一个 firstCallbackNode 的任务环状链表结构</li>
<li>比较当前任务的优先级对 firstCallbackNode 的链表任务进行排序</li>
<li>对链表上的 callback 任务排好序后使用 ensureHostCallbackIsScheduled 进行调度</li>
<li>当 firstCallbackNode 链表的首个任务改变时调用 ensureHostCallbackIsScheduled 进行调度，firstCallbackNode 没改变按原来的优先级执行<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">// scheduleDeferredCallback, 传入 performAsyncWork, &#123; timeout &#125;</span><br><span class="line">function unstable_scheduleCallback(callback, deprecated_options) &#123;</span><br><span class="line">  var startTime =</span><br><span class="line">    currentEventStartTime !== -1 ? currentEventStartTime : getCurrentTime(); // 其实就是 Date.now()</span><br><span class="line"></span><br><span class="line">  var expirationTime;</span><br><span class="line">  if (</span><br><span class="line">    typeof deprecated_options === &#x27;object&#x27; &amp;&amp;</span><br><span class="line">    deprecated_options !== null &amp;&amp;</span><br><span class="line">    typeof deprecated_options.timeout === &#x27;number&#x27;</span><br><span class="line">  ) &#123;</span><br><span class="line">    // expirationTime 的逻辑有可能全部搬到 Scheduler 包里</span><br><span class="line">    expirationTime = startTime + deprecated_options.timeout; // Date.now() + timeout 只会进入这里</span><br><span class="line">  &#125; else &#123; // 以后是这个逻辑</span><br><span class="line">    switch (currentPriorityLevel) &#123;</span><br><span class="line">      case ImmediatePriority: // sync</span><br><span class="line">        expirationTime = startTime + IMMEDIATE_PRIORITY_TIMEOUT;</span><br><span class="line">        break;</span><br><span class="line">      case UserBlockingPriority:</span><br><span class="line">        expirationTime = startTime + USER_BLOCKING_PRIORITY;</span><br><span class="line">        break;</span><br><span class="line">      case IdlePriority:</span><br><span class="line">        expirationTime = startTime + IDLE_PRIORITY;</span><br><span class="line">        break;</span><br><span class="line">      case NormalPriority:</span><br><span class="line">      default:</span><br><span class="line">        expirationTime = startTime + NORMAL_PRIORITY_TIMEOUT;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  var newNode = &#123;</span><br><span class="line">    callback, //  performAsyncWork</span><br><span class="line">    priorityLevel: currentPriorityLevel, // 用不到</span><br><span class="line">    expirationTime, // timeout + now()</span><br><span class="line">    next: null, // 链表结构</span><br><span class="line">    previous: null,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line"> // firstCallbackNode 是维护的单向链表头部</span><br><span class="line">  if (firstCallbackNode === null) &#123; // 单向链表头部 null 还没有元素, 当前 callback 就是第一个</span><br><span class="line">    // firstCallbackNode 链表 pre next 都为当前 callback 的 newNode</span><br><span class="line">    firstCallbackNode = newNode.next = newNode.previous = newNode;</span><br><span class="line">    ensureHostCallbackIsScheduled(); // firstCallbackNode 改变需要调用 进入调度过程</span><br><span class="line">  &#125; else &#123; // 链表上已经有多个 newNode 了</span><br><span class="line">    var next = null;</span><br><span class="line">    var node = firstCallbackNode;</span><br><span class="line">    do &#123;</span><br><span class="line">      // 根据 expirationTime 排序，把优先级大的放在前面, 这里是跟 firstCallbackNode 链表头比较</span><br><span class="line">      if (node.expirationTime &gt; expirationTime) &#123;</span><br><span class="line">        next = node; // next 变为 fristCallbackNode</span><br><span class="line">        break;</span><br><span class="line">      &#125;</span><br><span class="line">      node = node.next; // 循环</span><br><span class="line">    &#125; while (node !== firstCallbackNode);</span><br><span class="line"></span><br><span class="line">    if (next === null) &#123; // 当前优先级小，如果 node.expirationTime &lt; expirationTime,  当前的优先级是最小的</span><br><span class="line">      next = firstCallbackNode; // 当前优先级小，next 为原来的 firstCallbackNode</span><br><span class="line">    &#125; else if (next === firstCallbackNode) &#123; // 当前优先级大，firstCallbackNode 优先级没有当前的大</span><br><span class="line">      firstCallbackNode = newNode; // 当前优先级大， firstCallbackNode 为当前的</span><br><span class="line">      ensureHostCallbackIsScheduled(); // firstCallbackNode 改变需要调用  进入调度过程</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // next 为 fristCallbackNode 来看，把 next 放到原 firstCallbackNode 的位置，链表重新排序</span><br><span class="line">    var previous = next.previous;</span><br><span class="line">    previous.next = next.previous = newNode;</span><br><span class="line">    newNode.next = next;</span><br><span class="line">    newNode.previous = previous; // 形成环状的链表结构</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return newNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="ensureHostCallbackIsScheduled"><a href="#ensureHostCallbackIsScheduled" class="headerlink" title="ensureHostCallbackIsScheduled"></a>ensureHostCallbackIsScheduled</h3><ul>
<li>检查是否用 callbackNode 正在执行，否则停止</li>
<li>判断 hostCallback 是否在调度，已经调度就取消</li>
<li>执行 requestHostCallback 方法<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function ensureHostCallbackIsScheduled() &#123;</span><br><span class="line">  if (isExecutingCallback) &#123; // 代表已经有个 callbackNode 调用了</span><br><span class="line">    // Don&#x27;t schedule work yet; wait until the next time we yield.</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line">  // Schedule the host callback using the earliest expiration in the list.</span><br><span class="line">  var expirationTime = firstCallbackNode.expirationTime;</span><br><span class="line">  if (!isHostCallbackScheduled) &#123; // 判断这个 callback 有没有进入调度</span><br><span class="line">    isHostCallbackScheduled = true;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    // Cancel the existing host callback.</span><br><span class="line">    cancelHostCallback(); // 已经有了就退出</span><br><span class="line">  &#125;</span><br><span class="line">  // 执行</span><br><span class="line">  requestHostCallback(flushWork, expirationTime);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="requestHostCallback"><a href="#requestHostCallback" class="headerlink" title="requestHostCallback"></a>requestHostCallback</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">requestHostCallback = function(callback, absoluteTimeout) &#123;</span><br><span class="line">  scheduledHostCallback = callback;</span><br><span class="line">  timeoutTime = absoluteTimeout;</span><br><span class="line">  // absoluteTimeout &lt; 0 已经超时了，isFlushingHostCallback 强制执行</span><br><span class="line">  if (isFlushingHostCallback || absoluteTimeout &lt; 0) &#123;</span><br><span class="line">    // 不等了直接调用</span><br><span class="line">    // Don&#x27;t wait for the next frame. Continue working ASAP, in a new event.</span><br><span class="line">    window.postMessage(messageKey, &#x27;*&#x27;);</span><br><span class="line">  &#125; else if (!isAnimationFrameScheduled) &#123; // isAnimationFrameScheduled = false 还没进入调度循环</span><br><span class="line">    // If rAF didn&#x27;t already schedule one, we need to schedule a frame.</span><br><span class="line">    // TODO: If this rAF doesn&#x27;t materialize because the browser throttles, we</span><br><span class="line">    // might want to still have setTimeout trigger rIC as a backup to ensure</span><br><span class="line">    // that we keep performing work.</span><br><span class="line">    isAnimationFrameScheduled = true; // 进入调度循环</span><br><span class="line">    requestAnimationFrameWithTimeout(animationTick); // 进入调度，竞争调用 animationTick</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="requestAnimationFrameWithTimeout"><a href="#requestAnimationFrameWithTimeout" class="headerlink" title="requestAnimationFrameWithTimeout"></a>requestAnimationFrameWithTimeout</h3><ul>
<li>requestAnimationFrameWithTimeout 里，把 animationTick callback 放入浏览器动画回调里，如果 100ms 后还没有执行就通过 timeout 自动执行。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 100ms 内竞争调用 本地 localRequestAnimationFrame 和 localSetTimeout</span><br><span class="line">var requestAnimationFrameWithTimeout = function(callback) &#123;</span><br><span class="line">  // localRequestAnimationFrame 执行了，就取消 localSetTimeout, 互相竞争的关系</span><br><span class="line">  rAFID = localRequestAnimationFrame(function(timestamp) &#123; // 浏览器的 api</span><br><span class="line">    localClearTimeout(rAFTimeoutID);</span><br><span class="line">    callback(timestamp); // 传入动画时间戳</span><br><span class="line">  &#125;);</span><br><span class="line">  // 如果 100ms localRequestAnimationFrame 里的 callback 没执行，就取消 localRequestAnimationFrame 自己执行</span><br><span class="line">  rAFTimeoutID = localSetTimeout(function() &#123;</span><br><span class="line">    localCancelAnimationFrame(rAFID);</span><br><span class="line">    callback(getCurrentTime()); // 传入当前时间</span><br><span class="line">  &#125;, ANIMATION_FRAME_TIMEOUT);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="animationTick"><a href="#animationTick" class="headerlink" title="animationTick"></a>animationTick</h3><ul>
<li>处于浏览器 requestAnimationFrame 的回调中，为了节约时间不停地调用自己</li>
<li>通过 前后两次调用时间来判断当前浏览器的刷新频率</li>
<li>当 isMessageEventScheduled 变量为 false 后 通过 postMessage 发送事件给任务队列插入 react 任务，这才是一帧中做的事。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">// rafTime 就是 animationTick 调用的时间</span><br><span class="line">var animationTick = function(rafTime) &#123;</span><br><span class="line">  if (scheduledHostCallback !== null) &#123;</span><br><span class="line">    // 立马请求下一帧调用自己, 不停的调用, 队列有很多 callback</span><br><span class="line">    requestAnimationFrameWithTimeout(animationTick);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    // 没有方法要被调度</span><br><span class="line">    isAnimationFrameScheduled = false;</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line">  // rafTime 调用的当前时间，frameDeadline 为 0， activeFrameTime 33 保持浏览器一秒 30 帧每一帧的执行时间-一帧完整的时间</span><br><span class="line">  // 下一帧我可以执行的时间是多少</span><br><span class="line">  var nextFrameTime = rafTime - frameDeadline + activeFrameTime;</span><br><span class="line">  if (</span><br><span class="line">    nextFrameTime &lt; activeFrameTime &amp;&amp;</span><br><span class="line">    previousFrameTime &lt; activeFrameTime</span><br><span class="line">  ) &#123; // 如果连续两次帧的调用计算出来的时间是小于33ms 目前的帧时间的，就设置帧时间变小. 主要针对不同平台，比如 vr 120帧，设置平台的刷新平台设置 activeFrameTime</span><br><span class="line">    if (nextFrameTime &lt; 8) &#123;</span><br><span class="line">      nextFrameTime = 8;</span><br><span class="line">    &#125;</span><br><span class="line">    activeFrameTime =</span><br><span class="line">      nextFrameTime &lt; previousFrameTime ? previousFrameTime : nextFrameTime;</span><br><span class="line">  &#125; else &#123; //</span><br><span class="line">    previousFrameTime = nextFrameTime;</span><br><span class="line">  &#125;</span><br><span class="line">  frameDeadline = rafTime + activeFrameTime; // 第一个 frameDeadLine</span><br><span class="line">  if (!isMessageEventScheduled) &#123;</span><br><span class="line">    isMessageEventScheduled = true;</span><br><span class="line">    window.postMessage(messageKey, &#x27;*&#x27;); // 给任务队列插入 react 任务，等浏览器执行完自己的任务再执行这里队列里的</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="idleTick"><a href="#idleTick" class="headerlink" title="idleTick"></a>idleTick</h3><ul>
<li>接受判断 react 任务</li>
<li>判断当前帧是否把时间用完了，帧时间用完了任务又过期了 didTimout 标志过期</li>
<li>没用完继续或调用动画，保存任务等它过期再调用</li>
<li>最后判断 callback 不为空，调用过期的 react 任务。</li>
<li>这个方法保证了动画最大限度的执行，react 更新任务只有到时间才会执行<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">window.addEventListener(&#x27;message&#x27;, idleTick, false); // 接受 react 任务队列</span><br><span class="line"></span><br><span class="line">  var idleTick = function(event) &#123;</span><br><span class="line">    // 判断 key，避免接收到其他非 react 的消息</span><br><span class="line">    if (event.source !== window || event.data !== messageKey) &#123;</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    isMessageEventScheduled = false;</span><br><span class="line">    // 赋值再重置 scheduledHostCallback 是 requestHostCallback 传入的 flushWork</span><br><span class="line">    var prevScheduledCallback = scheduledHostCallback;</span><br><span class="line">    var prevTimeoutTime = timeoutTime;</span><br><span class="line">    scheduledHostCallback = null;</span><br><span class="line">    timeoutTime = -1;</span><br><span class="line"></span><br><span class="line">    var currentTime = getCurrentTime();</span><br><span class="line"></span><br><span class="line">    var didTimeout = false;</span><br><span class="line">    // 浏览器动画或用户反馈操作超过 33ms, 把这一帧的时间用完了，react 没有时间去更新了</span><br><span class="line">    if (frameDeadline - currentTime &lt;= 0) &#123;</span><br><span class="line">      // prevTimeoutTime 也就是 timeoutTime &lt;= currentTime，当前任务也已经过期了，需要强行更新了</span><br><span class="line">      if (prevTimeoutTime !== -1 &amp;&amp; prevTimeoutTime &lt;= currentTime) &#123;</span><br><span class="line">        didTimeout = true; // 准备强制更新</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        // No timeout. 没过期直接调用 requestAnimationFrameWithTimeout</span><br><span class="line">        if (!isAnimationFrameScheduled) &#123;</span><br><span class="line">          isAnimationFrameScheduled = true;</span><br><span class="line">          requestAnimationFrameWithTimeout(animationTick);</span><br><span class="line">        &#125;</span><br><span class="line">        scheduledHostCallback = prevScheduledCallback;</span><br><span class="line">        timeoutTime = prevTimeoutTime;</span><br><span class="line">        return;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // callback 不为空</span><br><span class="line">    if (prevScheduledCallback !== null) &#123;</span><br><span class="line">      isFlushingHostCallback = true; // 正在调用这个 callback</span><br><span class="line">      try &#123; // 强制执行</span><br><span class="line">        prevScheduledCallback(didTimeout);</span><br><span class="line">      &#125; finally &#123;</span><br><span class="line">        isFlushingHostCallback = false; // 强制更新完恢复 false</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="flushWork"><a href="#flushWork" class="headerlink" title="flushWork"></a>flushWork</h2><ul>
<li>通过判断 callback 已经过期或当前帧还有时间才开始真正执行</li>
<li>finally 最后 firstCallbackNode 不为空调 isHostCallbackScheduled 为 true , ensureHostCallbackIsScheduled 会执行 cancelHostCallback 重置所有的调度常量，老 callback 就不会被执行<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">// 强制执行过期任务</span><br><span class="line">function flushWork(didTimeout) &#123;</span><br><span class="line">  isExecutingCallback = true; // 开始真正调用 callback</span><br><span class="line">  deadlineObject.didTimeout = didTimeout;</span><br><span class="line">  try &#123;</span><br><span class="line">    if (didTimeout) &#123; // firstCallbackNode 已经过期</span><br><span class="line">      // Flush all the expired callbacks without yielding.</span><br><span class="line">      while (firstCallbackNode !== null) &#123; </span><br><span class="line">        var currentTime = getCurrentTime();</span><br><span class="line">        // 第一个 expirationTime 肯定小于 currentTime, 为过期任务</span><br><span class="line">        if (firstCallbackNode.expirationTime &lt;= currentTime) &#123;</span><br><span class="line">          do &#123;</span><br><span class="line">            // 执行的同时进行链表操作</span><br><span class="line">            flushFirstCallback(); // 真正执行了回调, 一直到第一个没有过期的任务为止</span><br><span class="line">          &#125; while (</span><br><span class="line">            firstCallbackNode !== null &amp;&amp;</span><br><span class="line">            firstCallbackNode.expirationTime &lt;= currentTime // 链表循环判断过期了</span><br><span class="line">          );</span><br><span class="line">          continue;</span><br><span class="line">        &#125;</span><br><span class="line">        break;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      //继续刷新回调，直到帧中的时间不足为止。</span><br><span class="line">      // Keep flushing callbacks until we run out of time in the frame.</span><br><span class="line">      if (firstCallbackNode !== null) &#123;</span><br><span class="line">        do &#123;</span><br><span class="line">          flushFirstCallback();</span><br><span class="line">        &#125; while (</span><br><span class="line">          firstCallbackNode !== null &amp;&amp;</span><br><span class="line">          getFrameDeadline() - getCurrentTime() &gt; 0 // 帧还有时间空闲才执行</span><br><span class="line">        );</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; finally &#123;</span><br><span class="line">    isExecutingCallback = false;</span><br><span class="line">    if (firstCallbackNode !== null) &#123;</span><br><span class="line">      ensureHostCallbackIsScheduled();// 这时候执行 isHostCallbackScheduled 为 true 会执行 cancelHostCallback 重置所有的调度常量，老 callback 就不会被执行</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      isHostCallbackScheduled = false;</span><br><span class="line">    &#125;</span><br><span class="line">    flushImmediateWork();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="deadlineObject-timeRemaining"><a href="#deadlineObject-timeRemaining" class="headerlink" title="deadlineObject.timeRemaining"></a>deadlineObject.timeRemaining</h3><ul>
<li>deadlineObject 上 还有个 timeRemaining 属性 剩余时间</li>
<li>remaining 表示 这一帧的渲染是否超过 在 shouldYield 中使用并判断<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">var timeRemaining; // 剩余时间</span><br><span class="line">if (hasNativePerformanceNow) &#123;</span><br><span class="line">  timeRemaining = function() &#123;</span><br><span class="line">    if (</span><br><span class="line">      firstCallbackNode !== null &amp;&amp;</span><br><span class="line">      firstCallbackNode.expirationTime &lt; currentExpirationTime // 不成立 不看</span><br><span class="line">    ) &#123;</span><br><span class="line">      return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    var remaining = getFrameDeadline() - performance.now();</span><br><span class="line">    return remaining &gt; 0 ? remaining : 0; // 这一帧的渲染是否超过 在 shouldYield 中使用并判断</span><br><span class="line">  &#125;;</span><br><span class="line">&#125; else &#123; // 不走这里</span><br><span class="line">  timeRemaining = function() &#123;</span><br><span class="line">    // Fallback to Date.now()</span><br><span class="line">    if (</span><br><span class="line">      firstCallbackNode !== null &amp;&amp;</span><br><span class="line">      firstCallbackNode.expirationTime &lt; currentExpirationTime</span><br><span class="line">    ) &#123;</span><br><span class="line">      return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    var remaining = getFrameDeadline() - Date.now();</span><br><span class="line">    return remaining &gt; 0 ? remaining : 0; // 判断这一帧是否已经超过</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="shouldYield"><a href="#shouldYield" class="headerlink" title="shouldYield"></a>shouldYield</h3><ul>
<li>用来 timeRemaining 剩余时间跟常量比较获取是否该跳出的判断<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 应该跳出了</span><br><span class="line">function shouldYield() &#123;</span><br><span class="line">  if (deadlineDidExpire) &#123;</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line">  if (</span><br><span class="line">    deadline === null ||</span><br><span class="line">    deadline.timeRemaining() &gt; timeHeuristicForUnitOfWork // 通过比较常量</span><br><span class="line">  ) &#123; // 当前帧 return false 还有剩余时间可以执行</span><br><span class="line">    return false;</span><br><span class="line">  &#125;</span><br><span class="line">  deadlineDidExpire = true; // 这一帧的渲染时间已经超时</span><br><span class="line">  return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="flushFirstCallback"><a href="#flushFirstCallback" class="headerlink" title="flushFirstCallback"></a>flushFirstCallback</h3><ul>
<li>处理链表后执行 callback</li>
<li>callbackID &#x3D; scheduleDeferredCallback(performAsyncWork, {timeout});<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">function flushFirstCallback() &#123;</span><br><span class="line">  var flushedNode = firstCallbackNode;</span><br><span class="line"></span><br><span class="line">  // Remove the node from the list before calling the callback. That way the</span><br><span class="line">  // list is in a consistent state even if the callback throws.</span><br><span class="line">  var next = firstCallbackNode.next;</span><br><span class="line">  if (firstCallbackNode === next) &#123; // 链表当前元素等于下一个，已经为空了</span><br><span class="line">    // This is the last callback in the list.</span><br><span class="line">    firstCallbackNode = null;</span><br><span class="line">    next = null;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    // 环状结构</span><br><span class="line">    var lastCallbackNode = firstCallbackNode.previous;</span><br><span class="line">    firstCallbackNode = lastCallbackNode.next = next;</span><br><span class="line">    next.previous = lastCallbackNode;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  flushedNode.next = flushedNode.previous = null;</span><br><span class="line"></span><br><span class="line">  // Now it&#x27;s safe to call the callback.</span><br><span class="line">  var callback = flushedNode.callback;</span><br><span class="line">  var expirationTime = flushedNode.expirationTime;</span><br><span class="line">  var priorityLevel = flushedNode.priorityLevel;</span><br><span class="line">  var previousPriorityLevel = currentPriorityLevel;</span><br><span class="line">  var previousExpirationTime = currentExpirationTime;</span><br><span class="line">  currentPriorityLevel = priorityLevel;</span><br><span class="line">  currentExpirationTime = expirationTime;</span><br><span class="line">  var continuationCallback;</span><br><span class="line">  try &#123;</span><br><span class="line">    continuationCallback = callback(deadlineObject); // 执行 callback</span><br><span class="line">  &#125; finally &#123;</span><br><span class="line">    currentPriorityLevel = previousPriorityLevel;</span><br><span class="line">    currentExpirationTime = previousExpirationTime;</span><br><span class="line">  &#125;</span><br><span class="line">// ... 暂时没作用</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="performWork"><a href="#performWork" class="headerlink" title="performWork"></a>performWork</h2><ul>
<li>调度完成回到 ReactDOM</li>
<li>performWork 通过 performAsyncWork 异步方式 和 performSyncWork 同步方式调用</li>
<li>异步情况给 performWork 设置的 minExpirationTime 是 NoWork 0，并且会判断dl.didTimeout，这个值是指任务的 expirationTime 是否已经超时，如果超时了，则通过 didExpireAtExpirationTime 直接设置 newExpirationTimeToWorkOn 为当前时间，表示这个任务直接执行就行了，不需要判断是否超过了帧时间</li>
<li>同步方式久比较简单了，设置 minExpirationTime 为 Sync 1<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function performAsyncWork(dl) &#123;</span><br><span class="line">  // true</span><br><span class="line">  if (dl.didTimeout) &#123; // 任务过期，立即执行</span><br><span class="line">    if (firstScheduledRoot !== null) &#123;</span><br><span class="line">      recomputeCurrentRendererTime(); // 设置当前渲染时间为当前时间</span><br><span class="line">      let root: FiberRoot = firstScheduledRoot;</span><br><span class="line">      do &#123;</span><br><span class="line">        // 标记 root 节点变量, 如果当前任务过期设置为当前时间为 expirationTime</span><br><span class="line">        didExpireAtExpirationTime(root, currentRendererTime);</span><br><span class="line">        root = (root.nextScheduledRoot: any); // 下一个 root</span><br><span class="line">      &#125; while (root !== firstScheduledRoot);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  performWork(NoWork, dl);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function performSyncWork() &#123;</span><br><span class="line">  performWork(Sync, null);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="核心功能-1"><a href="#核心功能-1" class="headerlink" title="核心功能"></a>核心功能</h3><ul>
<li>是否有 deadline 的区分<br>时间片更新后还有没有时间</li>
<li>循环渲染 Root 的条件<br>循环不同 root 和不同优先级任务来更新</li>
<li>超过时间片的处理<br>dealine 这一帧的时间到了把执行权交回浏览器</li>
</ul>
<h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><ul>
<li>通过 findHighestPriorityRoot  找到优先级最高的下一个需要渲染的 root: nextFlushedRoot 和对应的 expirtaionTime: nextFlushedExpirationTime</li>
<li>根据 deadline 判断 performWorkOnRoot 参数</li>
<li>相同部分<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nextFlushedRoot !== null &amp;&amp; // 判断下一个输出节点不是 null</span><br><span class="line">nextFlushedExpirationTime !== NoWork &amp;&amp; // 过期时间不是 NoWork</span><br><span class="line">(minExpirationTime === NoWork || // 超时时间是 NoWork</span><br><span class="line">  minExpirationTime &gt;= nextFlushedExpirationTime) &amp;&amp; // 超时时间大于下个节点或</span><br></pre></td></tr></table></figure>
普通情况 minExpirationTime 应该就等于nextFlushedExpirationTime 因为都来自同一个 root，nextFlushedExpirationTime 是在 findHighestPriorityRoot 阶段读取出来的 root.expirationTime</li>
<li>异步的判断<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">    while (</span><br><span class="line">      nextFlushedRoot !== null &amp;&amp;</span><br><span class="line">      nextFlushedExpirationTime !== NoWork &amp;&amp;</span><br><span class="line">      (minExpirationTime === NoWork ||</span><br><span class="line">        minExpirationTime &gt;= nextFlushedExpirationTime) &amp;&amp;</span><br><span class="line">        // deadlineDidExpire 判断时间片是否过期 shouldYield 中判断</span><br><span class="line">      (!deadlineDidExpire || currentRendererTime &gt;= nextFlushedExpirationTime) // currentRendererTime &gt;= nextFlushedExpirationTime 超时了</span><br><span class="line">      performWorkOnRoot(</span><br><span class="line">        nextFlushedRoot,</span><br><span class="line">        nextFlushedExpirationTime,</span><br><span class="line">        currentRendererTime &gt;= nextFlushedExpirationTime, // 超时了</span><br><span class="line">      );</span><br><span class="line">// ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
deadline 设置的 deadlineDidExpire 用来判断时间片是否到期的<br>当前渲染时间 currentRendererTime 比较 nextFlushedExpirationTime 判断任务是否已经超时<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(!deadlineDidExpire || currentRendererTime &gt;= nextFlushedExpirationTime)</span><br></pre></td></tr></table></figure></li>
<li>同步的判断<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">    while (</span><br><span class="line">      nextFlushedRoot !== null &amp;&amp;</span><br><span class="line">      nextFlushedExpirationTime !== NoWork &amp;&amp;</span><br><span class="line">      (minExpirationTime === NoWork ||</span><br><span class="line">        minExpirationTime &gt;= nextFlushedExpirationTime)</span><br><span class="line">    ) &#123;</span><br><span class="line">      performWorkOnRoot(nextFlushedRoot, nextFlushedExpirationTime, true);</span><br><span class="line">// ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>全部流程<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">// currentRendererTime 计算从页面加载到现在为止的毫秒数</span><br><span class="line">// currentSchedulerTime 也是加载到现在的时间，isRendering === true的时候用作固定值返回，不然每次requestCurrentTime都会重新计算新的时间</span><br><span class="line">function performWork(minExpirationTime: ExpirationTime, dl: Deadline | null) &#123;</span><br><span class="line">  deadline = dl;</span><br><span class="line"></span><br><span class="line">  // 找到优先级最高的下一个需要渲染的 root: nextFlushedRoot 和对应的 expirtaionTime: nextFlushedExpirationTime</span><br><span class="line">  findHighestPriorityRoot();</span><br><span class="line"></span><br><span class="line">  if (deadline !== null) &#123;</span><br><span class="line">    recomputeCurrentRendererTime(); // 重新计算 currentRendererTime</span><br><span class="line">    currentSchedulerTime = currentRendererTime;</span><br><span class="line"></span><br><span class="line">    if (enableUserTimingAPI) &#123;</span><br><span class="line">      const didExpire = nextFlushedExpirationTime &lt; currentRendererTime;</span><br><span class="line">      const timeout = expirationTimeToMs(nextFlushedExpirationTime);</span><br><span class="line">      stopRequestCallbackTimer(didExpire, timeout);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    while (</span><br><span class="line">      nextFlushedRoot !== null &amp;&amp;</span><br><span class="line">      nextFlushedExpirationTime !== NoWork &amp;&amp;</span><br><span class="line">      (minExpirationTime === NoWork ||</span><br><span class="line">        minExpirationTime &gt;= nextFlushedExpirationTime) &amp;&amp;</span><br><span class="line">        // deadlineDidExpire 判断时间片是否过期 shouldYield 中判断</span><br><span class="line">      (!deadlineDidExpire || currentRendererTime &gt;= nextFlushedExpirationTime) // currentRendererTime &gt;= nextFlushedExpirationTime 超时了</span><br><span class="line">    ) &#123;</span><br><span class="line">      performWorkOnRoot(</span><br><span class="line">        nextFlushedRoot,</span><br><span class="line">        nextFlushedExpirationTime,</span><br><span class="line">        currentRendererTime &gt;= nextFlushedExpirationTime, // 超时了 true</span><br><span class="line">      );</span><br><span class="line">      findHighestPriorityRoot();</span><br><span class="line">      recomputeCurrentRendererTime();</span><br><span class="line">      currentSchedulerTime = currentRendererTime;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    while (</span><br><span class="line">      nextFlushedRoot !== null &amp;&amp;</span><br><span class="line">      nextFlushedExpirationTime !== NoWork &amp;&amp;</span><br><span class="line">      (minExpirationTime === NoWork ||</span><br><span class="line">        minExpirationTime &gt;= nextFlushedExpirationTime)</span><br><span class="line">    ) &#123;</span><br><span class="line">      performWorkOnRoot(nextFlushedRoot, nextFlushedExpirationTime, true);</span><br><span class="line">      findHighestPriorityRoot();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="findHighestPriorityRoot"><a href="#findHighestPriorityRoot" class="headerlink" title="findHighestPriorityRoot"></a>findHighestPriorityRoot</h3><p>正常情况 React 应用只会有一个 root 执行下面逻辑</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if (root === root.nextScheduledRoot) &#123;</span><br><span class="line">  // This is the only root in the list.</span><br><span class="line">  root.nextScheduledRoot = null;</span><br><span class="line">  firstScheduledRoot = lastScheduledRoot = null;</span><br><span class="line">  break;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后   &#x2F;&#x2F; 找到优先级最高的下一个需要渲染的 root: nextFlushedRoot 和对应的 expirtaionTime: nextFlushedExpirationTime</p>
<h2 id="performWorkOnRoot"><a href="#performWorkOnRoot" class="headerlink" title="performWorkOnRoot"></a>performWorkOnRoot</h2><ul>
<li>renderRoot 渲染阶段</li>
<li>completeRoot 提交阶段</li>
<li>同步异步调用 renderRoot 区别在于 isYieldy</li>
<li>isYieldy &#x3D; false 和 shouldYield &#x3D; false 表示任务不可中断，执行的是同步任务或者已经过期的任务或时间片有剩余时间执行</li>
<li>同步情况直接进入 renderRoot 渲染阶段再进入 completeRoot 提交阶段</li>
<li>异步情况先进入 renderRoot 渲染阶段，然后根据 shouldYield(是否该暂停跳出) 判断是否需要中断</li>
<li>shouldYield &#x3D; false 当前帧还有时间，进入 completeRoot 提交阶段，true 则当前帧没有时间待到下一次 requestIdleCallback 之后执行</li>
<li>最后 isRendering &#x3D; false</li>
<li>finishedWork 是已经完成 renderRoot 渲染阶段的任务，只有 renderRoot 后才不为 null</li>
<li>completeRoot 只有在 renderRoot 渲染阶段完成 finishedWork 不为 null 时才能执行</li>
<li>判断 finishedWork !&#x3D;&#x3D; null 是因为当前时间片可能 renderRoot 结束了没时间 completeRoot，如果新的时间片中有完成 renderRoot 的 finishedWork 就直接 completeRoot<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">function performWorkOnRoot(</span><br><span class="line">  root: FiberRoot,</span><br><span class="line">  expirationTime: ExpirationTime,</span><br><span class="line">  isExpired: boolean,</span><br><span class="line">) &#123;</span><br><span class="line">  isRendering = true;</span><br><span class="line"></span><br><span class="line">  if (deadline === null || isExpired) &#123;</span><br><span class="line">    // 同步</span><br><span class="line">    let finishedWork = root.finishedWork;</span><br><span class="line">    // 因为有可能 renderRoot 执行完了 finishedWork != null 但是没时间 completeRoot， 所以每次都判断一下</span><br><span class="line">    if (finishedWork !== null) &#123;</span><br><span class="line">      completeRoot(root, finishedWork, expirationTime);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      root.finishedWork = null;</span><br><span class="line">      const timeoutHandle = root.timeoutHandle;</span><br><span class="line">      if (timeoutHandle !== noTimeout) &#123;</span><br><span class="line">        root.timeoutHandle = noTimeout;</span><br><span class="line">        cancelTimeout(timeoutHandle);</span><br><span class="line">      &#125;</span><br><span class="line">      const isYieldy = false;</span><br><span class="line">      renderRoot(root, isYieldy, isExpired);</span><br><span class="line">      finishedWork = root.finishedWork;</span><br><span class="line">      if (finishedWork !== null) &#123;</span><br><span class="line">        completeRoot(root, finishedWork, expirationTime)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    // 异步</span><br><span class="line">    let finishedWork = root.finishedWork;</span><br><span class="line">    if (finishedWork !== null) &#123;</span><br><span class="line">      completeRoot(root, finishedWork, expirationTime);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      root.finishedWork = null;</span><br><span class="line">      const timeoutHandle = root.timeoutHandle;</span><br><span class="line">      if (timeoutHandle !== noTimeout) &#123;</span><br><span class="line">        root.timeoutHandle = noTimeout;</span><br><span class="line">        cancelTimeout(timeoutHandle);</span><br><span class="line">      &#125;</span><br><span class="line">      const isYieldy = true;</span><br><span class="line">      renderRoot(root, isYieldy, isExpired);</span><br><span class="line">      finishedWork = root.finishedWork;</span><br><span class="line">      if (finishedWork !== null) &#123;</span><br><span class="line">        if (!shouldYield()) &#123; // 不可以中断，进入 commit 阶段</span><br><span class="line">          completeRoot(root, finishedWork, expirationTime);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          // 可以中断，记录 finishedWork, 此时只执行了 render 阶段 renderRoot 没执行 commit 阶段 completeRoot 待到下个时间段进入 performWorkOnRoot 判断</span><br><span class="line">          root.finishedWork = finishedWork;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  isRendering = false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="renderRoot-的概览"><a href="#renderRoot-的概览" class="headerlink" title="renderRoot 的概览"></a>renderRoot 的概览</h2><h3 id="核心功能-2"><a href="#核心功能-2" class="headerlink" title="核心功能"></a>核心功能</h3><ul>
<li>进入 workLoop 进行循环单元更新<br>对整颗 fiberTree 都遍历一遍</li>
<li>更新时捕获错误并进行处理</li>
<li>更新流程结束后的处理</li>
<li>nextUnitOfWork 是每个更新完的 fiber 的 child，也就是子节点</li>
<li>nextUnitOfWork &#x3D; createWorkInProgress() 拷贝一份 fiber 节点，在 nextUnitOfWork 中修改，防止改变当前 fiberTree<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">function renderRoot(root: FiberRoot, isYieldy: boolean, isExpired: boolean) &#123;</span><br><span class="line">  // ...</span><br><span class="line">  if ( // 将要执行的任务 root 和 expirationTime 和 nextRenderExpirationTime、nextRoot 预期的不一样， 应该是之前任务被高优先级的任务打断了。</span><br><span class="line">    expirationTime !== nextRenderExpirationTime ||</span><br><span class="line">    root !== nextRoot ||</span><br><span class="line">    nextUnitOfWork === null // 更新结束 fiber 的 child，下一个节点, 首次 = null</span><br><span class="line">  ) &#123;</span><br><span class="line">  // 初始化的内容</span><br><span class="line">    resetStack(); // 重置</span><br><span class="line">    nextRoot = root;</span><br><span class="line">    nextRenderExpirationTime = expirationTime; // root.nextExpirationTimeToWorkOn;</span><br><span class="line">    nextUnitOfWork = createWorkInProgress( // 拷贝了一份 fiber 对象操作</span><br><span class="line">      nextRoot.current,</span><br><span class="line">      null,</span><br><span class="line">      nextRenderExpirationTime,</span><br><span class="line">    );</span><br><span class="line">    root.pendingCommitExpirationTime = NoWork; // 设置成 NoWork</span><br><span class="line">  // ...</span><br><span class="line">  &#125;</span><br><span class="line">// 开始进入 workLoop </span><br><span class="line">  do &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      workLoop(isYieldy); // 进行每个节点的更新</span><br><span class="line">    &#125; catch (thrownValue) &#123;</span><br><span class="line">      // ...</span><br><span class="line">      break; // 遇到了某种错误跳出</span><br><span class="line">    &#125;   while(true)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>###执行流程</p>
<ul>
<li><p>执行 workLoop</p>
</li>
<li><p>在 performUnitOfWork 中执行 beginWork 进行更新</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function workLoop(isYieldy) &#123;</span><br><span class="line">  if (!isYieldy) &#123; // 不可中断 Sync 和 超时任务不可中断</span><br><span class="line">    // Flush work without yielding</span><br><span class="line">    // nextUnitOfWork 是 fiber 对象，为 null 已经是 root 节点 fiber return 的 null 了</span><br><span class="line">    while (nextUnitOfWork !== null) &#123;</span><br><span class="line">      nextUnitOfWork = performUnitOfWork(nextUnitOfWork); // 进行更新</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    // Flush asynchronous work until the deadline runs out of time.</span><br><span class="line">    while (nextUnitOfWork !== null &amp;&amp; !shouldYield()) &#123; // 判断 shouldYield = false 当前时间片是否有时间更新</span><br><span class="line">      nextUnitOfWork = performUnitOfWork(nextUnitOfWork);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>workLoop 过程中的 catch</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">do &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    workLoop(isYieldy); // 进行每个节点的更新</span><br><span class="line">  &#125; catch (thrownValue) &#123;</span><br><span class="line">    // ...</span><br><span class="line">    break; // 遇到了某种错误跳出</span><br><span class="line">  &#125;   while(true)</span><br></pre></td></tr></table></figure>
</li>
<li><p>workLoop 后的错误处理和提交</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 致命错误</span><br><span class="line">if (didFatal) &#123; &#125;</span><br><span class="line"></span><br><span class="line">// workLoop break 中断的错误</span><br><span class="line">if (nextUnitOfWork !== null) &#123; &#125;</span><br><span class="line"></span><br><span class="line">// 可处理的错误</span><br><span class="line">if (nextRenderDidError) &#123; &#125;</span><br><span class="line"></span><br><span class="line">// 准备提交</span><br><span class="line">onComplete(root, rootWorkInProgress, expirationTime);plete()</span><br></pre></td></tr></table></figure></li>
</ul>

            </div>
        </div>
    </article>

    
    
<nav class="article-nav">
  
    <a href="/2019/05/21/TCP%20%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/" id="article-nav-newer" class="article-nav-link-wrap prev">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          TCP 拥塞控制
        
      </div>
    </a>
  
  
    <a href="/2019/02/23/React%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%20-%20React%20%E5%88%9B%E5%BB%BA%E6%9B%B4%E6%96%B0%E5%9B%9E%E9%A1%BE%E5%92%8C%20React%20%E7%9A%84%E6%89%B9%E9%87%8F%E6%9B%B4%E6%96%B0%20/" id="article-nav-older" class="article-nav-link-wrap next">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">React 源码解析 - React 创建更新回顾和 React 的批量更新</div>
    </a>
  
</nav>

    

    
</div>
    </div>
    <footer class="site-footer">
        <div class="global-width">
            <ul class="site-widget">
                
                <li class="widget widget-tag">
                    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget-body">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/JavaScript/" rel="tag">JavaScript</a><span class="tag-list-count">6</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/React/" rel="tag">React</a><span class="tag-list-count">5</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/React-Tips/" rel="tag">React Tips</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Redux/" rel="tag">Redux</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Vue/" rel="tag">Vue</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/css/" rel="tag">css</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/dom/" rel="tag">dom</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/http/" rel="tag">http</a><span class="tag-list-count">8</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/nodejs/" rel="tag">nodejs</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/react/" rel="tag">react</a><span class="tag-list-count">6</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/sftp/" rel="tag">sftp</a><span class="tag-list-count">1</span></li></ul>
    </div>
  </div>

                </li>
                
                <li class="widget widget-category">
                    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget-body">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Font-End-Basis/">Font-End Basis</a><span class="category-list-count">11</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/React/">React</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Vue/">Vue</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/css/">css</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/http/">http</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/network/">network</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/nodejs/">nodejs</a><span class="category-list-count">2</span></li></ul>
    </div>
  </div>

                </li>
                
                <li class="widget widget-recent_posts">
                    
  <div class="widget-wrap">
    <h3 class="widget-title">Recents</h3>
    <div class="widget-body">
      <ul>
        
          <li>
            <a href="/2019/08/23/React%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%20-%20commitRoot%20%E6%9B%B4%E6%96%B0%E4%BB%BB%E5%8A%A1%20dom%20%E8%8A%82%E7%82%B9%20/">React 源码解析 - commitRoot 更新任务 dom 节点</a>
          </li>
        
          <li>
            <a href="/2019/06/21/React%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%20-%20renderRoot%20%E5%AE%8C%E6%88%90%E8%8A%82%E7%82%B9%E6%9B%B4%E6%96%B0%E4%BB%BB%E5%8A%A1%20/">React 源码解析 - renderRoot 完成节点更新任务</a>
          </li>
        
          <li>
            <a href="/2019/06/03/React%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%20-%20%E6%9B%B4%E6%96%B0%E6%B5%81%E7%A8%8B%20renderRoot%20%E6%B8%B2%E6%9F%93%E9%98%B6%E6%AE%B5%20/">React 源码解析 - 更新流程 renderRoot 渲染阶段</a>
          </li>
        
          <li>
            <a href="/2019/05/21/TCP%20%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/">TCP 拥塞控制</a>
          </li>
        
          <li>
            <a href="/2019/02/27/React%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%20-%20reactScheduler%20%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%20/">React 源码解析 - reactScheduler 异步任务调度</a>
          </li>
        
      </ul>
    </div>
  </div>

                </li>
                
            </ul>
        </div>
        <div class="site-info">
            <address>
                &copy; 2014 <a href="http://yoursite.com">Minimalist</a> All Right Reserved. <br/>
                Powered by <a target="_blank" rel="noopener" href="http://hexo.io">Hexo</a>. Theme by <a target="_blank" rel="noopener" href="http://zzoman.com">ZZOMAN</a>
            </address>
        </div>
    </footer>
    
    <script src="/libs/jquery-1.11.3.min.js" type="text/javascript"></script>
    
    <script src="/libs/fancybox/jquery.fancybox.js" type="text/javascript"></script>
    
    <script src="/js/site_init.js" type="text/javascript"></script>
    
</body>
</html>
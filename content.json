{"meta":{"title":"Minimalist","subtitle":null,"description":null,"author":"Yang Ran","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"前端基础重点回顾2:HTTP协议","slug":"前端基础重点回顾2:HTTP协议","date":"2018-01-24T08:50:04.000Z","updated":"2018-01-24T08:53:28.000Z","comments":true,"path":"2018/01/24/前端基础重点回顾2:HTTP协议/","link":"","permalink":"http://yoursite.com/2018/01/24/前端基础重点回顾2:HTTP协议/","excerpt":"","text":"HTTP协议的主要特点 简单快速URI固定，处理简单 灵活http协议可以通过修改header 指定传输的数据类型，一个http 传输可以完成不同数据类型的传输 无连接http协议每次传输后连接都会断开 无状态客户端和服务端是两块，客户端再次访问服务端是无法区分客户端的(单从http 协议上是无法区分客户端身份的) HTTP报文组成请求报文 请求行http方法、请求地址、http协议版本 请求头header：key value 格式 空行(CR+LF)用于识别请求头和请求体的分隔符，CR+LF 回车+换行符 请求体 响应报文 状态行状态码、http协议版本 响应头header：key value 格式 空行(CR+LF)用于识别响应头和响应体的分隔符，CR+LF 回车+换行符 响应体响应的实体内容 HTTP方法 get 获取 post 传输 put 更新 delete 删除 header 获得报文首部 options 对服务器预先请求告知 GET / POST 区别 get产生的url地址可以被收藏，post不可以 get会被浏览器主动缓存，post不会，除非手动设置 get只能进行url编码，post支持多种编码方式 get参数会被完整保留在浏览器历史记录里，post参数不会保留 get在url中参数有长度限制2kb，post没有限制 参数的数据类型：get只接受ASCII字符，post没有限制 get参数直接暴露在url上，不能传递敏感信息 get通过url传递，post放在request body中 HTTP状态码1xx: 指示信息 - 请求已接收2xx: 成功 - 请求被成功接收 200 OK 206 Partiaml Content 客户端发送了一个带Range头多get请求，服务器完成了它(音频、视频应用) 3xx: 重定向 301 Moved Permanently 所请求的资源已经转移至新的url地址 302 Found 所请求的资源临时转移至新url地址 304 Not Modified 客户端有缓存的文档并发出了一个条件性请求，服务器告诉客户端原来缓存的资源文件可以继续使用 4xx: 客户端错误 400 Bad Request 客户端存在语法错误，服务器无法理解 401 Unauthorized 请求未授权 必须和www-Authenticate 报头域一起使用(JWT鉴权应用) 403 Forbidden 请求被禁止访问(只能通过服务器端访问) 404 Not Found 请求的资源不存在 5xx: 服务器错误 500 Internal server Error 服务器错误 503 Server Unavailable 请求未完成或服务器临时过载当机 HTTP持久连接HTTP协议采用“请求-应答”模式，每进行一次http连接就会断开TCP连接 Keep-Alive Keep-Alive 模式，只要有一方未明确表示断开连接则保持TCP连接状态，此功能避免重复建立连接 HTTP/1.0 未标准化 HTTP/1.1 版本默认支持 HTTP管线化在HTTP/1.1 版本使用Keep-Alive 下可以使用管线化(pipelining)方式发送请求 123456789// 未使用管线化 单个请求req1 &gt; serverres1 &lt; serverreq2 &gt; serverres2 &lt; serverreq3 &gt; serverres3 &lt; server 12345678// 使用管线化 打包发送req1 &gt; serverreq2 &gt; serverreq3 &gt; serverres1 &lt; serverres2 &lt; serverres3 &lt; server 管线化只通过Keep-Alive 完成，http/1.1 才支持 只有get 和head 方法请求才可以，post 有限制 初次创建连接不启动管线化机制，因为对方服务器不一定支持http/1.1 管线化不会影响服务器响应顺序 http/1.1 要求服务端支持管线化处理不失败即可 chrmoe firefox 默认未开启管线化支持，因为管线化功能不一定能带来性能提升，服务器支持也不好。 Cookie 维持客户端访问状态浏览器每次访问会携带cookie 信息，服务器可以设置cookie，通过这个特性可以创建带状态(session)的http 访问连接123456// 客户端首次访问服务端client -----------无cookie------------&gt; serverclient &lt;-----set-cookie: sid=user1----- server// 客户端再次访问服务端client -----cookie: sid=user1---------&gt; serverclient &lt;--------确认是user1访问---------- server session 就是服务端手动维护每个客户端访问的cookie，可以维护在内存里也可以维护在redis 缓存中。","categories":[{"name":"Font-End Basis","slug":"Font-End-Basis","permalink":"http://yoursite.com/categories/Font-End-Basis/"}],"tags":[{"name":"http","slug":"http","permalink":"http://yoursite.com/tags/http/"}]},{"title":"前端基础重点回顾1:CSS盒模型、DOM、数据类型","slug":"前端基础重点回顾1:CSS盒模型、DOM、数据类型","date":"2018-01-22T13:42:52.000Z","updated":"2018-01-22T13:56:52.000Z","comments":true,"path":"2018/01/22/前端基础重点回顾1:CSS盒模型、DOM、数据类型/","link":"","permalink":"http://yoursite.com/2018/01/22/前端基础重点回顾1:CSS盒模型、DOM、数据类型/","excerpt":"","text":"CSS盒模型标准模型与IE模型的区别 计算高度宽度不同 标准盒模型的width 是以盒模型的content 来计算的IE盒模型的width 是以盒模型的border + padding + content 来计算的 CSS如何设置这两种模型 通过设置元素的box-sizing 属性 标准盒模型设置为box-sizing: content-boxIE盒模型设置为box-sizing: border-box JS如何设置获取盒模型对应的宽和高12// 获取内联样式dom.style.width / height 12// 获取渲染后的属性 IE 支持dom.currentStyle.width / height 12// 获取元素渲染后计算完毕的样式，所有浏览器支持window.getComputedStyle(dom).width / height 12// 计算元素的绝对位置dom.getBoundingClientRect().width / height dom.getBoundingClientRect() 函数不仅可以得到元素的宽高还能获得此元素在页面中的位置。[图片上传失败…(image-a1291e-1516628501105)] BFC什么是BFCBFC(block formatting context) 是一个块级格式化上下文，它形成了一个独立的布局环境。 怎么创建一个BFC1 设置float，值不为”none”2 设置overflow，值不为”visible”（hidden，auto，scroll）3 设置display的值为 “table-cell”, “table-caption”,或 “inline-block”4 设置position，值不为 “static” 或 “relative”（absolute，fixed） BFC 有什么特点1 BFC 元素内的各元素会在垂直方向上从顶部一个接一个的放置。2 BFC中的元素的布局是不受外界的影响,内外元素不会互相影响。3 BFC元素不会与浮动元素的区域重叠4 计算BFC元素高度的时候浮动元素也会参与计算 代码5 属于同一个BFC的两个相邻Box的margin会发生叠加 代码 BFC 的使用场景 解决margin叠加问题 代码 用于布局 代码 用于清除浮动 代码 DOMDOM事件的级别12// DOM0级el.onclick=function()&#123;&#125; 12// DOM2级el.addEventListenter(&apos;click&apos;, function()&#123;&#125;, &apos;是否捕获阶段触发&apos;: boolean) 12// DOM3级 区别DOM2级增加了更多的事件类型el.addEventListenter(&apos;keyup&apos;, function()&#123;&#125;, &apos;是否捕获阶段触发&apos;: boolean) DOM事件模型 事件捕获 事件冒泡 DOM事件流DOM事件流(event flow)三阶段 事件触发(触发元素) =&gt; 事件捕获阶段(事件下传) =&gt; 处于目标阶段(达到目标元素) =&gt; 事件冒泡阶段(事件上传) 描述DOM事件捕获的具体流程12// IE 只有冒泡流程window =&gt; document =&gt; html(document.documentElement) =&gt; body =&gt; ... =&gt; 目标元素 如何自定义事件Event 对象1234567// 创建var event = new Event(&apos;custome&apos;)// 注册el.addEventListener(&apos;custome&apos;, function()&#123; console.log(&apos;custome&apos;)&#125;)el.dispatchEvent(event) // 触发 CustomEvent 对象123456var event = new CustomEvent(&apos;build&apos;, &#123; &apos;detail&apos;: elem.dataset.time &#125;);function eventHandler(e) &#123; console.log(&apos;The time is: &apos; + e.detail);&#125;el.addEventListener(&apos;custome&apos;, eventHandler)el.dispatchEvent(event) // 触发 Event对象的常见应用12345event.preventDefault() // 阻止默认event.stopPropagation() // 阻止冒泡event.stopImmediatePropagation() // 按钮绑定两个click，A点击时候不出发B，A会成功阻止B, 事件响应优先级event.target // 可以用于事件委托，由父级注册事件event.currentTarget currentTarget vs targettarget在事件流的目标阶段；currentTarget在事件流的捕获，目标及冒泡阶段。只有当事件流处在目标阶段的时候，两个的指向才是一样的， 而当处于捕获和冒泡阶段的时候，target指向被单击的对象而currentTarget指向当前事件活动的对象（一般为父级）。 类型转换 数据类型 原始类型 Boolean, String, Number, Null, Undefined, Symbol 复杂类型(对象) Object 显式类型转换Number函数 简单类型: 直接转换end复杂类型: valueOf() =&gt; 简单类型 =&gt; 直接转换end || 复杂类型 =&gt; toString() =&gt; 简单类型 =&gt;直接转换end String函数 简单类型: 直接转换end复杂类型: toString() =&gt; 简单类型 =&gt; 直接转换end || 复杂类型 =&gt; valueOf() =&gt; 简单类型 =&gt;直接转换end || 复杂类型error Boolean函数 \b 空字符串、Null、undefined、false、0 转化为false","categories":[{"name":"Font-End Basis","slug":"Font-End-Basis","permalink":"http://yoursite.com/categories/Font-End-Basis/"}],"tags":[{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"},{"name":"dom","slug":"dom","permalink":"http://yoursite.com/tags/dom/"}]},{"title":"Vue组件.sync修饰符","slug":"Vue组件-sync修饰符","date":"2018-01-22T05:09:11.000Z","updated":"2018-01-22T05:09:33.000Z","comments":true,"path":"2018/01/22/Vue组件-sync修饰符/","link":"","permalink":"http://yoursite.com/2018/01/22/Vue组件-sync修饰符/","excerpt":"","text":"12345&lt;div id=&quot;app&quot;&gt; &lt;div&gt;父组件bar: &#123;&#123;bar&#125;&#125;&lt;/div&gt; &lt;comp :foo.sync=&quot;bar&quot;&gt;&lt;/comp&gt; &lt;!-- &lt;comp :foo=&quot;bar&quot; @update:foo=&quot;val =&gt; bar = val&quot;&gt;&lt;/comp&gt; --&gt;&lt;/div&gt; 1234567891011121314151617&lt;script&gt;Vue.component(&apos;comp&apos;, &#123; template: &apos;&lt;div&gt;&lt;button @click=&quot;increment&quot;&gt;点我更新子组件foo++&lt;/button&gt;&lt;div&gt;子组件foo: &#123;&#123;foo&#125;&#125;&lt;/div&gt;&lt;/div&gt;&apos;, props: [&apos;foo&apos;], methods: &#123; increment: function() &#123; this.foo++; this.$emit(&apos;update:foo&apos;, this.foo); &#125; &#125;&#125;);new Vue(&#123; el: &apos;#app&apos;, data: &#123;bar: 0&#125;&#125;);&lt;/script&gt; :foo.sync=&quot;bar&quot; 实际就是 :foo=&quot;bar&quot; @update:foo=&quot;val =&gt; bar = val&quot; 的语法糖.sync demo","categories":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/tags/Vue/"}]},{"title":"CSS3总结","slug":"CSS3总结","date":"2018-01-22T05:07:54.000Z","updated":"2018-01-22T05:08:22.000Z","comments":true,"path":"2018/01/22/CSS3总结/","link":"","permalink":"http://yoursite.com/2018/01/22/CSS3总结/","excerpt":"","text":"##CSS3 calc() 计算属性12width: calc(100% - 50px)calc内可以写 + - * / 运算符 记得留空格 ##CSS3效果的简单事例圆角， 圆形div 阴影2D 转换：放大、缩小、偏移、旋转3D 转换：移动、旋转背景色渐变过渡效果动画CSS3效果 ##全屏过渡效果全屏过渡 ##loading效果loading1loading2 本博客版权归 本人和饥人谷所有，转载需说明来源","categories":[{"name":"css","slug":"css","permalink":"http://yoursite.com/categories/css/"}],"tags":[{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"}]},{"title":"使用sftp操作远程服务器","slug":"使用sftp操作远程服务器","date":"2018-01-22T05:07:02.000Z","updated":"2018-01-22T05:07:27.000Z","comments":true,"path":"2018/01/22/使用sftp操作远程服务器/","link":"","permalink":"http://yoursite.com/2018/01/22/使用sftp操作远程服务器/","excerpt":"","text":"远程连接服务器12sftp user@xxx.xxx.xxxexit // 退出 与Bash相似的功能1234pwd // 查看当前路径ls ls -lacd 进行本地操作123lpwd // 查看本地路径llslcd 使用sftp传输文件12345678// 下载文件get remote_file_name// 下载重命名get remote_file_name local_file_name// 下载文件夹get -r some_directory_name// 下载并保持信息get -Pr some_directory_name 1234// 上传文件put local_file_name// 上传文件夹put -r local_directory_name 查看磁盘123df -h // 查看磁盘大小! // 切换本地使用bash命令exit // 返回远程服务器进行sftp操作 参考文章","categories":[{"name":"network","slug":"network","permalink":"http://yoursite.com/categories/network/"}],"tags":[{"name":"sftp","slug":"sftp","permalink":"http://yoursite.com/tags/sftp/"}]},{"title":"数组去重","slug":"数组去重","date":"2018-01-22T05:06:14.000Z","updated":"2018-01-22T05:06:38.000Z","comments":true,"path":"2018/01/22/数组去重/","link":"","permalink":"http://yoursite.com/2018/01/22/数组去重/","excerpt":"","text":"基础类型数组去重1const arr = [1, 1, 2, 3, 3, 4, 5] ES5123function unique(arr) &#123; return arr.filter((item, index, array) =&gt; array.indexOf(item) === index)&#125; ES612345678function unique (arr) &#123; const seen = new Map() return arr.filter((a) =&gt; !seen.has(a) &amp;&amp; seen.set(a, 1))&#125;// orfunction unique(array) &#123; return [...new Set(array)]&#125; 复杂类型数组去重1const array = [&#123;value: 1&#125;, &#123;value: 1&#125;, &#123;value: 2&#125;] ES51234function unique(arr) &#123; var obj = &#123;&#125; return arr.filter((item, index, array) =&gt; !obj.hasOwnProperty(JSON.stringify(item)) &amp;&amp; (obj[JSON.stringify(item)] = true))&#125; ES61234function unique (arr) &#123; const seen = new Map() return arr.filter((a) =&gt; !seen.has(JSON.stringify(a)) &amp;&amp; seen.set(JSON.stringify(a), 1))&#125;","categories":[{"name":"Font-End Basis","slug":"Font-End-Basis","permalink":"http://yoursite.com/categories/Font-End-Basis/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"Vue生命周期","slug":"Vue生命周期","date":"2018-01-22T05:05:18.000Z","updated":"2018-01-22T05:05:46.000Z","comments":true,"path":"2018/01/22/Vue生命周期/","link":"","permalink":"http://yoursite.com/2018/01/22/Vue生命周期/","excerpt":"","text":"vue里的生命周期是什么？vue实例从创建到销毁的过程称之为vue的生命周期 vue的生命周期各阶段都做了什么？beforeCreate 实例创建前：这个阶段实例的data、methods是读不到的created 实例创建后：这个阶段已经完成了数据观测(data observer)，属性和方法的运算， watch/event 事件回调。mount挂载阶段还没开始，$el 属性目前不可见，数据并没有在DOM元素上进行渲染beforeMount：在挂载开始之前被调用：相关的 render 函数首次被调用。mounted：el选项的DOM节点 被新创建的 vm.$el 替换，并挂载到实例上去之后调用此生命周期函数。此时实例的数据在DOM节点上进行渲染beforeUpdate：数据更新时调用，但不进行DOM重新渲染，在数据更新时DOM没渲染前可以在这个生命函数里进行状态处理updated：这个状态下数据更新并且DOM重新渲染，当这个生命周期函数被调用时，组件 DOM 已经更新，所以你现在可以执行依赖于 DOM 的操作。当实例每次进行数据更新时updated都会执行beforeDestory：实例销毁之前调用。destroyed：Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。 vue生命周期在真实场景下的业务应用created：进行ajax请求异步数据的获取、初始化数据mounted：挂载元素内dom节点的获取nextTick：针对单一事件更新数据后立即操作domupdated：任何数据的更新，如果要做统一的业务逻辑处理watch：监听具体数据变化，并做相应的处理","categories":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/tags/Vue/"}]},{"title":"Vue.nextTick的实现","slug":"Vue-nextTick的实现","date":"2018-01-22T05:04:21.000Z","updated":"2018-01-22T05:04:51.000Z","comments":true,"path":"2018/01/22/Vue-nextTick的实现/","link":"","permalink":"http://yoursite.com/2018/01/22/Vue-nextTick的实现/","excerpt":"","text":"这是一篇继event loop和MicroTask 后的vue.nextTick API实现的源码解析。 预热，写一个sleep函数123456789function sleep (ms) &#123; return new Promise(resolve =&gt; setTimeout(resolve, ms)&#125;async function oneTick (ms) &#123; console.log(&apos;start&apos;) await sleep(ms) console.log(&apos;end&apos;)&#125;oneTick(3000) 解释下sleep函数async 函数进行await PromiseFn()时函数执行是暂停的，我们也知道现在这个PromiseFn是在microTask内执行。当microTask没执行完毕时，后面的macroTask是不会执行的，我们也就通过microTask在event loop的特性实现了一个sleep函数，阻止了console.log的执行 流程1执行console.log(‘start’)2执行await 执行暂停，等待await函数后的PromiseFn在microTask执行完毕3在sleep函数内，延迟ms返回4返回resolve后执行console.log(‘end’) nextTick API vue中nextTick的使用方法 123vue.nextTick(() =&gt; &#123; // todo...&#125;) 了解用法后看一下源码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263const nextTick = (function () &#123; const callbacks = [] let pending = false let timerFunc // 定时函数 function nextTickHandler () &#123; pending = false const copies = callbacks.slice(0) // 复制 callbacks.length = 0 // 清空 for (let i = 0; i &lt; copies.length; i++) &#123; copies[i]() // 逐个执行 &#125; &#125; if (typeof Promise !== &apos;undefined&apos; &amp;&amp; isNative(Promise)) &#123; var p = Promise.resolve() var logError = err =&gt; &#123; console.error(err) &#125; timerFunc = () =&gt; &#123; p.then(nextTickHandler).catch(logError) // 重点 &#125; &#125; else if (&apos;!isIE MutationObserver&apos;) &#123; var counter = 1 var observer = new MutationObserver(nextTickHandler) // 重点 var textNode = document.createTextNode(string(conter)) observer.observe(textNode, &#123; characterData: true &#125;) timerFunc = () =&gt; &#123; counter = (counter + 1) % 2 textNode.data = String(counter) &#125; &#125; else &#123; timerFunc = () =&gt; &#123; setTimeout(nextTickHandler, 0) // 重点 &#125; &#125; return function queueNextTick (cb, ctx) &#123; // api的使用方式 let _resolve callbacks.push(() =&gt; &#123; if (cb) &#123; try &#123; cb.call(ctx) &#125; catch (e) &#123; err &#125; &#125; else if (_resolve) &#123; _resolve(ctx) &#125; &#125;) if (!pending) &#123; pending = true timerFunc() &#125; if (!cb &amp;&amp; typeof Promise !== &apos;undefined&apos;) &#123; return new Promise((resolve, reject) =&gt; &#123; _resolve =resolve &#125;) &#125; &#125;&#125;)() // 自执行函数 大致看一下源码可以了解到nextTick api是一个自执行函数既然是自执行函数，直接看它的return类型，return function queueNextTick (cb, ctx) {…} 1234567891011121314151617181920212223return function queueNextTick (cb, ctx) &#123; // api的使用方式 let _resolve callbacks.push(() =&gt; &#123; if (cb) &#123; try &#123; cb.call(ctx) &#125; catch (e) &#123; err &#125; &#125; else if (_resolve) &#123; _resolve(ctx) &#125; &#125;) if (!pending) &#123; pending = true timerFunc() &#125; if (!cb &amp;&amp; typeof Promise !== &apos;undefined&apos;) &#123; return new Promise((resolve, reject) =&gt; &#123; _resolve =resolve &#125;) &#125; &#125; 只关注主流程queueNextTick函数把我们传入的() =&gt; { // todo… } 推入了callbacks内 1234567891011121314151617181920212223if (typeof Promise !== &apos;undefined&apos; &amp;&amp; isNative(Promise)) &#123; var p = Promise.resolve() var logError = err =&gt; &#123; console.error(err) &#125; timerFunc = () =&gt; &#123; p.then(nextTickHandler).catch(logError) // 重点 &#125;&#125; else if (&apos;!isIE MutationObserver&apos;) &#123; var counter = 1 var observer = new MutationObserver(nextTickHandler) // 重点 var textNode = document.createTextNode(string(conter)) observer.observe(textNode, &#123; characterData: true &#125;) timerFunc = () =&gt; &#123; counter = (counter + 1) % 2 textNode.data = String(counter) &#125;&#125; else &#123; timerFunc = () =&gt; &#123; setTimeout(nextTickHandler, 0) // 重点 &#125;&#125; 这一段我们可以看到标注的三个点表明在不同浏览器环境下使用Promise, MutationObserver或setTimeout(fn, 0) 来执行nextTickHandler 12345678910111213function nextTickHandler () &#123; pending = false const copies = callbacks.slice(0) // 复制 callbacks.length = 0 // 清空 for (let i = 0; i &lt; copies.length; i++) &#123; copies[i]() // 逐个执行 &#125; &#125;``` nextTickHandler就是把我们之前放入callbacks的 () =&gt; &#123; // todo... &#125; 在当前tasks内执行。## 写一个简单的nextTick源码可能比较绕，我们自己写一段简单的nextTick const simpleNextTick = (function () { let callbacks = [] let timerFunc return function queueNextTick (cb) { callbacks.push(() =&gt; { // 给callbacks 推入cb() cb() }) timerFunc = () =&gt; { return Promise.resolve().then(() =&gt; { const fn = callbacks.shift() fn() }) } timerFunc() // 执行timerFunc，返回到是一个Promise }})() simpleNextTick(() =&gt; { setTimeout(console.log, 3000, ‘nextTick’)})12我们可以从这里看出nextTick的原理就是返回出一个Promise，而我们todo的代码在这个Promise中执行，现在我们还可以继续简化 const simpleNextTick = (function () { return function queueNextTick (cb) { timerFunc = () =&gt; { return Promise.resolve().then(() =&gt; { cb() }) } timerFunc() }})() simpleNextTick(() =&gt; { setTimeout(console.log, 3000, ‘nextTick’)})12直接写成这样。 const simpleNextTick = function queueNextTick (cb) { timerFunc = () =&gt; { return Promise.resolve().then(() =&gt; { cb() }) } timerFunc() } simpleNextTick(() =&gt; { setTimeout(console.log, 3000, ‘nextTick’)})12这次我们把自执行函数也简化掉 const simpleNextTick = function queueNextTick (cb) { return Promise.resolve().then(cb) } simpleNextTick(() =&gt; { setTimeout(console.log, 3000, ‘nextTick’)})1234现在我们直接简化到最后，现在发现nextTick最核心的内容就是Promise，一个microtask。现在我们回到vue的nextTick API官方示例 var vm = new Vue({ el: ‘#example’, data: { message: ‘123’ }})vm.message = ‘new message’ // 更改数据vm.$el.textContent === ‘new message’ // falseVue.nextTick(function () { vm.$el.textContent === ‘new message’ // true})12345原来在vue内数据的更新后dom更新是要在下一个事件循环后执行的。nextTick的使用原则主要就是解决单一事件更新数据后立即操作dom的场景。既然我们知道了nextTick核心是利用microTasks，那么我们把简化过的nextTick和开头的sleep函数对照一下。 const simpleNextTick = function queueNextTick (cb) { return Promise.resolve().then(cb) } simpleNextTick(() =&gt; { setTimeout(console.log, 3000, ‘nextTick’) // 也可以换成ajax请求})12345678910```function sleep (ms) &#123; return new Promise(resolve =&gt; setTimeout(resolve, ms) // 也可以换成ajax请求&#125;async function oneTick (ms) &#123; console.log(&apos;start&apos;) await sleep(ms) console.log(&apos;end&apos;)&#125;oneTick(3000) 我们看出nextTick和我么写的oneTick的执行结果是那么的相似。区别只在于nextTick是把callback包裹一个Promise返回并执行，而oneTick是用await执行一个Promise函数，而这个Promise有自己包裹的webapi函数。 那在用ajax请求的时候我们是不是直接这样使用axios可以返回Promise的库 12345async function getData () &#123; const data = await axios.get(url) // 操作data的数据来改变dom return data&#125; 这样也可以达到同nextTick同样的作用 最后我们也可以从源码中看出，当浏览器环境不支持Promise时可以使用MutationObserver或setTimeout(cb, 0) 来达到同样的效果。但最终的核心是microTask","categories":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/tags/Vue/"}]},{"title":"继异步编程的async/await函数补充","slug":"继异步编程的async-await函数补充","date":"2018-01-22T05:01:48.000Z","updated":"2018-01-22T05:04:08.000Z","comments":true,"path":"2018/01/22/继异步编程的async-await函数补充/","link":"","permalink":"http://yoursite.com/2018/01/22/继异步编程的async-await函数补充/","excerpt":"","text":"这个执行函数顺序的问题是继之前EventLoop 和 MicroTask的文章的补充1234567891011121314151617181920async function async1() &#123; console.log(&apos;async1 start&apos;); // 问题1 async1 start 在script 里执行是什么样的 await async2(); // 问题2 为什么async2 在promise1 前执行 console.log(&apos;async1 end&apos;); // 问题3 为什么async1 end 会在 promise2 后执行&#125;async function async2() &#123; console.log(&apos;async2&apos;);&#125;console.log(&apos;script start&apos;);setTimeout(function() &#123; console.log(&apos;setTimeout&apos;);&#125;, 0);async1();new Promise(function(resolve) &#123; console.log(&apos;promise1&apos;); resolve(); &#125;).then(function() &#123; console.log(&apos;promise2&apos;); &#125;);console.log(&apos;script end&apos;); 执行结果1234567891. script start2. async1 start3. async24. promise15. script end6. promise27. async1 end// stack 清空8. setTimeout 问题1 async1 start 在script 里执行是什么样的?先看下async 函数 babel 后样子 可以看出async 函数只是执行了_asyncToGenerator 这个函数, 再看下_asyncToGenerator 原来_asyncToGenerator 函数只是返回了一个 new Promise()，async1() 的执行也就是在script 里执行里一个new Promise() 问题2 为什么async2 在promise1 前执行从问题1可以知道async2 () 也是一个new Promise() ，不过async2() 多了一个aiwait，看下mdn 的描述 await 表达式会暂停当前 async function 的执行，等待 Promise 处理完成。若 Promise 正常处理(fulfilled)，其处理结果作为 await 表达式的值，继续执行 async function。 再看一下babel 后的babel 后只不过前面多了yield，await async()变成了yield new Promise()，\byield 是一个暂停执行的标记而后面的语句是已经执行完了，async2 也就先于promise1 在script 中执行。 问题3 为什么async1 end 会在 promise2 后执行这里引用阮一峰的对Generator-函数异步应用的解释 传统的编程语言，早有异步编程的解决方案（其实是多任务的解决方案）。其中有一种叫做”协程”（coroutine），意思是多个线程互相协作，完成异步任务。协程有点像函数，又有点像线程。它的运行流程大致如下。第一步，协程A开始执行。第二步，协程A执行到一半，进入暂停，执行权转移到协程B。第三步，（一段时间后）协程B交还执行权。第四步，协程A恢复执行。上面流程的协程A，就是异步任务，因为它分成两段（或多段）执行。 这里的async1 end 与 promise2 的执行就是因为yield 的“协程”，我们这里改写一下问题，让问题更清晰1234567891011121314151617181920async function async1() &#123; console.log(&apos;async1 start&apos;); new Promise(function(resolve) &#123; // 我们把new Promise 放到async1内部 console.log(&apos;promise1&apos;); resolve(); &#125;).then(function() &#123; // await 通过yield 协程的功能 把上下两段分割 console.log(&apos;promise2&apos;); &#125;); await async2(); // yield 协程分割，但是async2 先执行完毕 console.log(&apos;async1 end&apos;); // await 通过yield 协程的功能 把上下两段分割&#125;async function async2() &#123; console.log(&apos;async2&apos;);&#125;console.log(&apos;script start&apos;);setTimeout(function() &#123; console.log(&apos;setTimeout&apos;);&#125;, 0);async1();console.log(&apos;script end&apos;); 从上面的改写看出await async2 通过协程把上promise2 和 async1 end 分割成两部分，这里将会把上半部分的microtask 的任务都执行完毕才会执行下一段的代码。 这段代码的执行顺序不仅考察了异步执行主要考察了对async / await 函数的降级理解，了解到这一层后发现async / await 函数确实是js 异步执行的好方式。 babel编译","categories":[{"name":"Font-End Basis","slug":"Font-End-Basis","permalink":"http://yoursite.com/categories/Font-End-Basis/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"EventLoop事件循环中的 MacroTask与 MicroTask","slug":"EventLoop事件循环中的 MacroTask与 MicroTask","date":"2018-01-22T04:34:47.000Z","updated":"2018-01-22T04:36:51.000Z","comments":true,"path":"2018/01/22/EventLoop事件循环中的 MacroTask与 MicroTask/","link":"","permalink":"http://yoursite.com/2018/01/22/EventLoop事件循环中的 MacroTask与 MicroTask/","excerpt":"","text":"问题来源在学习Promise时在stackoverflow上看到一个解释Promise运行顺序回答。之前在学习异步编程中讲解了MacroTask和MicroTask， 但在最近深入EventLoop后又有了更多的了解 EventLoop、MacroTask、MicroTask之间的关系 macrotasks 与 microtasks 各自的 APImacrotasks: setTimeout, setInterval, setImmediate, requestAnimationFrame, I/O, UI renderingmicrotasks: process.nextTick, Promises, Object.observe, MutationObserver 一张图先了解microtasks 与macrotasks 在eventloop队列里的位置这里用了上一章EventLoop 事件循环文章里的图，并在回调队列里标注里microtask的位置。 microtasks 与macrotasks 在eventloop 里的流程在没有引入microtasks 概念前事件循环是这样执行的123while (queue是否有task) &#123; 执行task&#125; 引入microtasks 概念后1234while (queue是否有macrotasks) &#123; if (microtasks) 执行空microtasks 再执行macrotasks&#125; microtasks 与macrotasks 在eventloop 里实际执行结果1234567891011121314// 例1console.log(&apos;script start&apos;);setTimeout(function() &#123; console.log(&apos;setTimeout&apos;);&#125;, 0);Promise.resolve().then(function() &#123; console.log(&apos;promise1&apos;);&#125;).then(function() &#123; console.log(&apos;promise2&apos;);&#125;);console.log(&apos;script end&apos;); 12345678// 结果script startscript endpromise1promise2setTimeout// 当前循环结束// 进入下一个循环 从webapi在Eventloop的执行环境我们可以知道setTimeout在当前事件循环中将会在script end后执行，这是没问题的。而promise作为microtasks将会在当前事件循环内的macrotasks之前执行完毕。setTimeout作为macrotasks在例1中是最后执行的。 12345678910111213141516171819例2setImmediate(function()&#123; console.log(1);&#125;,0);setTimeout(function()&#123; console.log(2);&#125;,0);new Promise(function(resolve)&#123; console.log(3); resolve(); console.log(4);&#125;).then(function()&#123; console.log(5);&#125;);console.log(6);process.nextTick(function()&#123; console.log(7);&#125;);console.log(8); 12// 执行顺序3 4 6 8 7 5 2 1 例2process.nextTick在node环境中，属于microtasksetImmediate在macrotasks，优先级小于setTimeout定义new Promise() 是同步代码，在栈内先执行 1234567891011121314151617181920212223242526例3const p = new Promise((res, rej) =&gt; &#123; res(1) console.log(&apos;定义new Promise - 同步&apos;)&#125;).then(val =&gt; &#123; console.log(&apos;microtask start&apos;) console.log(&apos;执行then，enqueue micarotask 1&apos;) console.log(val) // 1&#125;)Promise.resolve(&#123; then(res, rej) &#123; console.log(&apos;执行then，enqueue micarotask 2&apos;) res(5) &#125;&#125;).then(val =&gt; &#123; console.log(&apos;执行then，enqueue micarotask 3&apos;) console.log(val) // 5&#125;)console.log(&apos;逐行执行1 - 同步&apos;)console.log(&apos;逐行执行2 - 同步&apos;)console.log(3) // 3setTimeout(console.log, 0, &apos;macrotask start&apos;) // 4 setTimeout(console.log, 0, 4) // 4 执行结果如下1234567891011121314151617定义new Promise - 同步逐行执行1 - 同步逐行执行2 - 同步3// 同步队列执行完毕为空 进入下一个栈microtask start执行then，enqueue micarotask 11执行then，enqueue micarotask 2执行then，enqueue micarotask 35// microtask执行完毕为空 进入下一个栈macrotask start4// macrotask执行完毕为空 结束 例3定义new Promise是同步函数Promise.resolve等api为异步micarotask 123456789101112131415161718192021222324252627282930例4&lt;div class=&quot;outer&quot;&gt; &lt;div class=&quot;inner&quot;&gt;&lt;/div&gt;&lt;/div&gt;var outer = document.querySelector(&apos;.outer&apos;);var inner = document.querySelector(&apos;.inner&apos;);new MutationObserver(function() &#123; console.log(&apos;mutate&apos;);&#125;).observe(outer, &#123; attributes: true&#125;);function onClick() &#123; console.log(&apos;click&apos;); setTimeout(function() &#123; console.log(&apos;timeout&apos;); &#125;, 0); Promise.resolve().then(function() &#123; console.log(&apos;promise&apos;); &#125;); outer.setAttribute(&apos;data-random&apos;, Math.random());&#125;inner.addEventListener(&apos;click&apos;, onClick);outer.addEventListener(&apos;click&apos;, onClick); 123456789// 同时点击到两个div时执行结果clickpromisemutateclickpromisemutatetimeouttimeout 例4执行效果没点击前：1绑定new MutationObserver 存入浏览器资源2绑定两个div元素的click事件 存入浏览器资源 3触发outer元素click的onClick 存入浏览器资源4触发inner元素click的onClick 存入浏览器资源5先执行outer的回调6输出click7执行setTimeout - macrotask存入浏览器资源8执行outer.setAttribute(‘data-random’, Math.random())，触发MutationObserver - marcotask 等待microtask先执行9执行Promise.resolve - microtask 输出promise10microtask 执行完毕，执行MutationObserver输出mutate—–下面执行的并不是outer回调里的setTimeout——11执行inner的回调12输出inner回调的click13执行inner回调的setTimeout - macrotask存入浏览器资源14执行inner回调outer.setAttribute(‘data-random’, Math.random())，触发MutationObserver - marcotask 等待microtask先执行15执行inner回调的Promise.resolve - microtask 输出promise16microtask 执行完毕，执行MutationObserver输出mutate–最后因为两个setTimeout都是在触发inner回调后存入浏览器资源的–所以最后两个setTimeout回调完成排入队列执行.","categories":[{"name":"Font-End Basis","slug":"Font-End-Basis","permalink":"http://yoursite.com/categories/Font-End-Basis/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"Event Loop 事件循环","slug":"Event Loop 事件循环","date":"2018-01-22T04:32:59.000Z","updated":"2018-01-22T04:36:08.000Z","comments":true,"path":"2018/01/22/Event Loop 事件循环/","link":"","permalink":"http://yoursite.com/2018/01/22/Event Loop 事件循环/","excerpt":"","text":"名词解释 “event-loop”: 事件循环“non-blocking”: 非堵塞“callback”: 回调函数“asynchronous”: 异步“single-threaded”: 单线程“concurrency”: 并发“web-api”: DOM, ajax, setTimeout… JS在浏览器中的环境先看一张图图片出自 V8引擎内的JS根据上图，首先可以得到的JS在V8引擎中有一个堆(heap)和栈(stack)的概念堆(heap): 对象被分配的区域栈(stack): 函数调用形成的栈帧 问题1: 执行JS时候发生了什么代码112345678910111213var a, bfunction foo () &#123; return a +=1&#125;function bar () &#123; return b += 2&#125;function baz () &#123; bar () foo () console.log( a + b )&#125;baz() 解释1 栈内：1执行baz() 进入栈2执行bar() 进入栈 - bar() return 退出栈3执行foo() 进入栈 - foo() return 退出栈4执行console.log 进入栈 无return并退出栈5baz() 执行完毕退出栈 JS操作WebApi根据图中WebApi所在的位置我们发现它并没有在V8引擎内，而是由stack内执行后再V8资源外层出现然后进入回调队列，并进行了一次event loop的事件 问题2: JS操作WebApi发生了什么?WebApi的执行不在V8内那在哪里?代码212345console.log('hi')setTimeout(function () &#123; console.log('ha')&#125;, 5000)console.log('heng') 解释2 栈内:1执行console.log(‘hi’) 进入栈 - 退出栈2执行setTimout 进入栈 - 把回调函数cb放入浏览器资源内(相对V8) - 退出栈3执行console.log(‘heng’)进入栈 - 退出栈4当前栈清空当前事件循环(event loop)结束 栈外:5通过while(queue.length)不停的检查队列(queue)是否为空6存放在浏览器资源内的setTimeout回调cb在5秒完成后进入队列(queue)7事件循环while(queue.length)检查到队列(queue)有回调cb8在当前循环内把cb推入栈内 栈内:9执行cb，console.log(‘ha’)进入栈 - 退出栈10清空栈 问题3: 如果setTimeout(cb, 0) 会是什么情况?代码312345console.log('hi')setTimeout(function () &#123; console.log('ha')&#125;, 0)console.log('heng') 解释3 同解释2，但是再第6步: 存放在浏览器资源内的setTimeout回调cb在5秒完成后进入队列(queue)应该变为cb直接进入队列(queue) 问题4: ajax是什么情况?代码412345console.log('hi')$.get(url, function (data) &#123; console.log(data)&#125;)console.log('heng') 解释4 同解释2，但是再第6步: 存放在浏览器资源内的setTimeout回调cb在5秒完成后进入队列(queue)应该变为ajax取得数据后cb进入队列()所以这也解释了为什么使用setTimeout来模拟ajax 问题5: WebApi中Event事件是什么情况？代码512345678console.log('start')$el.on('click', function fn() &#123; console.log('clicked')&#125;)setTimeout(function cb() &#123; console.log('timeout')&#125;, 5000)console.log('done') 解释5 栈内:1执行console.log(‘start’)进入栈 - 退出栈2执行$el.on(‘click’)进入栈 - 整个click事件包括回调函数fn放入浏览器资源内 - 退出栈3执行setTImeout 进入栈 - 把回调函数cb放入浏览器资源内 - 退出栈4执行console.log(‘done’)进入栈 - 退出栈 栈外:5通过while(queue.length)不停的检查队列(queue)是否为空6存放在浏览器资源内的setTimeout回调cb在5秒完成后进入队列(queue)7事件循环while(queue.length)检查到队列(queue)有回调cb8在当前循环内把cb推入栈内 栈内:9执行cb，console.log(‘ha’)进入栈 - 退出栈10清空栈 浏览器中:11用户点击$el触发’click’ 事件，回调函数fn进入队列中12事件循环while(queue.length)检查到队列(queue)有回调fn13在当前循环内把fn推入栈内执行并清空 问题6 - 列表滚动优化与Debounce去抖函数从问题5中可以知道，当我们连续不停的点击$el触发click时，队列(queue)内将会排满回调函数，这就是页面造成卡顿的原因。造成这种情况出现最多的就是列表滚动scroll事件, 窗口resize事件。常用的优化方法就是使用debounce去抖函数, 先看一下他的实现方法:1234567891011function debounce(fn, delay) &#123; var timer return function() &#123; var context = this var args = arguments clearTimeout(timer) timer = setTimeout(function() &#123; fn.apply(context, args) &#125;, delay) &#125;&#125; 分析debouncedebounce函数里有一个重点，就是clearTimeout(timer)现在模拟一个绑定事件1234document.addEventListener('scroll', debounce(function() &#123; console.log('scroll')&#125;, 1000), false); 当scroll事件在栈内执行回调函数被注册到浏览器资源后，当我们触发scroll事件时，我们都会把debounce(function(){console.log(&#39;scroll&#39;)}, 1000)排到队列(queue)里，在通过事件循环放入栈内执行。 如果1秒内只触发1次，那么debounce函数的回调就会因为内部的setTimeout放入浏览器资源等到1秒到后排如队列内在推入栈内执行。\b 但1秒内我们不停的触发scroll事件呢，那么debounce函数内部的clearTimeout(timer)将起到关键作用: 把前一次触发scroll事件放入浏览器资源的setTimeout回调给清空掉并放入新的setTimeout回调直到最后一次触发scroll，把浏览器资源内的setTimeout回调都清空只留下最后一个，等待1秒后回调排入队列(queue)等待推入栈内执行。 此方法相比问题5中的情况大大减少了浏览器资源的占用，使得在固定时间内队列(queue)内都只有一个回调在等待而不是一大堆。 异步执行12345678910代码1[1,2,3,4].forEach(function (i) &#123; console.log(i)&#125;)代码2[1,2,3,4].forEach(function (i) &#123; setTimeout(function (i) &#123; console.log(i) &#125;, 0, i)&#125;) 分析代码1中打印1，2，3，4 很明显它们都是直接在栈内执行console.log()输出的代码2页打印相同的结果，但是不同的是每次console.log的执行都是通过setTImeout放入队列(queue)内再推入栈内执行的，这就通过浏览器资源和V8资源的区别实现了一段异步执行的代码我们可以第二段代码改写成这样, 制作一个异步执行的forEach12345678function asyncForEach(arr, cb) &#123; arr.forEach(function (i) &#123; setTimeout(cb, 0, i) &#125;)&#125;asyncForEach([1,2,3,4], function(i) &#123; console.log(i)&#125;)","categories":[{"name":"Font-End Basis","slug":"Font-End-Basis","permalink":"http://yoursite.com/categories/Font-End-Basis/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"http 缓存","slug":"缓存","date":"2018-01-22T04:27:35.000Z","updated":"2018-01-22T04:28:26.000Z","comments":true,"path":"2018/01/22/缓存/","link":"","permalink":"http://yoursite.com/2018/01/22/缓存/","excerpt":"","text":"4种缓存方式HTTP缓存控制参考 分类和区别规定了过期时间： 响应header 描述 常用响应返回内容 推荐 特点 缺点 场景 Cache-Control 在多少秒内进行缓存 public, max-age=秒 是 固定时间 Expires 在此时间前进行缓存 格林威治时间 否 绝对时间 受客户端时间影响 兼容http1.0 需进行比较，会返回304状态码： 响应header 请求header 描述 常用响应返回内容 推荐 特点 缺点 场景 ETag If-None-Match 固定字符串 md5 是 检测文件完整性 Last-Modified If-Modified-Since 在某时间后没再更改 格林威治时间 否 浏览器根据返回的时间自己决定缓存 浏览器差异 Tips：Cache-Control与Expires一样，都是在某个时间未到来前进行缓存默认第一个请求(主页)的请求头里会自动加上Cache-Control: max-age=0，这个请求无论响应头的Cache-Control是什么设置都不会缓存，减少请求次数同时减少下载次数ETag方式通过检查request.headers里的if-None-Match里的32位md5字符串来检测文件完整性决定是否更新, 如果md5匹配成功则返回304，只减少下载次数 Cache-Control 与 Last-Modified / if-Modified-Since 比较 对于所有可以缓存的资源都可以同时使用这两种策略进行缓存Cache-Control/Expires的优先级要高于Last-Modified/ETag Cache-Control:1设置固定过期时间2文件在过期时间没到之前都不进行请求也不进行下载更新3解决方法只能通过加时间戳改变文件名解决 Last-Modified / if-Modified-Since:1通过给文件内容进行哈希算法来确定文件内容版本2通过对请求头if-Modified-Since的字符串来检测文件内容有没改变3文件内容没改变则不更新资源，跟请求资源的文件名关系不大但每次都需要请求4可以通过标识文件版本名、加长缓存时间的方式来减少304响应。 结论 1需要兼容HTTP1.0的时候需要使用Expires，不然可以考虑直接使用Cache-Control2需要处理一秒内多次修改的情况，或者其他Last-Modified处理不了的情况，才使用ETag，否则使用Last-Modified。3对于所有可缓存资源，需要指定一个Expires或Cache-Control，同时指定Last-Modified或者Etag。4可以通过标识文件版本名、加长缓存时间的方式来减少304响应。HTTP缓存控制参考 MD5hash算法任何文件或数据都可以通过MD5算法转化成一个32位的固定字符串场景：1检查缓存的文件内容是否有变化2检查下载文件是否下载完毕(cat xxx.mp4 | md5)","categories":[{"name":"http","slug":"http","permalink":"http://yoursite.com/categories/http/"}],"tags":[{"name":"http","slug":"http","permalink":"http://yoursite.com/tags/http/"}]},{"title":"flex布局","slug":"flex","date":"2018-01-22T04:02:11.000Z","updated":"2018-01-22T04:24:40.000Z","comments":true,"path":"2018/01/22/flex/","link":"","permalink":"http://yoursite.com/2018/01/22/flex/","excerpt":"","text":"flex之前 文档流布局 float + clear 相对定位 + 绝对定位 display inline-block 负margin flex特点 布局与方向无关 空间自动分配、自动对齐 适用于简单的线性布局 基本概念基本flex flex container的六个属性(父元素) 在下面demo的父元素里审查元素加上各种属性试试1flex-direction2flex-wrap &amp; flex-direction3缩写flex-flow: [direction] [wrap] 4justify-content5align-items6align-content flex item的六个属性1flex-grow2flex-shrink3flex-basis4缩写flex: [grow] [shrink] [basis]5order6align-self demo1手机页面布局topbar+main+tabs上下固定2产品列表ul&gt;li*9抛弃负margin3PC页面布局中间自适应抛弃双飞翼4完美居中 参考css-tricksflex布局-阮一峰","categories":[{"name":"css","slug":"css","permalink":"http://yoursite.com/categories/css/"}],"tags":[{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"}]},{"title":"Hello World","slug":"hello-world","date":"2018-01-21T14:02:59.000Z","updated":"2018-01-21T14:02:59.000Z","comments":true,"path":"2018/01/21/hello-world/","link":"","permalink":"http://yoursite.com/2018/01/21/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}
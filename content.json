{"meta":{"title":"Minimalist","subtitle":null,"description":null,"author":"Yang Ran","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"my-article","slug":"my-article","date":"2023-09-12T11:53:41.000Z","updated":"2023-09-12T12:33:51.048Z","comments":true,"path":"2023/09/12/my-article/","link":"","permalink":"http://yoursite.com/2023/09/12/my-article/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"编写React组件要点-单一责任原则","slug":"编写React组件要点-单一责任原则","date":"2018-10-28T15:22:31.000Z","updated":"2018-10-28T15:23:32.680Z","comments":true,"path":"2018/10/28/编写React组件要点-单一责任原则/","link":"","permalink":"http://yoursite.com/2018/10/28/%E7%BC%96%E5%86%99React%E7%BB%84%E4%BB%B6%E8%A6%81%E7%82%B9-%E5%8D%95%E4%B8%80%E8%B4%A3%E4%BB%BB%E5%8E%9F%E5%88%99/","excerpt":"","text":"什么是单一原则 单一责任原则 SRP(Single responsibility principle) 是一种计算机编程原理，它规定每个模块或类应该对软件提供的单个功能负责。\b 在 React 里单一责任原则要求组件改变时只有一个原因。 React 组件使用单一责任原则时，当它改变时只会有一个原因，做一件事就会更简单。 多责任陷阱 直接编码，不划分结构 写一个大组件，不划分组件 对 callback、props、fetch 都不拆分 反模式、上帝组件。 多见于 , , , 大量代码 React 单一责任原则设想一个组件12345678910111213141516171819202122232425262728import axios from &apos;axios&apos;; // 组件具有多个职责class Weather extends Component &#123; constructor(props) &#123; super(props); this.state = &#123; temperature: &apos;N/A&apos;, windSpeed: &apos;N/A&apos; &#125;; &#125; render() &#123; const &#123; temperature, windSpeed &#125; = this.state; return ( &lt;div className=&quot;weather&quot;&gt; &lt;div&gt;Temperature: &#123;temperature&#125;°C&lt;/div&gt; &lt;div&gt;Wind: &#123;windSpeed&#125;km/h&lt;/div&gt; &lt;/div&gt; ); &#125; componentDidMount() &#123; axios.get(&apos;http://weather.com/api&apos;).then(function(response) &#123; const &#123; current &#125; = response.data; this.setState(&#123; temperature: current.temperature, windSpeed: current.windSpeed &#125;) &#125;); &#125;&#125; 这个组件有两个方式会改变：(setState 和 render 会导致组件渲染)1 componentDidMount() 请求 http://weather.com/api 获取数据时 this.setState2 在 render() 里渲染数据时 改写当前组件123456789101112131415161718192021222324import axios from &apos;axios&apos;; // 当前组件只负责获取数据class WeatherFetch extends Component &#123; constructor(props) &#123; super(props); this.state = &#123; temperature: &apos;N/A&apos;, windSpeed: &apos;N/A&apos; &#125;; &#125; render() &#123; const &#123; temperature, windSpeed &#125; = this.state; return ( &lt;WeatherInfo temperature=&#123;temperature&#125; windSpeed=&#123;windSpeed&#125; /&gt; ); &#125; async componentDidMount() &#123; const response = await axios.get(&apos;http://weather.com/api&apos;); const &#123; current &#125; = response.data; this.setState(&#123; temperature: current.temperature, windSpeed: current.windSpeed &#125;); &#125;&#125; 12345678910// 组件只负责展示数据，展示逻辑可写在内部 function WeatherInfo(&#123; temperature, windSpeed &#125;) &#123; const windInfo = windSpeed === 0 ? &apos;calm&apos; : `$&#123;windSpeed&#125; km/h`; return ( &lt;div className=&quot;weather&quot;&gt; &lt;div&gt;Temperature: &#123;temperature&#125;°C&lt;/div&gt; &lt;div&gt;Wind: &#123;windInfo&#125;&lt;/div&gt; &lt;/div&gt; );&#125; HOC 高阶组件 借用高阶函数的概念：高阶组件是一个函数，入参接受一个组件返回值也是一个组件 属性代理 props proxy 高阶组件为封装的组件传递新的 props 或者改变现有的 props，这种方式称为属性代理 12345678910111213141516function withNewFunctionality(WrappedComponent) &#123; return class NewFunctionality extends Component &#123; render() &#123; const newProp = &apos;Value&apos;; const propsProxy = &#123; ...this.props, // Alter existing prop: ownProp: this.props.ownProp + &apos; was modified&apos;, // Add new prop: newProp &#125;; return &lt;WrappedComponent &#123;...propsProxy&#125; /&gt;; &#125; &#125;&#125;const MyNewComponent = withNewFunctionality(MyComponent); 渲染劫持 render highjacking 通过更改组件 render 方法来改变组件的渲染方式，这种方式称为渲染劫持 123456789101112131415161718function withModifiedChildren(WrappedComponent) &#123; return class ModifiedChildren extends WrappedComponent &#123; render() &#123; const rootElement = super.render(); const newChildren = [ ...rootElement.props.children, // Insert a new child: &lt;div&gt;New child&lt;/div&gt; ]; return cloneElement( rootElement, rootElement.props, newChildren ); &#125; &#125;&#125;const MyNewComponent = withModifiedChildren(MyComponent); HOC 高阶组件单一责任原则先定义多重责任组件1234567891011121314151617181920212223242526272829class PersistentForm extends Component &#123; constructor(props) &#123; super(props); this.state = &#123; inputValue: localStorage.getItem(&apos;inputValue&apos;) &#125;; this.handleChange = this.handleChange.bind(this); this.handleClick = this.handleClick.bind(this); &#125; render() &#123; const &#123; inputValue &#125; = this.state; return ( &lt;div className=&quot;persistent-form&quot;&gt; &lt;input type=&quot;text&quot; value=&#123;inputValue&#125; onChange=&#123;this.handleChange&#125;/&gt; &lt;button onClick=&#123;this.handleClick&#125;&gt;Save to storage&lt;/button&gt; &lt;/div&gt; ); &#125; handleChange(event) &#123; this.setState(&#123; inputValue: event.target.value &#125;); &#125; handleClick() &#123; localStorage.setItem(&apos;inputValue&apos;, this.state.inputValue); &#125;&#125; constructor 内进行数据初始化 button 点击时保存数据 input 内容改变时更新组件状态 抽离出保存数据逻辑1234567891011121314151617181920212223242526272829class PersistentForm extends Component &#123; constructor(props) &#123; super(props); this.state = &#123; inputValue: props.initialValue &#125;; this.handleChange = this.handleChange.bind(this); this.handleClick = this.handleClick.bind(this); &#125; render() &#123; const &#123; inputValue &#125; = this.state; return ( &lt;div className=&quot;persistent-form&quot;&gt; &lt;input type=&quot;text&quot; value=&#123;inputValue&#125; onChange=&#123;this.handleChange&#125;/&gt; &lt;button onClick=&#123;this.handleClick&#125;&gt;Save to storage&lt;/button&gt; &lt;/div&gt; ); &#125; handleChange(event) &#123; this.setState(&#123; inputValue: event.target.value &#125;); &#125; handleClick() &#123; this.props.saveValue(this.state.inputValue); &#125;&#125; 改写组件，使数据初始化和保存功能都由 props 传递 此组件现在只负责 input 的数据变化，数据和保存逻辑都由外部提供 编写可复用的单一责任原则的高阶组件12345678910111213141516171819202122232425// 给函数传递两个参数，一个是数据获取的 key 值，一个是存储函数function withPersistence(storageKey, storage) &#123; // 高阶组件函数 return function(WrappedComponent) &#123; return class PersistentComponent extends Component &#123; constructor(props) &#123; super(props); this.state = &#123; initialValue: storage.getItem(storageKey) &#125;; &#125; render() &#123; return ( &lt;WrappedComponent initialValue=&#123;this.state.initialValue&#125; saveValue=&#123;this.saveValue&#125; &#123;...this.props&#125; /&gt; ); &#125; saveValue(value) &#123; storage.setItem(storageKey, value); &#125; &#125; &#125;&#125; 123// 调用方式const LocalStoragePersistentForm = withPersistence(&apos;key&apos;, localStorage)(PersistentForm); 隔离了数据操作和展示操作 数据操作可以通过高阶函数传参改变存储 API 或 key 值 符合单一责任原则：允许在隔离中进行修改，从而较少影响系统的其他部分。","categories":[{"name":"React","slug":"React","permalink":"http://yoursite.com/categories/React/"}],"tags":[{"name":"React","slug":"React","permalink":"http://yoursite.com/tags/React/"}]},{"title":"HTTP相关系统知识","slug":"HTTP相关系统知识","date":"2018-10-26T15:22:06.000Z","updated":"2018-10-26T15:23:13.673Z","comments":true,"path":"2018/10/26/HTTP相关系统知识/","link":"","permalink":"http://yoursite.com/2018/10/26/HTTP%E7%9B%B8%E5%85%B3%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86/","excerpt":"","text":"因特网协议五层协议 物理层定义物理设备如何传输数据 数据链路层在通信的实体间建立数据链路连接 网络层为数据在节点之间传输创建逻辑链路 传输层向用户提供可靠的端到端服务传输层向高层屏蔽了下层数据通信的细节 应用层为应用软件提供了更多服务构建于 TCP 协议之上屏蔽网络传输相关细节 HTTP 历史 HTTP / 0.9只有一个命令 GET没有HEADER 等描述数据的信息服务器发送完毕就关闭 TCP 连接 HTTP / 1.0增加了很多命令增加 status code 和header多字符集的支持、多部分发送、权限、缓存 HTTP / 1.1持久连接pipeline(同一个连接里发送多个请求)增加 host 和其他命令 (物理服务、集群里 host 区分部署的 web 服务) HTTP2所有数据以二进制传输同一个连接里发送多个请求不再需要按照顺序(并行)头信息压缩以及推送提高效率的功能(资源返回和 ajax 并行) URI 、URL、URN URIUniform Resource Identifier / 统一资源标识符用来标识互联网上唯一的信息资源包括 URL、URN URLUniform Resource Locator / 统一资源定位器http、ftp 协议都是同一个格式http://user:pass@host.com:80/path?query=string#hashschema: http:// file:// https://host: 找到物理服务器端口: 定位 web 服务器path: 路由、资源目录query: 查询参数hash: 文档片段、锚点定位 URN永久统一资源定位符在资源移动之后还能被找到不成熟 HTTP 请求 报文 HTTP 方法用来定义对于资源的操作常用 GET、POST、DETEL、PUT、PATCH有各自的语义 HTTP code定义服务器对请求的处理结果各个区间的 code 各自的语义好的 HTTP 服务可以通过 code 判断结果 命令行发送请求 curl1curl -v url 同源限制Access-Control-Allow-Origin CORS 预请求 允许方法GET HEAD POST 允许的Content-Typetext/plainmultipart/form-dataapplication/x-www-form-urlencoded 其他限制自定义 header 限制XMLHttpRequestUpload 对象没有注册时间监听请求中没有使用 ReadableStream 对象 HTTP 缓存 强缓存 Cache-Control可缓存性public: 任何地方都可缓存，http 代理服务器、发出请求的客户端浏览器都可缓存private: 发起请求的客户端浏览器才可缓存no-cache: 任何节点都不可使用缓存(可缓存但服务器指定其不使用) 到期max-age=&lt;seconds&gt;: 缓存时间s-maxage=&lt;seconds&gt;: 会代替 max-age 只在代理服务器生效max-stale=&lt;seconds&gt;: max-age 过期后仍然使用过期缓存，发起请求的客户端设置(浏览器不常用) 资源重新验证must-revalidate: 过期后会去原服务端验证是否过期proxy-revalidate: 指定的缓存服务器验证是否过期 其他no-store: 本地不可缓存no-transform: 常用于 proxy 服务器里, 资源不可转换压缩 协商缓存验证 header Last-Modified Etag Last-Modified配合 If-Modified-Since 或 If-Unmodified-Since 使用对比上次修改时间验证资源是否需要更新 Etag文件完整性 hash 数据签名配合 If-Match 或 If-Non-Match 使用对比资源的 hash 签名是否一致决定是否使用缓存 cookie &amp; sessioncookieSet-Cookie 设置同源下再次请求会自动带上键值对形式，可以设置多个 cookie 属性max-age 和 expires 设置过期时间Secure 只在 https 请求的时候才发送 cookieHttpOnly 无法通过 document.cookie 访问 cookiedomain 设置二级域名可访问的 cookie (domain=yang.com，a.yang.com, b.yang.com 都可以访问) 长连接Connection: keep-alive | closehttp/1.1 无法并发，在网速慢的情况下还是会创建多个 ConnectionID 数据协商分类MIME types 请求 响应 请求 header - AcceptAccept: 想要的数据类型Accept-Encoding: 什么样的编码方式传输, 用于数据压缩格式Accept-Language: 数据语言User-Agent: 浏览器信息判断 响应 header - ContentContent-Type: 返回的数据格式Content-Encoding: 对应客户端请求的 Accept-EncodingContent-Language: 对应客户端请求的 Accept-Language 数据压缩zlib 压缩zlib.gzipSync(buffer)Content-Encoding: gzip没压缩前压缩后 文件数据协商Content-Type: multipart/form-data 重定向 redirect响应 header : Location: /url响应 CODE: 302 301 才可以跳转123response.writeHead(301, &#123; &apos;Location&apos;: &apos;/new&apos;,&#125;) 301 302 区别 302 临时跳转请求 / 重定向到 /new每次后台都会收到两次请求 301 永久跳转浏览器会尽量长的缓存 301 请求，需要慎重设置, 浏览器如果不清缓存会造成一直跳转 请求 / 重定向到 /new后台第一次会收到两次请求第二次只会收到/new 内容安全策略 CSPContent-Security-Policy:限制资源获取报告资源获取越权 限制方式default-src 限制全局制定资源类型 资源类型MDNconnect-src / img-src / style-src / script-src 等 设置 CSP12345678// 服务端设置 &apos;Content-Security-Policy&apos;: &apos;default-src http: https:&apos; // 只能根据外链 &apos;Content-Security-Policy&apos;: &apos;script-src http: https:&apos; // 只限制script &apos;Content-Security-Policy&apos;: &apos;default-src \\&apos;self\\&apos; https://cdn.bootcss.com&apos; // 只根据本域名, 增加 cdn.bootcss.com 域名 &apos;Content-Security-Policy&apos;: &apos;default-src \\&apos;self\\&apos;&apos; // 只根据本域名 &apos;Content-Security-Policy&apos;: &apos;default-src \\&apos;self\\&apos;; form-action \\&apos;self\\&apos;&apos; // 限制表单提交 &apos;Content-Security-Policy&apos;: &apos;default-src \\&apos;self\\&apos;; form-action \\&apos;self\\&apos;; report-uri /report&apos; // 服务器上报 &apos;Content-Security-Policy-Report-Only&apos;: &apos;default-src \\&apos;self\\&apos;; form-action \\&apos;self\\&apos;; report-uri /report&apos; // 服务器只上报，但是课加载 12// meta 标签设置 &lt;meta http-equiv=&quot;Content-Security-Policy&quot; content=&quot;default-src &apos;self&apos;; form-action &apos;self&apos;; report-uri /report&quot;&gt; 被 csp 禁止 设置 connect-src 可以限制 ajax 发送 nginx统一配置文件nginx.conf1include servers/*; // 此目录下的所有 .conf 文件 代理访问 yang.com 下的 / 路径代理到本地 8888 端口123456789server &#123; listen 80; server_name yang.com; # 要配置 host 不然就访问外网了 location / &#123; proxy_pass http://127.0.0.1:8888; proxy_set_header Host $host; # host配置 &#125;&#125; 代理缓存12345678910111213# 缓存proxy_cache_path cache levels=1:2 keys_zone=my_cache:10m; # levels=1:2 是否创建二级文件夹, keys_zone 缓存大小server &#123; listen 80; server_name yang.com; # 要配置 host 不然就访问外网了 location / &#123; proxy_cache my_cache; # 配置的缓存名 proxy_pass http://127.0.0.1:8888; proxy_set_header Host $host; # host配置 &#125;&#125; 1234&apos;Cache-Control&apos;: &apos;max-age=5, s-maxage=20&apos; 浏览器缓存 5s 代理服务器缓存 20s&apos;Cache-Control&apos;: &apos;max-age=5, s-maxage=20, private&apos; // 只可浏览器缓存&apos;Cache-Control&apos;: &apos;max-age=5, s-maxage=20, no-store&apos; // 都不可缓存&apos;Vary&apos;: &apos;X-Test-Cache&apos; // 指定的 X-Test-Cache 头才可缓存，比如 req header 发了 X-Test-Cache： user-agent， s-maxage 代理服务器缓存，对应多个客户端请求加速 Vary 当 req.header: X-Test-Cache 为 1 时发送后，代理缓存了 X-Test-Cache 为 1 这个请求，下次其他客户端请求 X-Test-Cache 为 1 则使用代理服务器缓存。可以使用 user-agent 进行代理服务器的设备缓存。 HTTPS 生成密钥1openssl req -x509 -newkey rsa:2048 -nodes -sha256 -keyout test-privkey.pem -out test-cert.pem nginx 生成 https 服务1234567891011121314server &#123; listen 443; server_name yang.com; # 要配置 host 不然就访问外网了 ssl on; ssl_certificate_key /usr/local/etc/openssl/test/test-privkey.pem; # 密钥路径 ssl_certificate /usr/local/etc/openssl/test/test-cert.pem; # 密钥路径 location / &#123; proxy_cache my_cache; # 配置的缓存名 proxy_pass http://127.0.0.1:8888; proxy_set_header Host $host; # host配置 &#125;&#125; http 跳转到 https1234567# http 跳转到 httpsserver &#123; listen 80 default_server; listen [::]:80 default_server; server_name yang.com; return 302 https://$server_name$request_uri; # 进行 302 跳转&#125; HTTP2开启 https 才可使用 http2 优势信道复用、分帧传输: 并发的 TCP 连接只创建一个 TCPServer Push: 服务端主动发送 server 编写 http2123456789101112// ... if (request.url === &apos;/&apos;) &#123; response.writeHead(200, &#123; &apos;Content-Type&apos;: &apos;text/html&apos;, &apos;Connection&apos;: &apos;close&apos;, &apos;Link&apos;: &apos;&lt;/carbon.png&gt;; as=image; rel=preload&apos; // http2 需要进行服务端推送 &#125;) response.end(html) &#125;// ... nginx 将 http2 转为 http1.1nginx 可以将 http2 转成 1.1 版本传输给服务端123456789101112131415server &#123; listen 443 http2; server_name yang.com; # 要配置 host 不然就访问外网了 http2_push_preload on; # 开启服务器推送 ssl on; ssl_certificate_key /usr/local/etc/openssl/test/test-privkey.pem; ssl_certificate /usr/local/etc/openssl/test/test-cert.pem; location / &#123; proxy_cache my_cache; # 配置的缓存名 proxy_pass http://127.0.0.1:8888; proxy_set_header Host $host; # host配置 &#125;&#125; 推送结果测试 HTTP2 性能123$ curl -v https://yang.com $ curl -v -k https://yang.com // 打开不安全 ssl 限制$ curl -v -k --http1.1 https://yang.com // 指定 http1.1 访问","categories":[{"name":"http","slug":"http","permalink":"http://yoursite.com/categories/http/"}],"tags":[{"name":"http","slug":"http","permalink":"http://yoursite.com/tags/http/"}]},{"title":"JavaScript 中的垃圾回收","slug":"JavaScript中的垃圾回收","date":"2018-04-16T17:12:31.000Z","updated":"2018-04-16T17:12:57.000Z","comments":true,"path":"2018/04/17/JavaScript中的垃圾回收/","link":"","permalink":"http://yoursite.com/2018/04/17/JavaScript%E4%B8%AD%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/","excerpt":"","text":"1234内存的生命周期javascript 的内存分配javascript 垃圾回收的方法和方式哪些操作会造成内存泄漏 内存的生命周期1 分配所需要的内存2 使用分配到的内存进行读写操作3 不需要时将内存进行清除 javascript 的内存分配 变量初始化分配 1234567891011var str = &apos;string&apos; // 为字符串分配内存var arr = [1, 2] // 为数组及数值分配内存var obj = &#123; // 为对象及承载的数值分配内存 a: 1&#125;function fn(a, b) &#123; // 为可调用的函数变量 fn 对象分配内存 return a + b&#125;el.addEventListener(&apos;click&apos;, function() &#123; // 函数表达式, 匿名函数分配内存 el.style.color = &apos;red&apos; &#125;) 调用函数分配 123var d = new Date(); // 为Date 对象值分配内存var e = document.createElement(&apos;div&apos;); // 为 DOM 对象分配内存 javascript 垃圾回收的方法 引用计数 标记清除(常用) 引用计数引用计数垃圾回收算法123456789101112131415161718192021var o = &#123; a: &#123; b:2 &#125;&#125;; // 两个对象被创建// &#123; b: 2 &#125; 作为一个属性被引用 +1 = 1// &#123; a: &#123; b: 2 &#125; &#125; 被分配给变量 o +1 = 1var o2 = o; // o2变量是第二个对 &#123; a: &#123; b: 2 &#125; &#125; +1 = 2 的引用 o = 1; // 现在，&#123; a: &#123; b: 2 &#125; &#125; 的原始引用o被o2替换了 -1 = 1var oa = o2.a; // 引用 &#123; a: &#123; b: 2 &#125; &#125; + 1 = 2的a属性 &#123; b: 2 &#125; + 1 = 2// 现在，&#123; a: &#123; b: 2 &#125; &#125; 有两个引用了，一个是o2，一个是oao2 = &quot;yo&quot;; // &#123; a: &#123; b: 2 &#125; &#125; = 0 对象的原始引用被清除 // 然而它的属性a的对象还在被oa引用，所以还不能回收oa = null; // a属性 &#123; b: 2 &#125; 现在也是零引用了// &#123; a: &#123; b: 2 &#125; &#125; 它可以被垃圾回收了 循环引用12345678910function f()&#123; var o = &#123;&#125;; + 1 var o2 = &#123;&#125;; + 1 o.a = o2; // o 引用 o2 + 1 o2.a = o; // o2 引用 o + 1 return &quot;str&quot;;&#125;f()// var o = &#123;&#125;; var o2 = &#123;&#125;; 在栈中运行后该被清除 // o.a, o2.a 都至少引用了一次 o 和 o2 无法被清除 12345678var el;window.onload = function()&#123; el = document.getElementById(&quot;element&quot;); el.circularReference = el; el.lotsOfData = new Array(10000).join(&quot;*&quot;);&#125;;// 当element 元素被删除后应该被回收// el.circularReference 循环引用了 el, 导致对此 dom 元素的引用无法被回收, el.lotsOfData 的数据无法释放 标记清除(常用) 在全局环境或函数环境声明变量时，进入执行环境，\u001d垃圾回收器将其标记为’进入环境’，当变量离开环境、函数执行结束后将其标记为’离开环境’。垃圾收集器会在运行时通过给存储在内存中的所有变量加上标记的方式决定是否应该清除，闭包只有’进入环境’标记。垃圾收集器运行时会对标记为’离开环境’的变量和全局环境无法访问到的对象进行清除。 标记清除的循环引用123456789// 函数内声明的 o 和 o2 因为在全局环境下无法访问会被清除function f()&#123; var o = &#123;&#125;; + 1 var o2 = &#123;&#125;; + 1 o.a = o2; // o 引用 o2 + 1 o2.a = o; // o2 引用 o + 1 return &quot;str&quot;;&#125;f() 12345678// 当 element 被删除后或手动取消引用时，全局环境 el 变量为null，dom 对象占用的内存则被清除var el;window.onload = function()&#123; el = document.getElementById(&quot;element&quot;); el.circularReference = el; el.lotsOfData = new Array(10000).join(&quot;*&quot;);&#125;;el = null // 全局环境无法访问到el.circularReference 被清除 哪些操作会造成内存泄漏 settimeout的第一个参数使用字符串而非函数的话,会引发内存泄漏。意外的全局变量、闭包、控制台日志、遗留的定时器、在两个对象彼此引用且彼此保留解决方法:函数运行后手动设置 dom 为null， 手动 clear 定时器，避免循环引用。 WeakMapWeakMap 作用 WeakMap WeakSet对于值的引用都是不计入垃圾回收机制的，表示这是弱引用。先新建一个 Weakmap 实例。然后，将一个 DOM 节点作为键名存入该实例，并将一些附加信息作为键值，一起存放在 WeakMap 里面。这时，WeakMap 里面对element的引用就是弱引用，不会被计入垃圾回收机制。当我们想为对象添加数据但是又不想干扰垃圾回收机制就可以使用 123456const wm = new WeakMap();const element = document.getElementById(&apos;example&apos;); // 引用计数 + 1wm.set(element, &apos;some information&apos;); // 弱引用 - 引用计数不变wm.get(element) // &quot;some information&quot; value 可以为对象 WeakMap 示例当called 大于10后 进行 report 上报 map 对 obj 参数的引用仍然存在，造成了内存泄漏，而我们只是为obj添加了一些额外信息12345678var map = new Map(); // maps can have object keysfunction useObj(obj)&#123; doSomethingWith(obj); var called = map.get(obj) || 0; called++; // called one more time if(called &gt; 10) report(); // 应该手动清除 map 对 obj 的引用 map.set(obj, called);&#125; 使用WeakMap用于处理为对象添加信息的场景12345678var map = new WeakMap(); // create a weak mapfunction useObj(obj)&#123; doSomethingWith(obj); var called = map.get(obj) || 0; called++; // called one more time if(called &gt; 10) report(); // 无需清除引用 map.set(obj, called);&#125;","categories":[{"name":"Font-End Basis","slug":"Font-End-Basis","permalink":"http://yoursite.com/categories/Font-End-Basis/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"实现一个 Vue (1) 实现响应式原理","slug":"实现一个 Vue (1) 实现响应式原理","date":"2018-04-11T11:28:09.000Z","updated":"2018-04-11T11:29:26.000Z","comments":true,"path":"2018/04/11/实现一个 Vue (1) 实现响应式原理/","link":"","permalink":"http://yoursite.com/2018/04/11/%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%20Vue%20(1)%20%E5%AE%9E%E7%8E%B0%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86/","excerpt":"","text":"new Vue(options) 创建 Vue 实例 observer() 将处理 options.data1 创建 dep = new Dep()(订阅者) 闭包等待依赖收集 watcher(观察者)2 创建 getter 函数等待 options.data 被 getter 后执行依赖收集3 创建 setter 函数等待 options.data 改变时遍历 dep.subs: watcher[] 通知每个 watcher 进行更新 Vue 构造函数 init 执行 compile() compile() 时执行了 observer(options.data) 的 getter 函数进行 dep 对 watcher 的依赖收集 创建实例 / 更新数据 方便演示为 options.data 定义 testA testB 待响应数据 创建实例执行 Vue 按顺序执行 observer 更新 testA testB 响应数据通过 setter -&gt; dep.subs -&gt; watcher -&gt; update 更新 123456789101112// vm.jslet vm = new Vue(&#123; // 实例初始化 el: &apos;#app&apos;, data: &#123; testA: &apos;i am testA&apos;, testB: &apos;i am testB&apos;, &#125;,&#125;)// 对观察者数据更新vm._data.testA = &apos;testA change&apos;vm._data.testB = &apos;testB change&apos; Dep 订阅者依赖收集 var dep = new Dep() 创建一个订阅者 subs 为 watcher[] 类型的数组 dep.notify 会通知每个 watcher 进行更新 1234567891011121314151617// dep.jsexport default class Dep &#123; constructor() &#123; this.subs = [] &#125; addSub(sub) &#123; this.subs.push(sub) console.log(this.subs) &#125; notify() &#123; this.subs.forEach(sub =&gt; &#123; sub.update() &#125;) &#125;&#125; Watcher 观察者 被用来收集 new Watcher 时 给 Dep.target 指向为一个 watcher 实例对象 为 dep.subs addSub 时只需要增加 Dep.target update 为响应数据更新时的需处理的逻辑 123456789101112// watcher.jsimport Dep from &apos;./dep&apos;export default class Wathcher &#123; constructor() &#123; Dep.target = this &#125; update() &#123; console.log(&apos;wathcher updating!&apos;) &#125;&#125; 实现 observer1234567891011121314151617181920212223242526272829303132// observer.jsimport Dep from &apos;./dep.js&apos;export function observer(data) &#123; if (!data || typeof data !== &apos;object&apos;) &#123; return &#125; Object.keys(data).forEach(key =&gt; &#123; defineReactive(data, key, data[key]) &#125;) Dep.target = null // Watcher 添加完毕&#125;function defineReactive(data, key, val) &#123; observer(val) // 对子属性进行绑定 const dep = new Dep() // 创建一个订阅者 Object.defineProperty(data, key, &#123; enumerable: true, configurable: true, get: function proxyGetter() &#123; // view 层绑定几次 addSub 注册几个 Watcher 绑定完了Dep.target = null 继续绑定注册下个数据 Dep.target &amp;&amp; dep.addSub(Dep.target) return val &#125;, set: function proxySetter(newVal) &#123; if (val === newVal) return val = newVal dep.notify() // 响应数据更新后此数据的 dep 订阅者通知所有 watcher 观察对象 &#125; &#125;)&#125; mvvm Vue 构造函数的 compile 为 view 层绑定数据逻辑 compile 会触发响应数据的 getter 1234567891011121314151617181920212223242526// mvvm.jsimport Watcher from &apos;./watcher&apos;import &#123; observer &#125; from &apos;./observer&apos;export default class Vue &#123; constructor(options) &#123; this._data = options.data observer(this._data) new Watcher() this._init() &#125; _init() &#123; this._compile(this._data) &#125; _compile(data) &#123; // 每次 log 模拟绑定一次视图， 触发一次响应数据的 getter console.log(&apos;view 层绑定&apos;, data.testA) console.log(&apos;view 层绑定&apos;, data.testA) console.log(&apos;view 层绑定&apos;, data.testA) console.log(&apos;view 层绑定&apos;, data.testB) console.log(&apos;view 层绑定&apos;, data.testB) &#125;&#125;","categories":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/tags/Vue/"}]},{"title":"学习并实现 redux(1) - 基础 API","slug":"学习并实现 redux(1) - 基础 API","date":"2018-04-03T13:50:27.000Z","updated":"2018-04-03T13:51:19.000Z","comments":true,"path":"2018/04/03/学习并实现 redux(1) - 基础 API/","link":"","permalink":"http://yoursite.com/2018/04/03/%E5%AD%A6%E4%B9%A0%E5%B9%B6%E5%AE%9E%E7%8E%B0%20redux(1)%20-%20%E5%9F%BA%E7%A1%80%20API/","excerpt":"","text":"redux 基础 API createStore 创建 store (对外直接暴露 createStore(reducer)) getState 获取 store 当前 state，(store.getState()) subscribe 注册监听器函数(listener)，(store.subscribe(listener)) dispatch 触发 action，(store.dispatch({ type: ‘actionType’ })) reducer / listener / action reducer 由createStore(reducer) 创建store，\b用来被 store.dispatch({ type: ‘TYPE’ })命中更改 state\b 12345678910111213// reducerfunction counter(state = 0, action) &#123; console.log(state, action) // log 每次action switch (action.type) &#123; case &apos;ADD&apos;: return state + 1 case &apos;SUB&apos;: return state - 1 default: return 10 // &#123; type: @@redux/INIT &#125; 命中 &#125;&#125; listener 由store.subscribe(listener) 注册监听函数，每次 action 时都会执行 action 由store.dispatch(action) 触发通知 reducer 命中后更改store 的state redux 应用流程图 根据流程图实现 redux12345678910111213141516171819202122// redux.jsexport function createStore(reducer) &#123; let currentState = &#123;&#125; // state let currentListeners = [] // 监听器 function getState() &#123; // store.getState() 获取 state return currentState &#125; function subscribe(listener) &#123; // store.subscribe(listener) 注册listener currentListeners.push(listener) &#125; function dispatch(action) &#123; currentState = reducer(currentState, action) // 更改 state currentListeners.forEach(v =&gt; v()) // 执行listeners return action // 返回action &#125; dispatch(&#123; type: &apos;@@redux/INIT&apos; &#125;) // store 初始化时命中 reducer default return &#123; getState, subscribe, dispatch &#125; // 暴露store API&#125; 定义 reducer 创建 store 1234567891011121314151617181920import &#123; createStore &#125; from &apos;./redux&apos;// reducerfunction counter(/*initState*/state = 0, action) &#123; console.log(state, action) // log 每次action switch (action.type) &#123; case &apos;ADD&apos;: return state + 1 case &apos;SUB&apos;: return state - 1 default: return 10 // &#123; type: @@redux/INIT &#125; 命中 &#125;&#125;// storeconst store = createStore(counter)const init = store.getState()console.log(&apos;initCount:&apos; + init) 注册listener 123456// listenerfunction listener() &#123; const current = store.getState() console.log(&apos;listener - currentCount:&apos; + current)&#125;store.subscribe(listener) 执行 store.dispatch 命中reducer 123456789// actionconst ADD = &apos;ADD&apos;const SUB = &apos;SUB&apos;store.dispatch(&#123; type: ADD &#125;)store.dispatch(&#123; type: ADD &#125;)store.dispatch(&#123; type: SUB &#125;)store.dispatch(&#123; type: ADD &#125;)store.dispatch(&#123; type: SUB &#125;) 控制台输出","categories":[{"name":"React","slug":"React","permalink":"http://yoursite.com/categories/React/"}],"tags":[{"name":"Redux","slug":"Redux","permalink":"http://yoursite.com/tags/Redux/"}]},{"title":"React Tips 依赖注入、全局包裹Context","slug":"React Tips: 依赖注入、全局包裹Context","date":"2018-03-23T09:34:37.000Z","updated":"2018-03-23T09:36:12.000Z","comments":true,"path":"2018/03/23/React Tips: 依赖注入、全局包裹Context/","link":"","permalink":"http://yoursite.com/2018/03/23/React%20Tips:%20%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E3%80%81%E5%85%A8%E5%B1%80%E5%8C%85%E8%A3%B9Context/","excerpt":"","text":"依赖注入props 传递 props 层层传递 很多组件并不需要使用 props 不推荐 1234// Title.jsxexport default function Title(props) &#123; return &lt;h1&gt;&#123; props.title &#125;&lt;/h1&gt;;&#125; 123456789// Header.jsximport Title from &apos;./Title.jsx&apos;;export default function Header() &#123; return ( &lt;header&gt; &lt;Title /&gt; &lt;/header&gt; );&#125; 1234567891011// App.jsximport Header from &apos;./Header.jsx&apos;;class App extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; title: &apos;React Dependency Injection&apos; &#125;; &#125; render() &#123; return &lt;Header /&gt;; &#125;&#125; HOC 高阶组件123456// title.jsximport React from &apos;react&apos;export default function Title(props) &#123; return &lt;h1&gt;&#123; props.title &#125;&lt;/h1&gt;&#125; 1234567891011121314151617// inject.jsximport React from &apos;react&apos;export default function inject(Component) &#123; return class Injector extends React.Component &#123; render() &#123; const &#123; title &#125; = this.props return ( &lt;Component &#123;...this.state&#125; &#123;...this.props&#125; &#123;...this.children&#125; title=&#123; title &#125; /&gt; ) &#125; &#125;&#125; 123456789101112131415// header.jsximport React from &apos;react&apos;import inject from &apos;./inject&apos;import Title from &apos;./title&apos;const title = &apos;React Dependency Injection&apos;const EnhancedTitle = inject(Title)export default function Header() &#123; return ( &lt;header&gt; &lt;EnhancedTitle title=&#123;title&#125; /&gt; &lt;/header&gt; )&#125; 新版 Context API123456789101112131415161718// title.jsximport React from &apos;react&apos;import &#123; InjectContext &#125; from &apos;./inject&apos;export default class Title extends React.Component &#123; render() &#123; return ( &lt;InjectContext.Consumer&gt; &#123;context =&gt; ( &lt;div&gt; &#123;console.log(context)&#125; &lt;h1&gt;&#123;context.title&#125;&lt;/h1&gt; &lt;/div&gt; )&#125; &lt;/InjectContext.Consumer&gt; ) &#125;&#125; 123// inject.jsximport React from &apos;react&apos;export const InjectContext = React.createContext(&#123;&#125;) 12345678// header.jsximport React from &apos;react&apos;import Title from &apos;./title&apos;export default class Header extends React.Component &#123; render() &#123; return &lt;Title /&gt; &#125;&#125; 12345678910111213141516// App.jsimport React, &#123; Component &#125; from &apos;react&apos;;import Header from &apos;./header&apos;import &#123; InjectContext &#125; from &apos;./inject&apos;class App extends Component &#123; render() &#123; return ( &lt;InjectContext.Provider value=&#123;&#123; title: &apos;React Dependency Injection&apos; &#125;&#125;&gt; &lt;Header /&gt; &lt;/InjectContext.Provider&gt; ); &#125;&#125;export default App; 全局包裹Context新版Context API 实现 相比于单纯的数据对象，将context包装成一个提供一些方法的对象会是更好的实践。因为这样能提供一些方法供我们操作context里面的数据。 12345678910// dependcies.jsexport default &#123; data: &#123;&#125;, get(key) &#123; return this.data[key]; &#125;, register(key, value) &#123; this.data[key] = value; &#125;&#125; 1234567891011// header.jsximport React from &apos;react&apos;import Title from &apos;./title.jsx&apos;export default function Header() &#123; return ( &lt;header&gt; &lt;Title /&gt; &lt;/header&gt; )&#125; 1234// inject.jsimport React from &apos;react&apos;export const InjectContext = React.createContext(&#123;&#125;) 创建dependcies后可以用dependencies.register 注册数据12345678910111213141516171819// App.jsimport React, &#123; Component &#125; from &apos;react&apos;;import dependencies from &apos;./dependencies&apos;import Header from &apos;./header&apos;import &#123; InjectContext &#125; from &apos;./inject&apos;dependencies.register(&apos;title&apos;, &apos;context-react-patterns&apos;)class App extends Component &#123; render() &#123; return ( &lt;InjectContext.Provider value=&#123;dependencies&#125;&gt; &lt;Header /&gt; &lt;/InjectContext.Provider&gt; ) &#125;&#125;export default App; 然后在 Title 组件中直接从 Context 获取数据12345678910111213141516import React from &apos;react&apos;import &#123; InjectContext &#125; from &apos;./inject&apos;export default class Title extends React.Component &#123; render() &#123; return ( &lt;InjectContext.Consumer&gt; &#123;context =&gt; ( &lt;div&gt; &lt;h1&gt;&#123;context.get(&apos;title&apos;)&#125;&lt;/h1&gt; &lt;/div&gt; )&#125; &lt;/InjectContext.Consumer&gt; ) &#125;&#125; 高阶组件 HOC 实现123456789101112131415161718192021222324252627282930313233// dependencies.jsximport React from &apos;react&apos;let dependencies = &#123;&#125;export function register(key, dependency) &#123; dependencies[key] = dependency&#125;export function fetch(key) &#123; if (dependencies.hasOwnProperty(key)) return dependencies[key] throw new Error(`&quot;$&#123; key &#125; is not registered as dependency.`)&#125;export function wire(Component, deps, mapper) &#123; return class Injector extends React.Component &#123; constructor(props) &#123; super(props) this._resolvedDependencies = mapper(...deps.map(fetch)) &#125; render() &#123; return ( &lt;Component &#123;...this.state&#125; &#123;...this.props&#125; &#123;...this._resolvedDependencies&#125; // &#123;title: &quot;react-patterns&quot;&#125; /&gt; ) &#125; &#125;&#125; 在App 组件中使用register 注册数据1234567891011121314// App.jsimport React, &#123; Component &#125; from &apos;react&apos;;import Header from &apos;./header&apos;import &#123; register &#125; from &apos;./dependencies&apos;register(&apos;awesome-title&apos;, &apos;HOC-react-patterns&apos;)class App extends Component &#123; render() &#123; return &lt;Header /&gt; &#125;&#125;export default App; 1234567891011// header.jsximport React from &apos;react&apos;import Title from &apos;./title.jsx&apos;export default function Header() &#123; return ( &lt;header&gt; &lt;Title /&gt; &lt;/header&gt; )&#125; 在 Title 组件中通过 wire 注入数据1234567// title.jsximport React from &apos;react&apos;import &#123; wire &#125; from &apos;./dependencies&apos;const Title = props =&gt; (&lt;h1&gt;&#123; props.title &#125;&lt;/h1&gt;)export default wire(Title, [&apos;awesome-title&apos;], title =&gt; (&#123; title &#125;))","categories":[{"name":"React","slug":"React","permalink":"http://yoursite.com/categories/React/"}],"tags":[{"name":"React Tips","slug":"React-Tips","permalink":"http://yoursite.com/tags/React-Tips/"}]},{"title":"React Tips  JSX条件语句、setState 异步特性","slug":"React Tips  JSX条件语句、setState 异步特性","date":"2018-03-22T10:51:29.000Z","updated":"2018-03-22T10:52:59.000Z","comments":true,"path":"2018/03/22/React Tips  JSX条件语句、setState 异步特性/","link":"","permalink":"http://yoursite.com/2018/03/22/React%20Tips%20%20JSX%E6%9D%A1%E4%BB%B6%E8%AF%AD%E5%8F%A5%E3%80%81setState%20%E5%BC%82%E6%AD%A5%E7%89%B9%E6%80%A7/","excerpt":"","text":"JSX 条件语句三元表达式1234567891011const Test = function(props) &#123; const &#123; flag1, flag2 &#125; = props return ( &lt;div&gt; &#123;flag1 &amp;&amp; flag2 ? &lt;h1&gt;11111&lt;/h1&gt; : &lt;h1&gt;22222&lt;/h1&gt; &#125; &lt;/div&gt; )&#125; 立即执行函数12345678910111213141516const Test = function(props) &#123; const &#123; flag1, flag2 &#125; = props return ( &lt;div&gt; &#123; (() =&gt; &#123; if (flag1 &amp;&amp; flag2) &#123; return &lt;h1&gt;11111&lt;/h1&gt; &#125; else &#123; return &lt;h1&gt;22222&lt;/h1&gt; &#125; &#125;)() &#125; &lt;/div&gt; )&#125; 条件语句1234567const Test = function(props) &#123; const &#123; flag1, flag2 &#125; = props const condition = flag1 &amp;&amp; flag2 if (condition) return &lt;h1&gt;111111&lt;/h1&gt; if (!condition) return &lt;h1&gt;222222&lt;/h1&gt; return &lt;h1&gt;333333&lt;/h1&gt;&#125; do 表达式(stage0新提案)12345678910111213141516const Test = function(props) &#123; const &#123; flag1, flag2 &#125; = props return ( &lt;div&gt; &#123; do &#123; if (flag1 &amp;&amp; flag2) &#123; &lt;h1&gt;11111&lt;/h1&gt; &#125; else &#123; &lt;h1&gt;22222&lt;/h1&gt; &#125; &#125; &#125; &lt;/div&gt; )&#125; setState() 异步 setState 时 函数会创建一个暂态的state作为过渡state，而不是立即修改this.state。 如果在调用setState()函数之后尝试去访问this.state，你得到的可能还是setState()函数执行之前的结果。 setState 在执行多次state 更新时会合并成一次更新，这时setState 会显示为异步函数 而有些浏览器 API 会造成 state 更新同步化 addEventListener setTimeout fetch 等 当setState() 函数执行的时候，函数会创建一个暂态的state作为过渡state，而不是立即修改this.state。 如果在调用setState()函数之后尝试去访问this.state，你得到的可能还是setState()函数执行之前的结果。 123456789101112131415161718192021222324252627class TestComponent extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; count: 0 &#125; &#125; componentDidMount() &#123; this.setState(&#123;count: this.state.count + 1&#125;) console.log(this.state.count) // 0 state 更新为异步 this.setState(&#123;count: this.state.count + 1&#125;) console.log(this.state.count) // 0 state 更新为异步 setTimeout(() =&gt; &#123; console.log(this.state.count) // 1 state 更新异步被合并, 只更新了一次 this.setState(&#123;count: this.state.count + 1&#125;) console.log(this.state.count) // 2 state 更新同步化 this.setState(&#123;count: this.state.count + 1&#125;) console.log(this.state.count) // 3 state 更新同步化 &#125;) &#125;&#125; 当和addEventListener, setTimeout 函数或者发出ajax call的时候，调用setState, state会发生改变。并且render函数会在setState()函数被触发之后马上被调用。 addEventListener setTimeout ajax call 在事件循环里都只是属于浏览器层面的 API ，这些 API 的回调函数将会在浏览器资源里执行完成再进入队列最后通过事件循环进入 script 里执行。 浏览器层面的API 的上下文环境已经不属于 React 中了，React 无法控制这些这些回调函数，无法合并他们导致的state 更新, 于是使用同步化策略及时更新，确保在这些函数执行之后的其他代码能拿到正确的数据 而在 JSX 中通过props 绑定 onClick 的事件则仍然是在 React 上下文中，React 仍然可以控制这类事件回调函数 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970class TestComponent extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; count: 0 &#125; &#125; componentDidMount() &#123; document.getElementById(&apos;button1&apos;).addEventListener(&apos;click&apos;, this.onClickHandler1); setTimeout(this.onTimeoutHandler, 10000); fetch(&apos;https://api.github.com/users&apos;) .then(this.onAjaxCallback); &#125; onClickHandler1 = () =&gt; &#123; console.log(&apos;State before (onClickHandler1): &apos; + JSON.stringify(this.state)); this.setState(&#123; count: this.state.count + 1 &#125;); console.log(&apos;State after (onClickHandler1): &apos; + JSON.stringify(this.state)); &#125; onClickHandler2 = () =&gt; &#123; console.log(&apos;State before (onClickHandler2): &apos; + JSON.stringify(this.state)); this.setState(&#123; count: this.state.count + 2 &#125;); console.log(&apos;State after (onClickHandler2): &apos; + JSON.stringify(this.state)); &#125; onTimeoutHandler = () =&gt; &#123; console.log(&apos;State before (timeout): &apos; + JSON.stringify(this.state)); this.setState(&#123; count: this.state.count + 3 &#125;); console.log(&apos;State after (timeout): &apos; + JSON.stringify(this.state)); &#125; onAjaxCallback = (err, res) =&gt; &#123; console.log(&apos;State before (AJAX call): &apos; + JSON.stringify(this.state)); this.setState(&#123; count: this.state.count + 4 &#125;); console.log(&apos;State after (AJAX call): &apos; + JSON.stringify(this.state)); &#125; render() &#123; console.log(&apos;State in render: &apos; + JSON.stringify(this.state)); return ( &lt;div&gt; &lt;button id=&quot;button1&quot; &gt; &apos;addEventListener&apos; &lt;/button&gt; &lt;button id=&quot;button2&quot; onClick=&#123;this.onClickHandler2&#125;&gt; &apos;props bind in jsx&apos; &lt;/button&gt; &lt;/div&gt; ); &#125;&#125;","categories":[{"name":"React","slug":"React","permalink":"http://yoursite.com/categories/React/"}],"tags":[{"name":"React Tips","slug":"React-Tips","permalink":"http://yoursite.com/tags/React-Tips/"}]},{"title":"学习并实现react4","slug":"学习并实现react4","date":"2018-03-16T08:30:41.000Z","updated":"2018-03-16T08:31:31.000Z","comments":true,"path":"2018/03/16/学习并实现react4/","link":"","permalink":"http://yoursite.com/2018/03/16/%E5%AD%A6%E4%B9%A0%E5%B9%B6%E5%AE%9E%E7%8E%B0react4/","excerpt":"","text":"实现生命周期生命周期介绍1234567componentWillMount // 组件挂载前componentDidMount // 组件挂载后componentWillReceiveProps // 组件props 变化时shouldComponentUpdate // (props / state) 变化时componentWillUpdate // 组件更新前componentDidUpdate // 组件更新后componentWillUnmount // 组件即将销毁 React 生命周期图 React 子组件在父组件下的生命周期流程 实现 componentWillMount, componentDidMount, componentDidUpdatecomponentWillMount在组件实例新建时执行 componentDidMount、componentDidUpdate相同点：组件render 执行完成后执行的不同点：新建的实例render 后执行componentDidMount， 已创建的实例组件再次render 则调用componentDidUpdate12345678910111213141516171819202122232425262728function render(vnode, parent, comp, olddomOrComp, myIndex) &#123; ... if (typeof vnode.type === &apos;function&apos;) &#123; let func = vnode.type let inst if (olddomOrComp &amp;&amp; olddomOrComp instanceof func) &#123; inst = olddomOrComp inst.props = vnode.props &#125; else &#123; inst = new func(vnode.props) // 新建组件实例执行 componentWillMount inst.componentWillMount &amp;&amp; inst.componentWillMount.call() if (comp) comp.__rendered = inst else parent.__rendered[myIndex] = inst // dom 渲染 &#125; let innerVNode = inst.render() render(innerVNode, parent, inst, inst.__rendered, myIndex) // render 后进行判断调用 componentDidUpdate componentDidMount if (olddomOrComp &amp;&amp; olddomOrComp instanceof func) &#123; inst.componentDidUpdate &amp;&amp; inst.componentDidUpdate.call() &#125; else &#123; inst.componentDidMount &amp;&amp; inst.componentDidMount.call() &#125; &#125;&#125; 实现 componentWillReceiveProps， shouldComponentUpdate， componentWillUpdatecomponentWillReceiveProps1234componentWillReceiveProps(nextProps) &#123; console.log(nextProps) // 变化后的 props console.log(this.props) // 变化前的 props&#125; componentWillReceiveProps 具有一个 nextProps 参数，表示改变后的新props，而在componentWillReceiveProps 内执行的 this.props 还是指向未改变的 oldProps1234567891011121314151617181920212223242526if (typeof vnode.type === &apos;function&apos;) &#123; let func = vnode.type let inst if (olddomOrComp &amp;&amp; olddomOrComp instanceof func) &#123; inst = olddomOrComp // 父组件改变时 inst.props 改变前 调用 componentWillReceiveProps inst.componentWillReceiveProps &amp;&amp; inst.componentWillReceiveProps(vnode.props) inst.props = vnode.props &#125; else &#123; inst = new func(vnode.props) inst.componentWillMount &amp;&amp; inst.componentWillMount.call() if (comp) comp.__rendered = inst else parent.__rendered[myIndex] = inst // dom 渲染 &#125; let innerVNode = inst.render() render(innerVNode, parent, inst, inst.__rendered, myIndex) if (olddomOrComp &amp;&amp; olddomOrComp instanceof func) &#123; inst.componentDidUpdate &amp;&amp; inst.componentDidUpdate.call() &#125; else &#123; inst.componentDidMount &amp;&amp; inst.componentDidMount.call() &#125;&#125; shouldComponentUpdate / componentWillUpdate1234shouldComponentUpdate(nextProps, nextState) &#123; return boolean&#125;componentWillUpdate(nextProps, nextState) &#123;&#125; 组件setState 或props 后决定组件是否更新，返回一个 true 或 false 通知组件是否执行 componentWillUpdate - render - componentDidUpdate, 组件不存在shouldComponentUpdate 则直接更新 componentWillUpdate 只有当shouldComponentUpdate 返回值是true 时才会调用 12345678910111213141516171819202122232425262728293031323334353637// render.js 父组件props 改变时 if (typeof vnode.type === &apos;function&apos;) &#123; let func = vnode.type let inst if (olddomOrComp &amp;&amp; olddomOrComp instanceof func) &#123; inst = olddomOrComp inst.componentWillReceiveProps &amp;&amp; inst.componentWillReceiveProps(vnode.props) let shouldUpdate // ture or false if (inst.shouldComponentUpdate) &#123; shouldUpdate = inst.shouldComponentUpdate(vnode.props, olddomOrComp.state) // 进行比较 &#125; else &#123; // 组件实例不存在shouldComponentUpdate 为true shouldUpdate = true &#125; // 这里调用componentWillUpdate shoudUpdate &amp;&amp; inst.componentWillUpdate &amp;&amp; inst.componentWillUpdate(inst.props, olddomOrComp.state) inst.props = vnode.props if (!shouldUpdate) return // 无需更新时阻止组件 render &#125; else &#123; inst = new func(vnode.props) inst.componentWillMount &amp;&amp; inst.componentWillMount.call() if (comp) comp.__rendered = inst else parent.__rendered[myIndex] = inst // dom 渲染 &#125; let innerVNode = inst.render() render(innerVNode, parent, inst, inst.__rendered, myIndex) if (olddomOrComp &amp;&amp; olddomOrComp instanceof func) &#123; inst.componentDidUpdate &amp;&amp; inst.componentDidUpdate.call() &#125; else &#123; inst.componentDidMount &amp;&amp; inst.componentDidMount.call() &#125; &#125; 123456789101112131415161718192021222324// component.js 当组件本身调用 setStateclass Component &#123; constructor(props) &#123; this.props = props &#125; setState(state) &#123; setTimeout(() =&gt; &#123; let shouldUpdate if (this.shouldComponentUpdate) &#123; // state 改变时 shouldUpdate = this.shouldComonentUpdate(this.props, state) &#125; else shouldUpdate = true this.state = state if (!shouldUpdate) return // 判断是否组织render const vnode = this.render() let olddom = getDOM(this) // 获取渲染此实例的 olddom const myIndex = getDOMIndex(olddom) render(vnode, olddom.parentNode, this.__rendered, myIndex) this.componentDidUpdate &amp;&amp; this.componentDidUpdate.call() // 最后执行componentDidUpdate &#125;, 0) &#125;&#125; componentWillUnmountcomponentWillUnmount 调用的场景1组件实例销毁时2组件实例不被复用时3包裹组件的dom 不被复用时 &lt;div&gt;&lt;Comp /&gt;&lt;/div&gt;12345678910111213function recoveryComp(comp) &#123; if (comp instanceof Component) &#123; comp.componentWillUnmount &amp;&amp; comp.componentWillUnmount.call() recoveryComp(comp.__rendered) &#125; else if (comp.__rendered instanceof Array) &#123; // 包裹的dom，&lt;div&gt; / &lt;span&gt; comp.__rendered.forEach(el =&gt; recoveryComp(el)) &#125; else return // 文本节点&#125;``` &gt; + recoveryComp 对传入的参数进行判断&gt; + 当为组件实例时调用 componentWillUnmount 然后递归调用 comp.__rendered&gt; + 当comp.__rendered 为数组时comp 为dom 节点，对__rendered 里的各元素进行 recoveryComp(el)&gt; + 最后如果是文本节点则不操作 function diffDOM(vnode, parent, comp, olddom) { const { onlyInLeft, onlyInRight, bothIn } = diffObject(vnode.props, olddom.__vnode.props) setAttrs(olddom, onlyInLeft) // 添加新属性 removeAttrs(olddom, onlyInRight) // 删除旧属性 diffAttrs(olddom, bothIn) // 比较且更新新旧属性的不同 const willRemoveArr = olddom.rendered.slice(vnode.children.length) // 将要删除的 dom const renderedArr = olddom.rendered.slice(0, vnode.children.length) olddom.__rendered = renderedArr for (let i = 0; i &lt; vnode.children.length; i++) { // 顺序固定，有缺点，原来是replaceChild，现在对dom 或 text 节点进行重新render _render(vnode.children[i], olddom, null, renderedArr[i], i) } willRemoveArr.forEach(el =&gt; { recoveryComp(el) // 当组件不被复用时进行 调用recoveryComp olddom.removeChild(getDOM(el)) }) olddom.__vnode = vnode // 不忘重新标记}123现在我们把生命周期都加入了。首次挂载到根节点时 // document.getElementById(‘app’) dom 节点也需要初始化__rendered 和 myIndexrender(, document.getElementById(‘app’))123456789```export function render(vnode, parent) &#123; parent.__rendered = [] // 为 document.getElementById(&apos;root&apos;) 初始化__rendered _render(vnode, parent, null, null, 0)&#125;function _render(vnode, parent, comp, olddomOrComp, myIndex) &#123; ...&#125;","categories":[{"name":"React","slug":"React","permalink":"http://yoursite.com/categories/React/"}],"tags":[{"name":"React","slug":"React","permalink":"http://yoursite.com/tags/React/"}]},{"title":"学习并实现react3","slug":"学习并实现react3","date":"2018-03-15T14:36:00.000Z","updated":"2018-03-15T14:37:22.000Z","comments":true,"path":"2018/03/15/学习并实现react3/","link":"","permalink":"http://yoursite.com/2018/03/15/%E5%AD%A6%E4%B9%A0%E5%B9%B6%E5%AE%9E%E7%8E%B0react3/","excerpt":"","text":"复用组件React 组件书写规则 组件可以直接渲染组件 组件渲染多个children 时需要用 dom 元素进行包裹 123456789101112131415161718192021222324252627class Parent extends Component &#123; render() &#123; return &lt;Child /&gt; &#125;&#125;class Child extends Component &#123; render() &#123; return ( &lt;div&gt; &lt;SubChild /&gt; &lt;SubChild /&gt; &lt;SubChild /&gt; &lt;/div&gt; ) &#125;&#125;class SubChild extends Component &#123; render() &#123; return ( &lt;div&gt; &lt;span&gt;SubChild&lt;/span&gt; &lt;/div&gt; ) &#125;&#125; 组件复用策略 每个组件渲染时都增加 __rendered 确定渲染元素的标记 对于渲染多个组件(children)时 children 为数组，__rendered 标记每个children 元素 __rendered 标记组件或dom 组件渲染树绝对不会出现下列情况 渲染多个组件(children)时 必须用 dom 元素包裹 最后正确渲染后的Tree 改造render 为了复用组件 render 第四个参数由 olddom 改为 olddomOrComp 12345678910111213141516171819202122232425262728293031function render(vnode, parent, comp, olddomOrComp) &#123; let dom if (typeof vnode === &apos;string&apos; || typeof vnode === &apos;number&apos;) &#123; // 文本节点直接渲染 if (olddomOrComp &amp;&amp; olddomOrComp.nodeType === 3) &#123; // 是一个文本节点 if (olddomOrComp.nodeValue !== vnode) olddomOrComp.nodeValue = vnode &#125; else &#123; dom = document.createTextNode(vnode) if (olddomOrComp) parent.replaceChild(dom, olddomOrComp) else parent.appendChild(dom) &#125; &#125; if (typeof vnode.type === &apos;string&apos;) &#123; // dom 节点 if (!olddomOrComp || olddomOrComp.nodeName !== vnode.type.toUpperCase()) &#123; createNewDom(vnode, parent, comp, olddomOrComp) &#125; else &#123; diffDOM(vnode, olddomOrComp) &#125; &#125; if (typeof vnode.type === &apos;function&apos;) &#123; let func = vnode.type let inst = new func(vnode.props) comp &amp;&amp; (comp.__rendered = inst) let innerVNode = inst.render() render(innerVNode, parent, inst, inst.__rendered) // 比较是否复用组件 &#125;&#125; 修改前olddom 参数可以判断是否复用，也可以判断replace(newdom, olddom) 的替换位置 当&lt;Parent /&gt; __rendered = &lt;Child1 /&gt; – setState变成 – &lt;Parent /&gt; __rendered = &lt;Child2 /&gt;, 而&lt;Child2 /&gt; 这个组件实例的inst.__rendered 应该是 undefined 原逻辑中 olddom 不存在时进行 appendChild 存在则进行replacechild 现在olddomOrComp 在替换组件时为 undefined 只会操作appendChild\b 为 render 函数增加第五个参数 myIndex 标识 dom 的位置 12345678function setNewDom(parent, newDom, myIndex) &#123; const old = parent.childNodes[myIndex] if (old) &#123; parent.replaceChild(newDom, old) &#125; else &#123; parent.appendChild(newDom) &#125;&#125; 123456789101112131415161718192021222324252627282930function render(vnode, parent, comp, olddomOrComp, myIndex) &#123; let dom if (typeof vnode === &apos;string&apos; || typeof vnode === &apos;number&apos;) &#123; // 文本节点直接渲染 if (olddomOrComp &amp;&amp; olddomOrComp.nodeType === 3) &#123; // 是一个文本节点 if (olddomOrComp.nodeValue !== vnode) olddomOrComp.nodeValue = vnode &#125; else &#123; dom = document.createTextNode(vnode) setNewDom(parent, dom, myIndex) // &#125; &#125; if (typeof vnode.type === &apos;string&apos;) &#123; // dom 节点 if (!olddomOrComp || olddomOrComp.nodeName !== vnode.type.toUpperCase()) &#123; createNewDom(vnode, parent, comp, olddomOrComp, myIndex) &#125; else &#123; diffDOM(vnode, parent, comp, olddomOrComp, myIndex) &#125; &#125; if (typeof vnode.type === &apos;function&apos;) &#123; let func = vnode.type let inst = new func(vnode.props) comp &amp;&amp; (comp.__rendered = inst) let innerVNode = inst.render() render(innerVNode, parent, inst, inst.__rendered, myIndex) &#125;&#125; 123456789101112131415161718192021function createNewDom(vnode, parent, comp, olddomOrComp, myIndex) &#123; ... setAttrs(dom, vnode.props) setNewDom(parent, dom, myIndex) // 创建时根据myIndex 决定是append / replace for(let i = 0; i &lt; vnode.children.length; i++) &#123; render(vnode.children[i], dom, null, null, i) // myIndex 其实就是 children 的 i &#125;&#125;function diffDOM(vnode, parent, comp, olddom) &#123; ... const willRemoveArr = olddom.__rendered.slice(vnode.children.length) // 将要删除的 dom const renderedArr = olddom.__rendered.slice(0, vnode.children.length) olddom.__rendered = renderedArr for(let i = 0; i &lt; vnode.children.length; i++) &#123; render(vnode.children[i], olddom, null, renderedArr[i], i) // 同样要增加 children 的 i &#125; ...&#125; 实现 __rendered 链123456789101112// __rendered 链场景class Child extends Component &#123; render() &#123; return ( &lt;div&gt; // 此处dom，__rendered 在这里应该为数组 &lt;SubChild 1/&gt; &lt;SubChild 2/&gt; &lt;SubChild 3/&gt; &lt;/div&gt; ) &#125;&#125; 现在 __rendered 标识组件实例后再标识到 dom 节点就结束了。 现在需要实现 div.__rendered 关联 SubChild 组件 确定rendered 链的思想，当渲染的是dom 元素时(组件被根dom包裹), rendered 为数组 1234567891011121314151617181920212223242526272829303132333435363738function render(vnode, parent, comp, olddomOrComp, myIndex) &#123; let dom if (typeof vnode === &apos;string&apos; || typeof vnode === &apos;number&apos;) &#123; // 文本节点直接渲染 if (olddomOrComp &amp;&amp; olddomOrComp.nodeType === 3) &#123; // 是一个文本节点 if (olddomOrComp.nodeValue !== vnode) olddomOrComp.nodeValue = vnode &#125; else &#123; dom = document.createTextNode(vnode) parent.__rendered[myIndex] = dom // comp 为 null 组件实例不会渲染文本节点 setNewDom(parent, dom, myIndex) &#125; &#125; if (typeof vnode.type === &apos;string&apos;) &#123; // dom 节点 if (!olddomOrComp || olddomOrComp.nodeName !== vnode.type.toUpperCase()) &#123; createNewDom(vnode, parent, comp, olddomOrComp, myIndex) &#125; else &#123; diffDOM(vnode, parent, comp, olddomOrComp) &#125; &#125; if (typeof vnode.type === &apos;function&apos;) &#123; let func = vnode.type let inst if (olddomOrComp &amp;&amp; olddomOrComp instanceof func) &#123; inst = olddomOrComp inst.props = vnode.props &#125; else &#123; inst = new func(vnode.props) if (comp) comp.__rendered = inst else parent.__rendered[myIndex] = inst // dom 渲染 &#125; let innerVNode = inst.render() render(innerVNode, parent, inst, inst.__rendered, myIndex) &#125;&#125; 1234567891011121314151617181920212223function setNewDom(parent, newDom, myIndex) &#123; const old = parent.childNodes[myIndex] if (old) parent.replaceChild(newDom, old) else parent.appendChild(newDom)&#125;function createNewDom(vnode, parent, comp, olddomOrComp, myIndex) &#123; let dom = document.createElement(vnode.type) dom.__rendered = [] // 创建dom 时 初始的 __rendered 未数组 dom.__vnode = vnode if (comp) comp.__rendered = dom else parent.__rendered[myIndex] = dom setAttrs(dom, vnode.props) setNewDom(parent, dom, myIndex) for (let i = 0; i &lt; vnode.children.length; i++) &#123; render(vnode.children[i], dom, null, null, i) // 标记位置 &#125;&#125; 1234567891011121314151617181920function diffDOM(vnode, parent, comp, olddom) &#123; const &#123; onlyInLeft, onlyInRight, bothIn &#125; = diffObject(vnode.props, olddom.__vnode.props) setAttrs(olddom, onlyInLeft) // 添加新属性 removeAttrs(olddom, onlyInRight) // 删除旧属性 diffAttrs(olddom, bothIn) // 比较且更新新旧属性的不同 // 比较__rendered 和children 删除多余的 const willRemoveArr = olddom.__rendered.slice(vnode.children.length) const renderedArr = olddom.__rendered.slice(0, vnode.children.length) olddom.__rendered = renderedArr for (let i = 0; i &lt; vnode.children.length; i++) &#123; // 顺序固定，有缺点，原来是replaceChild，现在对dom 或 text 节点进行重新render _render(vnode.children[i], olddom, null, renderedArr[i], i) &#125; willRemoveArr.forEach(el =&gt; olddom.removeChild(getDOM(el))) olddom.__vnode = vnode // 不忘重新标记&#125; 123456789101112131415161718192021222324class Component &#123; constructor(props) &#123; this.props = props &#125; setState(state) &#123; setTimeout(() =&gt; &#123; this.state = state const vnode = this.render() let olddom = getDOM(this) // 获取渲染此实例的 olddom const myIndex = getDOMIndex(olddom) const startTime = new Date().getTime() render(vnode, olddom.parentNode, this.__rendered, myIndex) // 传入此组件渲染的内容 console.log(&quot;duration for setState:&quot;, new Date().getTime() - startTime) &#125;, 0) &#125;&#125;function getDOMIndex(dom) &#123; const nodes = dom.parentNode.childNodes for (let i = 0; i &lt; nodes.length; i++) &#123; if (nodes[i] === dom) return i &#125;&#125; 最后再看下这张图，setState 后也会尝试复用组件，完善 __rendered 链","categories":[{"name":"React","slug":"React","permalink":"http://yoursite.com/categories/React/"}],"tags":[{"name":"React","slug":"React","permalink":"http://yoursite.com/tags/React/"}]},{"title":"学习并实现react2","slug":"学习并实现react2","date":"2018-03-13T13:09:05.000Z","updated":"2018-03-13T13:13:29.000Z","comments":true,"path":"2018/03/13/学习并实现react2/","link":"","permalink":"http://yoursite.com/2018/03/13/%E5%AD%A6%E4%B9%A0%E5%B9%B6%E5%AE%9E%E7%8E%B0react2/","excerpt":"","text":"组件列表渲染场景123456789101112131415161718192021222324252627// app.jsclass App extends Component &#123; constructor(props) &#123; super(props) this.state = &#123; number: 10000 &#125; &#125; render() &#123; const list = new Array(this.state.number).fill(&apos;item&apos;) return ( &lt;div width=&#123;100&#125;&gt; &lt;button onClick=&#123;e =&gt; &#123; this.setState(&#123; number: this.state.number &#125;) &#125;&#125;&gt;click me&lt;/button&gt; &#123;list.map((item, index) =&gt; &lt;div key=&#123;item + index&#125; style=&#123;listStyle&#125;&gt;&#123;`$&#123;item&#125;:$&#123;index&#125;`&#125;&lt;/div&gt;)&#125; &lt;/div&gt; ) &#125;&#125;const startTime = new Date().getTime()render(&lt;App /&gt;, document.getElementById(&apos;app&apos;))console.log(&quot;duration for render:&quot;, new Date().getTime() - startTime) 1234567891011// component.js setState(state) &#123; setTimeout(() =&gt; &#123; this.state = state const vnode = this.render() let olddom = getDOM(this) // 获取渲染此实例的 olddom const startTime = new Date().getTime() render(vnode, olddom.parentNode, this, olddom) console.log(&quot;duration for setState:&quot;, new Date().getTime() - startTime) &#125;, 0) &#125; 在这里组件首次渲染(render)和更新状态(setState)后都将渲染10000 条列表, 用时平局150ms \bDOM复用 react 的重点在于首次渲染和更新渲染，现在考虑更新渲染如何复用DOM 让渲染更有效率. 分析更新前后的 vnode 结构1234567891011121314151617181920212223242526const beforeVnode = &#123; tagName: &apos;div&apos;, props: &#123; width: &apos;20px&apos;, className: &apos;before&apos; &#125;, chilren: [child1, child2]&#125;const afterVnode1 = &#123; tagName: &apos;div&apos;, props: &#123; width: &apos;30px&apos;, className: &apos;after1&apos; &#125;, children:[child1, child2, child3]&#125;const afterVnode2 = &#123; tagName: &apos;span&apos;, props: &#123; width: &apos;20px&apos;, className: &apos;after2&apos; &#125;, children:[child1, child2]&#125; beforeVnode vs afterVnode1: tagName 仍然是 div ，只改变了props 和childrenbeforeVnode vs afterVnode2: tagName 由 div -&gt; span 更新原则: dom 节点不变则更新 props 属性，复用 children dom 节点改变则创建新节点 更改 render 函数 render 函数复用 DOM 的情况只存在于文本节点及 DOM 节点 更改前文本节点与 DOM 节点在首次渲染及更新都是 create 或 replace 一个新的节点 1234567891011121314151617181920212223242526// code1/render.jsfunction render(vnode, parent, comp, olddom) &#123; let dom if (typeof vnode === &apos;string&apos;) &#123; // 文本节点直接渲染 dom = document.createTextNode(vnode) comp &amp;&amp; (comp.__rendered = dom) if (olddom) parent.replaceChild(dom, olddom) else parent.appendChild(dom) &#125; if (typeof vnode.type === &apos;string&apos;) &#123; // dom 节点 dom = document.createElement(vnode.type) comp &amp;&amp; (comp.__rendered = dom) setAttrs(dom, vnode.props) // props 已经被createElement 解析成对象 if (olddom) parent.replaceChild(dom, olddom) else parent.appendChild(dom) for(let i = 0; i &lt; vnode.children.length; i++) &#123; render(vnode.children[i], dom, null, null) // 递归 render children &#125; &#125; ...&#125; 文本节点我们增加了一个对olddom value 的比较 标签节点的渲染逻辑分为首次渲染的 createNewDom 和更新的 diffDOM 1234567891011121314151617181920212223// code2/render.jsfunction render(vnode, parent, comp, olddom) &#123; let dom if (typeof vnode === &apos;string&apos; || typeof vnode === &apos;number&apos;) &#123; // 文本节点直接渲染 if (olddom &amp;&amp; olddom.nodeType === 3) &#123; // 是一个文本节点 if (olddom.nodeValue !== vnode) olddom.nodeValue = vnode &#125; else &#123; dom = document.createTextNode(vnode) if (olddom) parent.replaceChild(dom, olddom) else parent.appendChild(dom) &#125; &#125; if (typeof vnode.type === &apos;string&apos;) &#123; // dom 节点 if (!olddom || olddom.nodeName !== vnode.type.toUpperCase()) &#123; createNewDom(vnode, parent, comp, olddom) &#125; else &#123; diffDOM(vnode, parent, comp, olddom) &#125; &#125; ...&#125; createNewDom 抽离 DOM 节点首次渲染方法，首次渲染为每个节点添加 vnode 标记。 12345678910111213function createNewDom(vnode, parent, comp) &#123; let dom = document.createElement(vnode.type) dom.__vnode = vnode // 为 DOM 节点对象增加 vnode 标记，diffDOM 时会用到 comp &amp;&amp; (comp.__rendered = dom) setAttrs(dom, vnode.props) parent.appendChild(dom) for (let i = 0; i &lt; vnode.children.length; i++) &#123; render(vnode.children[i], dom, null, null) &#125;&#125; diffDOM 设计思路 diffObject \b比较新旧vnode 的属性 然后通过新旧vnode 的差异更改 olddom 的属性 比较新children 与olddom 的子节点进行递归渲染 最后记得删除 olddom 123456789101112131415161718192021222324252627/** * * @param vnode &#123;object&#125; 即将更新的vnode * @param olddom &#123;HTMLElement&#125; * __vnode (object) 渲染olddom 的vnode 标记 */function diffDOM(vnode, olddom) &#123; const &#123; onlyInLeft, onlyInRight, bothIn &#125; = diffObject(vnode.props, olddom.__vnode.props) setAttrs(olddom, onlyInLeft) // 添加新属性 removeAttrs(olddom, onlyInRight) // 删除旧属性 diffAttrs(olddom, bothIn) // 比较且更新新旧属性的不同 let olddomChild = olddom.firstChild for (let i = 0; i &lt; vnode.children.length; i++) &#123; // 顺序固定，有缺点，原来是replaceChild，现在对dom 或 text 节点进行重新render render(vnode.children[i], olddom, null, olddomChild) olddomChild = olddomChild &amp;&amp; olddomChild.nextSibling &#125; while (olddomChild) &#123; // 递归后删除所有 olddom let next = olddomChild.nextSibling olddom.removeChild(olddomChild) olddomChild = next &#125; olddom.__vnode = vnode&#125; 1234567891011121314151617181920212223242526272829303132333435/** * * @param leftProps &#123;object&#125; newProps * @param rightProps &#123;object&#125; oldProps */function diffObject(leftProps, rightProps) &#123; const onlyInLeft = &#123;&#125;, // 只存在于left onlyInRight = &#123;&#125;, // 只存在于right bothLeft = &#123;&#125;, // 两者都有 bothRight = &#123;&#125; // 两者都有 for (let key in leftProps) &#123; if (!rightProps[key]) &#123; onlyInLeft[key] = leftProps[key] &#125; else &#123; bothLeft[key] = leftProps[key] bothRight[key] = rightProps[key] &#125; &#125; for (let key in rightProps) &#123; if (!leftProps[key]) &#123; onlyInRight[key] = rightProps[key] &#125; &#125; return &#123; onlyInRight, onlyInLeft, bothIn: &#123; left: bothLeft, right: bothRight &#125; &#125;&#125; 12345678910111213141516171819202122232425262728function setAttrs(dom, props) &#123; Object.keys(props).forEach(k =&gt; &#123; const v = props[k] if (k === &apos;className&apos;) &#123; dom.setAttribute(&apos;class&apos;, v) return &#125; if (k === &apos;style&apos;) &#123; if (typeof v === &apos;string&apos;) dom.style.cssText = v if (typeof v === &apos;object&apos;) &#123; for (let i in v) &#123; dom.style[i] = v[i] &#125; &#125; return &#125; if (k[0] === &apos;o&apos; &amp;&amp; k[1] === &apos;n&apos;) &#123; // onClick of onClickCapture const capture = k.indexOf(&apos;Capture&apos;) !== -1 dom.addEventListener(k.replace(&apos;Capture&apos;, &apos;&apos;).substring(2).toLowerCase(), v, capture) return &#125; dom.setAttribute(k, v) &#125;)&#125; 1234567891011121314151617181920212223function removeAttrs(dom, props) &#123; Object.keys(props).forEach(k =&gt; &#123; const v = props[k] if (k === &apos;className&apos;) &#123; dom.removeAttribute(&apos;class&apos;, v) return &#125; if (k === &apos;style&apos;) &#123; dom.style.cssText = &apos;&apos; return &#125; if (k[0] === &apos;o&apos; &amp;&amp; k[1] === &apos;n&apos;) &#123; // onClick of onClickCapture const capture = k.indexOf(&apos;Capture&apos;) !== -1 dom.removeEventListener(k.replace(&apos;Capture&apos;, &apos;&apos;).substring(2).toLowerCase(), v, capture) return &#125; dom.removeAttribute(k) &#125;)&#125; 123456789101112131415161718192021222324252627282930313233343536373839function diffAttrs(dom, &#123; left: newProps, right: oldProps &#125;) &#123; Object.keys(newProps).forEach(k =&gt; &#123; let nv = newProps[k] // newValue let ov = oldProps[k] // oldValue if (nv === ov) return if (k === &apos;className&apos;) &#123; dom.setAttribute(&apos;class&apos;, nv) return &#125; if (k === &apos;style&apos;) &#123; if (typeof nv === &apos;string&apos;) &#123; dom.style.cssText = nv &#125; else if (typeof nv === &apos;object&apos; &amp;&amp; typeof ov === &apos;object&apos;) &#123; Object.keys(nv).forEach(nk =&gt; &#123; if (nv[nk] !== ov[nk]) dom.style[nk] = nv[nk] &#125;) Object.keys(ov).forEach(ok =&gt; &#123; if (!nv[ok]) dom.style[ok] = &apos;&apos; &#125;) &#125; else if (typeof nv === &apos;object&apos; &amp;&amp; typeof ov === &apos;string&apos;) &#123; dom.style = &#123;&#125; Object.keys(nv).forEach(nk =&gt; dom.style[nk] = nv[nk]) &#125; return &#125; if (k[0] === &apos;o&apos; &amp;&amp; k[1] === &apos;n&apos;) &#123; const capture = k.indexOf(&apos;Capture&apos;) !== -1 const eventKey = k.replace(&apos;Capture&apos;, &apos;&apos;).substring(2).toLowerCase() dom.removeEventListener(eventKey, ov, capture) dom.addEventListener(eventKey, nv, capture) return &#125; dom.setAttribute(k, nv) &#125;)&#125; 通过diffDOM 实现了复用 DOM 节点，更新渲染的速度更快。不过这里没实现react 的key 值比较，children 的属性依赖 olddom 的顺序。","categories":[{"name":"React","slug":"React","permalink":"http://yoursite.com/categories/React/"}],"tags":[{"name":"React","slug":"React","permalink":"http://yoursite.com/tags/React/"}]},{"title":"学习并实现react1","slug":"学习并实现react1","date":"2018-03-09T10:37:23.000Z","updated":"2018-03-09T10:40:55.000Z","comments":true,"path":"2018/03/09/学习并实现react1/","link":"","permalink":"http://yoursite.com/2018/03/09/%E5%AD%A6%E4%B9%A0%E5%B9%B6%E5%AE%9E%E7%8E%B0react1/","excerpt":"","text":"搭建学习环境1npm install -g parcel-bundler package.json123456789101112131415161718192021&#123; &quot;name&quot;: &quot;myReact&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;&quot;, &quot;main&quot;: &quot;index.js&quot;, &quot;scripts&quot;: &#123; &quot;start&quot;: &quot;parcel index.html&quot;, &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot; &#125;, &quot;keywords&quot;: [], &quot;author&quot;: &quot;&quot;, &quot;license&quot;: &quot;ISC&quot;, &quot;dependencies&quot;: &#123; &quot;babel-preset-env&quot;: &quot;^1.6.1&quot;, &quot;babel-preset-es2015&quot;: &quot;^6.24.1&quot;, &quot;parcel-bundler&quot;: &quot;^1.6.2&quot; &#125;, &quot;devDependencies&quot;: &#123; &quot;babel-plugin-transform-react-jsx&quot;: &quot;^6.24.1&quot; &#125;&#125; 支持 JSX在 js 文件中我们是不能写 jsx 语法的，必须使用一种 babel 插件 transform-react-jsx 才能使用。\b新建.babelrc12345678&#123; &quot;presets&quot;: [&quot;env&quot;], &quot;plugins&quot;: [ [&quot;transform-react-jsx&quot;, &#123; &quot;pragma&quot;: &quot;createElement&quot; &#125;] ]&#125; 这样我们在写React 组件时 babel 会帮我们自动编译成 实现一个 createElement.babelrc 文件中使用了transform-react-jsx 插件，告诉babel 解析 jsx 需要 createElement方法，也就是 babel 编译后的React.createElement createElement 有三个参数12345678910111213function createElement(type, props, ...args) &#123; props = props || &#123;&#125; let children = [] for (let i = 0; i &lt; args.length; i++) &#123; if (Array.isArray(args[i])) &#123; children = [ ...children, ...args[i] ] &#125; else &#123; children = [ ...children, args[i] ] &#125; &#125; return &#123; type, props, children &#125;&#125; 然后我们来试验下createElement 结果12345678910111213141516171819import &#123; createElement &#125; from &apos;./src/react&apos;const React = &#123;&#125;React.createElement = createElementReact.Component = class Component &#123;&#125;class App extends React.Component &#123; render() &#123; return ( &lt;div&gt; &lt;span&gt;App&lt;/span&gt; &lt;span&gt;component&lt;/span&gt; &lt;/div&gt; ) &#125;&#125;const app = new App().render()console.log(app) new App().render() 这种格式跟 react 组件区别有些大，再实现一个renderVDOM(&lt;App /&gt;) 的格式1234567891011121314151617181920function reactVDOM(vnode) &#123; if (typeof vnode === &apos;string&apos;) return vnode // 文本节点 if (typeof vnode.type === &apos;string&apos;) &#123; // type 为标签名 - dom节点 let ret = &#123; type: ret.type, props: ret.props, children: [] &#125; for (let i = 0; i &lt; vnode.children.length; i++) &#123; ret.children.push(reactVDOM(vnode.children[i])) // 递归children &#125; return ret &#125; if (typeof vnode.type === &apos;function&apos;) &#123; // type 为 class 组件 let func = vnode.type let inst = new func(vnode.props) // 把 props 传入 let innerVNODE = inst.render() return reactVDOM(innerVNODE) // 递归渲染后的组件 &#125;&#125; 1234567891011121314151617181920import &#123; createElement &#125; from &apos;./src/react&apos;import &#123; renderVDOM &#125; from &apos;./src/renderVDOM&apos;const React = &#123;&#125;React.createElement = createElementReact.Component = class Component &#123;&#125;class App extends React.Component &#123; render() &#123; return ( &lt;div&gt; &lt;span&gt;App&lt;/span&gt; &lt;span&gt;component&lt;/span&gt; &lt;/div&gt; ) &#125;&#125;const app = renderVDOM(&lt;App /&gt;)console.log(app) // 与 new App().render() 一样 父子组件12345678910111213141516171819202122232425262728293031323334class ChildrenChild extends React.Component &#123; render() &#123; return ( &lt;div&gt; children-child &lt;/div&gt; ) &#125;&#125;class Children extends React.Component &#123; render() &#123; return ( &lt;div&gt; children &lt;ChildrenChild /&gt; &lt;/div&gt; ) &#125;&#125;class App extends React.Component &#123; render() &#123; return ( &lt;div&gt; &lt;span&gt;App&lt;/span&gt; &lt;span&gt;component&lt;/span&gt; &lt;Children /&gt; &lt;/div&gt; ) &#125;&#125;const app = renderVDOM(&lt;App /&gt;) 结果中组件的文本内容、dom、组件实例都在children 数组里，React.render 时只需要识别这些children 就可以做到真实渲染 实现 render改写 renderVDMO 加入真实 dom 操作123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354function render(vnode, parent) &#123; let dom if (typeof vnode === &apos;string&apos;) &#123; // 文本节点直接渲染 dom = document.createTextNode(vnode) parent.appendChild(dom) &#125; if (typeof vnode.type === &apos;string&apos;) &#123; // dom 节点 dom = document.createElement(vnode.type) setAttrs(dom, vnode.props) // props 已经被createElement 解析成对象 parent.appendChild(dom) for(let i = 0; i &lt; vnode.children.length; i++) &#123; render(vnode.children[i], dom) // 递归 render children &#125; &#125; if (typeof vnode.type === &apos;function&apos;) &#123; // class 组件 let func = vnode.type let inst = new func(vnode.props) // props 已经被createElement 解析成对象 let innerVNode = inst.render() render(innerVNode, parent) &#125;&#125;function setAttrs(dom, props) &#123; Object.keys(props).forEach(k =&gt; &#123; const v = props[k] if (k === &apos;className&apos;) &#123; dom.setAttribute(&apos;class&apos;, v) return &#125; if (k === &apos;style&apos;) &#123; if (typeof v === &apos;string&apos;) dom.style.cssText = v if (typeof v === &apos;object&apos;) &#123; for (let i in v) &#123; dom.style[i] = v[i] &#125; &#125; return &#125; if (k[0] === &apos;o&apos; &amp;&amp; k[1] === &apos;n&apos;) &#123; // onClick of onClickCapture const capture = k.indexOf(&apos;Capture&apos;) !== -1 dom.addEventListener(k.replace(&apos;Capture&apos;, &apos;&apos;).substring(2).toLowerCase(), v, capture) return &#125; dom.setAttribute(k, v) &#125;)&#125; 把上面例子换一下1234567891011121314151617181920212223242526272829303132333435363738394041// app.jsclass ChildrenChild extends React.Component &#123; render() &#123; return ( &lt;div&gt; children-child &lt;/div&gt; ) &#125;&#125;class Children extends React.Component &#123; render() &#123; return ( &lt;div&gt; children &lt;ChildrenChild /&gt; &lt;/div&gt; ) &#125;&#125;class App extends React.Component &#123; render() &#123; return ( &lt;div&gt; &lt;span&gt;App&lt;/span&gt; &lt;span&gt;component&lt;/span&gt; &lt;Children /&gt; &lt;/div&gt; ) &#125;&#125;render(&lt;App /&gt;, document.getElementById(&apos;app&apos;))// index.html&lt;body&gt; &lt;div id=&quot;app&quot;&gt;&lt;/div&gt; &lt;script src=&quot;./app.js&quot;&gt;&lt;/script&gt;&lt;/body&gt; 实现props 和state12345678910111213141516171819202122232425262728293031class Color extends React.Component &#123; render() &#123; return ( &lt;div style=&#123;&#123; color: this.props.color &#125;&#125;&gt;color is: &#123;this.props.color&#125;&lt;/div&gt; ) &#125;&#125;const colorArr = [&apos;red&apos;, &apos;blue&apos;, &apos;black&apos;, &apos;green&apos;, &apos;gray&apos;]class App extends React.Component &#123; constructor(props) &#123; super(props) this.state = &#123; color: &apos;black&apos; &#125; &#125; handleClick() &#123; console.log(&quot;handleClick&quot;) this.setState(&#123; color: colorArr[Math.random() * 5 | 0] &#125;) &#125; render() &#123; return ( &lt;div onClick=&#123;this.handleClick.bind(this)&#125;&gt; &lt;Color color=&#123;this.state.color&#125; /&gt; &lt;/div&gt; ) &#125;&#125;render(&lt;App /&gt;, document.getElementById(&apos;app&apos;)) 目的: 我们要通过点击 App 组件中的元素来改变 Color 文字的颜色步骤: 把新的state 传入 this.setState 来更新组件 - 调用render 方法 setState123456789101112export default class Component &#123; constructor(props) &#123; this.props = props &#125; setState(state) &#123; setTimeout(() =&gt; &#123; this.state = state // ...render() &#125;) &#125;&#125; 回忆 render 函数有两个参数，vnode， parent，vnode 我们可以使用 this.render() 获取当前组件，但我们要知道需要更新dom 内容的 parent 就需要在首次render 时记录。 改写 render给render 增加参数，comp(当前更新组件)， olddom(当前组件曾经的dom)拿首次渲染举例: parent - document.getElementById(&#39;app&#39;), comp - &lt;App /&gt;, olddom - 当App组件更新时就是App 首次渲染的dom12345678910111213141516171819202122232425262728293031323334export function render(vnode, parent, comp, olddom) &#123; let dom if (typeof vnode === &apos;string&apos;) &#123; // 文本节点直接渲染 dom = document.createTextNode(vnode) comp &amp;&amp; (comp.__rendered = dom) if (olddom) parent.replaceChild(dom, olddom) else parent.appendChild(dom) &#125; if (typeof vnode.type === &apos;string&apos;) &#123; // dom 节点 dom = document.createElement(vnode.type) comp &amp;&amp; (comp.__rendered = dom) setAttrs(dom, vnode.props) // props 已经被createElement 解析成对象 if (olddom) parent.replaceChild(dom, olddom) else parent.appendChild(dom) for(let i = 0; i &lt; vnode.children.length; i++) &#123; render(vnode.children[i], dom, null, null) // 递归 render children &#125; &#125; if (typeof vnode.type === &apos;function&apos;) &#123; // class 组件 let func = vnode.type let inst = new func(vnode.props) // props 已经被createElement 解析成对象 comp &amp;&amp; (comp.__rendered = inst) // 这里记录的是 Component 实例 let innerVNode = inst.render() render(innerVNode, parent, inst, olddom) &#125;&#125; 在这里我们每次render 的时候都会判断这次render 是否是class 组件触发的render，如果是组件触发的render 我们就会在这个组件comp 上增加 __rendered 记录当前渲染的 dom 或 当前渲染的组件 (组件追溯到顶层也是dom) ，这时候我们需要一个方法来获得olddom1234567function getDOM (comp) &#123; let rendered = comp.__rendered while (rendered instanceof Component) &#123; rendered = rendered.__rendered &#125; return rendered&#125; 实现 setState1234567891011121314151617import &#123; getDOM &#125; from &apos;./util&apos;import &#123; render &#125; from &apos;./render&apos;export default class Component &#123; constructor(props) &#123; this.props = props &#125; setState(state) &#123; setTimeout(() =&gt; &#123; this.state = state const vnode = this.render() let olddom = getDOM(this) // 获取渲染此实例的 olddom render(vnode, olddom.parentNode, this, olddom) &#125;) &#125;&#125; 实现效果123456789101112131415161718192021222324252627282930313233343536373839import &#123; render, createElement, Component &#125; from &apos;./src/code1/react&apos;const React = &#123;&#125;React.createElement = createElementReact.Component = Componentclass Color extends React.Component &#123; render() &#123; return ( &lt;div style=&#123;&#123; color: this.props.color &#125;&#125;&gt;color is: &#123;this.props.color&#125;&lt;/div&gt; ) &#125;&#125;const colorArr = [&apos;red&apos;, &apos;blue&apos;, &apos;black&apos;, &apos;green&apos;, &apos;gray&apos;]class App extends React.Component &#123; constructor(props) &#123; super(props) this.state = &#123; color: &apos;black&apos; &#125; &#125; handleClick() &#123; console.log(&quot;handleClick&quot;) this.setState(&#123; color: colorArr[Math.random() * 5 | 0] &#125;) &#125; render() &#123; return ( &lt;div onClick=&#123;this.handleClick.bind(this)&#125;&gt; &lt;Color color=&#123;this.state.color&#125; /&gt; &lt;/div&gt; ) &#125;&#125;render(&lt;App /&gt;, document.getElementById(&apos;app&apos;))","categories":[{"name":"React","slug":"React","permalink":"http://yoursite.com/categories/React/"}],"tags":[{"name":"React","slug":"React","permalink":"http://yoursite.com/tags/React/"}]},{"title":"前端基础重点回顾6:渲染机制、页面性能优化、错误监控","slug":"前端基础重点回顾6-渲染机制、页面性能优化、错误监控","date":"2018-02-05T12:26:55.000Z","updated":"2018-02-05T12:27:23.000Z","comments":true,"path":"2018/02/05/前端基础重点回顾6-渲染机制、页面性能优化、错误监控/","link":"","permalink":"http://yoursite.com/2018/02/05/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E9%87%8D%E7%82%B9%E5%9B%9E%E9%A1%BE6-%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6%E3%80%81%E9%A1%B5%E9%9D%A2%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E3%80%81%E9%94%99%E8%AF%AF%E7%9B%91%E6%8E%A7/","excerpt":"","text":"渲染机制DOCTYPE DOCTYPE是用来声明文档类型的，告诉浏览器使用哪一种DTD规范的文档类型。 DTD(document type definition, 文档类型定义) 是一些列的语法规则，用来定义HTML文件类型。用来给浏览器判断文档类型。 声明文档类型 HTML5 &lt;!DOCTYPE html&gt; HTML 4.01 有宽松模式和严格模式(不包括展示性和弃用的元素) 浏览器渲染过程 HTML通过HTML解析转化成DOM树 Style样式通过CSS解析转化成Style规则 DOM树和Style规则结合成渲染树(Render Tree) 然后渲染树通过layout 计算出各元素在浏览器上的宽高颜色位置等属性，最后在浏览器上进行绘制。 重排Reflow DOM元素的盒模型需要浏览器根据样式计算结果将他们绘制在页面上，这个过程就是reflow 触发Reflow 条件 增加、删除、修改DOM节点时，会触发Reflow 或 Repaint 移动DOM节点、动画 修改CSS样式 resize 窗口、滚动页面 修改页面默认字体 重绘Repaint 当DOM元素盒模型的各种属性确定计算结果后，浏览器根据这些元素的样式属性绘制一遍出现在页面上的过程就是repaint 触发Repaint DOM改动 CSS改动 减少Reflow Repaint的开销 DOM拼接后一次append 到页面上(列表) 页面性能优化打开浏览器，在地址栏输入 url 直到页面展现，整个过程发生了什么？ DNS(Domain Name System)域名系统预解析(应用层)，输入url后,浏览器会进行DNS解析出, 对应服务器的ip地址. 浏览器会将用户输入的请求信息打包发送给nginx服务器. 服务器会分析用户的请求寻找处理请求的对应文件，发送给浏览器. 最后浏览器接收服务器的响应,解析并渲染呈现给用户。 提升页面性能的方法有哪些？ 资源压缩合并，减少HTTP请求 非核心代码异步加载 利用浏览器缓存 使用CDN 预解析DNS 非核心代码异步加载 动态脚本加载动态创建&lt;script&gt;标签添加到html 文档中内 &lt;script&gt; 标签的defer 属性在html 文档解析完执行，按加载顺序依次执行 &lt;script&gt; 标签的async 属性在html 文档解析完执行，加载顺序与执行顺序无关 利用浏览器缓存 强缓存:客户端无需再次请求服务端，客户端直接根据缓存条件决定是否使用缓存资源 响应header 描述 常用响应返回内容 推荐 特点 缺点 场景 Cache-Control 在多少秒内进行缓存 public, max-age=秒 是 固定时间 客户端服务端时间可能不一致 Expires 在此时间前进行缓存 格林威治时间 否 绝对时间 客户端服务端时间可能不一致 兼容http1.0 协商缓存:客户端需请求服务端进行比较缓存条件，符合条件则返回304使用缓存资源 响应header 请求header 描述 常用响应返回内容 推荐 特点 缺点 场景 ETag If-None-Match 固定字符串 md5 hash值 是 检测文件完整性 Last-Modified If-Modified-Since 在某时间后没再更改 格林威治时间 否 浏览器根据返回的时间自己决定缓存 浏览器差异 DNS 预解析123// 强制打开a 标签的DNS 预解析，https 默认关闭a 标签的DNS 预解析&lt;meta http-equiv=&quot;x-dns-prefetch-control&quot; content=&quot;on&quot;&gt;&lt;link rel=&quot;dns-prefatch&quot; href=&quot;url&quot;&gt; 前端错误监控 保证产品质量 即时运行错误(代码错误)收集 资源加载错误收集 即时运行错误的捕获方式123456// 代码块使用错误捕获try &#123;&#125; catch (e) &#123;&#125;// 使用window对象错误事件捕获window.onerror = function(e) &#123;&#125;window.addEventListener(&apos;error&apos;, function(e) &#123;&#125;) 资源加载错误&lt;img&gt;等资源加载错误不会冒泡，window.onerror 无法捕获到标签资源加载的错误 \bdom 捕获 123elScript.onerror = function (e)&#123;&#125;elImg.onerror = function (e)&#123;&#125;... 跨域js 错误捕获 js 文件资源响应头设置Access-Control-Allow-Origin: * script 标签增加crossorigin 属性&lt;script crossorigin src=&#39;url&#39;&gt;&lt;/script&gt; 获取成功加载的资源 12performance.getEntries()performance.getEntries().map(item =&gt; item.name) // 获取所有成功资源加载地址 通过Error 事件捕获 1234window.addEventListener(&apos;error&apos;, function(e) &#123; console.log(&apos;捕获&apos;, e) // 将会捕获到资源加载错误&#125;, true)&lt;script src=&apos;错误url&apos;&gt;&lt;/script&gt; 上报错误的基本原理 采用Ajax 通信方式上报 利用Image 对象上报 123&lt;script&gt; new Image().src = &apos;url?k=val&apos; // 会发送一个请求用于上报&lt;/script&gt; 参考","categories":[{"name":"Font-End Basis","slug":"Font-End-Basis","permalink":"http://yoursite.com/categories/Font-End-Basis/"}],"tags":[]},{"title":"前端基础重点回顾5:XSS、CSRF攻击","slug":"前端基础重点回顾5-XSS、CSRF攻击","date":"2018-01-31T09:01:53.000Z","updated":"2018-01-31T09:19:51.000Z","comments":true,"path":"2018/01/31/前端基础重点回顾5-XSS、CSRF攻击/","link":"","permalink":"http://yoursite.com/2018/01/31/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E9%87%8D%E7%82%B9%E5%9B%9E%E9%A1%BE5-XSS%E3%80%81CSRF%E6%94%BB%E5%87%BB/","excerpt":"","text":"XSS攻击前提 攻击脚本必须添加到页面上 攻击方式 跨站脚本XSS(Cross site script) 代码注入 script 标签注入攻击 &lt;li&gt;&lt;script&gt;alert(1)&lt;/script&gt;&lt;/li&gt; 标签属性注入攻击 &lt;img src=&quot;&quot; onerror=&quot;alert(1)&quot;&gt; &lt;p onclick=&quot;alert(2)&quot;&gt;诱导点击&lt;/p&gt; 广告注入 &lt;iframe src=&#39;&#39;&gt;&lt;/iframe&gt; 防止XSS攻击 获取的数据不允许进行字符串拼接 使用element.inneText方法 把数据添加到dom 中，inneText 方法会转义所有内容 把所有数据里的/[&quot;&#39;&amp;&lt;&gt;]/使用正则进行转义 存储数据时过滤并转义/[&quot;&#39;&amp;&lt;&gt;]/ 防止URL 上的参数在页面上展示 http://url?code=&lt;p onclick=&quot;alert(2)&quot;&gt;诱导点击&lt;/p&gt; 这里的code query参数内容不得在页面中渲染 CSRF 攻击原理 利用用户已经登录的状态 伪造请求发送给服务器进行用户操作 攻击方式 跨站请求伪造(Cross site request forgery) 用户已登录(cookie登录)如果没设置httpOnly cookie是根据域名和路径访问的, 无关端口 伪造请求(GET, POST)123伪造GET&lt;img src=&quot;http://localhost:3000/csrf?data=111&quot; alt=&quot;&quot;&gt;http://localhost:3000/csrf?data=111 // 直接地址栏中输入 1234567891011表单伪造POST &lt;form id=&quot;form&quot; style=&quot;display: none;&quot; action=&quot;http://localhost:3000/csrf?data=111&quot; method=&quot;post&quot; target=&quot;csrf&quot;&gt; &lt;/form&gt; &lt;input id=&quot;btn&quot; type=&quot;button&quot; value=&quot;submit&quot;&gt; &lt;iframe src=&quot;&quot; style=&quot;display: none;&quot; name=&quot;csrf&quot; frameborder=&quot;0&quot;&gt;&lt;/iframe&gt; &lt;script&gt; btn.addEventListener(&apos;click&apos;, (e) =&gt; &#123; e.preventDefault() form.submit() &#125;) &lt;/script&gt; 防止CSRF攻击 请求时不仅浏览器携带cookie， 请求参数也需要把跟cookie 相关的值携带到参数中, 伪造的请求无法获取正确网站cookie的值, 比如常见约定的csrfToken 使用Authorization 的token 授权 提交表单的时候增加token 认证 验证请求header 的Referer 携带请求来源信息","categories":[{"name":"Font-End Basis","slug":"Font-End-Basis","permalink":"http://yoursite.com/categories/Font-End-Basis/"}],"tags":[{"name":"http","slug":"http","permalink":"http://yoursite.com/tags/http/"}]},{"title":"前端基础重点回顾4:前后端通信","slug":"前端基础重点回顾4-前后端通信","date":"2018-01-30T05:16:50.000Z","updated":"2018-01-31T09:02:46.000Z","comments":true,"path":"2018/01/30/前端基础重点回顾4-前后端通信/","link":"","permalink":"http://yoursite.com/2018/01/30/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E9%87%8D%E7%82%B9%E5%9B%9E%E9%A1%BE4-%E5%89%8D%E5%90%8E%E7%AB%AF%E9%80%9A%E4%BF%A1/","excerpt":"","text":"同源策略及限制同源策略的概念 同源:http协议，域名， 端口三者均相同 同源策略是用来限制在一个源上加载的文档或脚本与来自另一个源的资源进行交互。这是一个用于隔离潜在恶意文件的关键的安全机制。 同源策略的限制 cookie localStorage indexDB 无法读取 dom 无法获得 ajax请求不能发送 前后端通信的常见几种方式 Ajax(同源通信) WebSocket(协议不同的不同源通信) CORS(用于支持不同源之间ajax通信的方法) Ajax通信参考 Ajax 概念 Ajax(Async JavaScript And XML)是一种依赖CSS/HTML/JAVASCRIPT 等现有技术使用XMLHttpRequest对象发送http 请求并接受响应的一种技术方案 实现一个Ajax1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/** * &#123;string&#125; param.url * &#123;string&#125; param.type? || &apos;get&apos; * &#123;object&#125; param.data * &#123;function&#125; param.success * &#123;function&#125; param.error */var ajax = function(param) &#123; var xhr = XMLHttpRequest ? new XMLHttpRequest() : new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;) var type = (param.type || &apos;get&apos;).toUpperCase() var url = param.url if(!url) return var data = param.data var dataArr = [] for (var k in data) &#123; dataArr.push(k + &apos;=&apos; + data[k]) &#125; if (type === &apos;GET&apos;) &#123; url = url + &apos;?&apos; + dataArr.join(&apos;&amp;&apos;) xhr.open(type, url) xhr.send() &#125; if (type === &apos;POST&apos;) &#123; xhr.open(type, url) xhr.setRequestHeader(&quot;Content-type&quot;, &quot;application/x-www.form-urlencoded&quot;) xhr.send(dataArr.join(&apos;&amp;&apos;)) &#125; xhr.onreadystatechange = function () &#123; if (xhr.readyState === 4) &#123; if (xhr.status === 200 || xhr.status === 304) &#123; var res if (param.success &amp;&amp; typeof param.success === &apos;function&apos;) &#123; res = xhr.responseText if (typeof res === &apos;string&apos;) &#123; res = JSON.parse(res) param.success.call(xhr, res) &#125; &#125; &#125; else &#123; param.error.call() &#125; &#125; &#125;&#125; 跨域通信的几种方式 首先我们先给host 设置几个子域名来模拟跨域 跨域代码示例1234$ npm install$ npm startport: 3000 使用示例前记得设置本机host JSONPjsonp 原理就是在页面上动态添加一个script标签，给标签的src 指定一个url 路径并加上回调函数query 参数，发送给后端后，后端利用需返回的数据和回调函数的query 参数拼接成类似handleJsonp({ a:1, b:2 })的字符串返回前端，前端定义的handleJsonp 的函数会直接运行并处理{ a:1, b:2 } 这个后端返回的数据 只能发送GET请求 可能会被注入恶意代码 callback=alter(‘111’) 任何域都可以发送jsonp请求，需进行验证，如token1234567891011// 前端代码 jsonpBtn.addEventListener(&apos;click&apos;, function() &#123; const script = document.createElement(&apos;script&apos;) script.src = &apos;http://b.yang.com:3000/jsonp?callback=handleJsonp&apos; document.head.appendChild(script) // document.head.removeChild(script) &#125;) function handleJsonp(data) &#123; console.log(data) &#125; 123456789101112// 后端代码// JSONProuter.get(&apos;/jsonp&apos;, function(req, res, next) &#123; let &#123; callback: cb &#125; = req.query const data = &#123; type: &apos;jsonp&apos;, data: &apos;data&apos; &#125; cb = cb.replace(/\\(/g, &apos;&apos;); // 替换掉() 防止恶意代码注入 cb = cb.replace(/\\)/g, &apos;&apos;); res.send(cb + &apos;(&apos; + JSON.stringify(data) + &apos;)&apos;)&#125;) CORS CORS(cross-origin resource sharing) 跨域资源共享，是一种ajax 跨域请求资源的方式， 普遍用于前后端分离开发环境 原理就在于Access-Control-Allow-Origin 响应头，它指定浏览器在何种域下发送的ajax 请求服务器资源时可以跨域 服务器响应还可以设置其它header:1Access-Control-Allow-Methods: POST, GET, OPTIONS表明服务器允许客户端使用 POST, GET 和 OPTIONS 方法发起请求2Access-Control-Allow-Headers: X-PINGOTHER, Content-Type表明服务器允许请求中携带字段 X-PINGOTHER 与 Content-Type3Access-Control-Max-Age: 86400表明该响应的有效时间为 86400 秒4Access-Control-Allow-Credentials: true 表明跨域请求允许携带cookieMDN12345678910111213// 前端代码 cors.addEventListener(&apos;click&apos;, function() &#123; let reqHeaders = new Headers() reqHeaders.append(&apos;Content-Type&apos;, &apos;application/x-www-form-urlencoded&apos;) fetch(&apos;http://b.yang.com:3000/cors/&apos;, &#123; method: &apos;post&apos;, headers: reqHeaders, mode: &apos;cors&apos;, body: &apos;post body&apos; &#125;).then(function (response) &#123; console.log(response) &#125;) &#125;) 1234567// 后端代码// CORSrouter.post(&apos;/cors&apos;, function(req, res, next) &#123; // res.header(&apos;Access-Control-Allow-Origin&apos;, &apos;http://a.yang.com:3000&apos;) res.header(&apos;Access-Control-Allow-Origin&apos;, &apos;*&apos;) res.send(&apos;cors ok&apos;)&#125;) WebSocket利用websocket 协议进行前后端跨域通信123456789101112// 前端代码 var ws socket.addEventListener(&apos;click&apos;, function() &#123; ws = new WebSocket(`ws://b.yang.com:3000/`) ws.onmessage = (data) =&gt; console.log(data); ws.onerror = () =&gt; console.log(&apos;WebSocket error&apos;); ws.onopen = () =&gt; console.log(&apos;WebSocket connection established&apos;); ws.onclose = () =&gt; console.log(&apos;WebSocket connection closed&apos;); &#125;) sendmsg.addEventListener(&apos;click&apos;, function() &#123; ws.send(&apos;send a msg&apos;) &#125;) 1234567891011121314// 后端代码var express = require(&apos;express&apos;);var app = express();const WebSocket = require(&apos;ws&apos;)var server = http.createServer(app);const wss = new WebSocket.Server(&#123; server &#125;)wss.on(&apos;connection&apos;, (ws, req) =&gt; &#123; ws.on(&apos;message&apos;, message =&gt; &#123; console.log(message) ws.send(message) &#125;)&#125;)server.listen(3000) 降域(使用iframe)1234567891011121314151617// URL: http://a.yang.com:3000/a&lt;div class=&quot;ct&quot;&gt; &lt;h1&gt;使用降域实现跨域&lt;/h1&gt; &lt;div class=&quot;main&quot;&gt; &lt;h4&gt;URL: http://a.yang.com:3000/a&lt;/h4&gt; &lt;input type=&quot;text&quot; placeholder=&quot;http://a.yang.com:3000/a&quot;&gt; &lt;/div&gt; &lt;iframe src=&quot;http://b.yang.com:3000/b&quot; frameborder=&quot;0&quot; &gt;&lt;/iframe&gt;&lt;/div&gt;&lt;script&gt; document.querySelector(&apos;.main input&apos;).addEventListener(&apos;input&apos;, function()&#123; console.log(location.host, this.value); window.frames[0].document.querySelector(&apos;input&apos;).value = this.value; &#125;) document.domain = &quot;yang.com&quot;&lt;/script&gt; 123456789// URL: http://b.yang.com:3000/b&lt;input id=&quot;input&quot; type=&quot;text&quot; placeholder=&quot;http://b.yang.com:3000/b&quot;&gt;&lt;script&gt; document.querySelector(&apos;#input&apos;).addEventListener(&apos;input&apos;, function()&#123; console.log(location.host, this.value); window.parent.document.querySelector(&apos;input&apos;).value = this.value; &#125;) document.domain = &apos;yang.com&apos;;&lt;/script&gt; postMessage(使用iframe)123456789101112131415161718192021//URL: http://a.yang.com:3000/c&lt;div class=&quot;ct&quot;&gt; &lt;h1&gt;使用postMessage实现跨域&lt;/h1&gt; &lt;div class=&quot;main&quot;&gt; &lt;h4&gt;URL: http://a.yang.com:3000/c&lt;/h4&gt; &lt;input type=&quot;text&quot; placeholder=&quot;http://a.yang.com:3000/c&quot;&gt; &lt;/div&gt; &lt;iframe src=&quot;http://localhost:3000/d&quot; frameborder=&quot;0&quot; &gt;&lt;/iframe&gt;&lt;/div&gt;&lt;script&gt; var input = document.querySelector(&apos;.main input&apos;) input.addEventListener(&apos;input&apos;, function()&#123; console.log(&apos;a.yang.com - input event value&apos;, this.value); window.frames[0].postMessage(this.value,&apos;*&apos;); &#125;) window.addEventListener(&apos;message&apos;,function(e) &#123; input.value = e.data console.log(&apos;a.yang.com - message event value&apos;, e.data); &#125;);&lt;/script&gt; 1234567891011121314// URL: http://b.yang.com:3000/d&lt;input id=&quot;input&quot; type=&quot;text&quot; placeholder=&quot;http://b.yang.com:3000/d&quot;&gt;&lt;script&gt; var input = document.querySelector(&apos;#input&apos;) input.addEventListener(&apos;input&apos;, function()&#123; console.log(&apos;b.yang.com - input event value&apos;, this.value); window.parent.postMessage(this.value, &apos;*&apos;); &#125;) window.addEventListener(&apos;message&apos;,function(e) &#123; input.value = e.data console.log(&apos;b.yang.com - message event value&apos;, e.data); &#125;);&lt;/script&gt; 其他hack改变hash值","categories":[{"name":"Font-End Basis","slug":"Font-End-Basis","permalink":"http://yoursite.com/categories/Font-End-Basis/"}],"tags":[{"name":"http","slug":"http","permalink":"http://yoursite.com/tags/http/"}]},{"title":"前端基础重点回顾3:原型链、面向对象、继承","slug":"前端基础重点回顾3:原型链、面向对象、继承","date":"2018-01-26T15:22:17.000Z","updated":"2018-01-30T05:21:53.000Z","comments":true,"path":"2018/01/26/前端基础重点回顾3:原型链、面向对象、继承/","link":"","permalink":"http://yoursite.com/2018/01/26/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E9%87%8D%E7%82%B9%E5%9B%9E%E9%A1%BE3:%E5%8E%9F%E5%9E%8B%E9%93%BE%E3%80%81%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E3%80%81%E7%BB%A7%E6%89%BF/","excerpt":"","text":"创建对象的几种方法 字面量创建对象 1var o1 = &#123; name: &apos;o1&apos; &#125; 使用Object构造函数创建对象 1var o2 = new Object(&#123; name: &apos;o2&apos; &#125;) 使用显式构造函数创建 12var Obj = function (name) &#123; this.name = name &#125;var o3 = new Obj(&apos;o3&apos;) 是用Object.create 创建一个指定原型的对象 12var proto = &#123; name: &apos;o4&apos; &#125;var o4 = Object.create(proto) 原型链 原型链描述 1.从一个实例对象向上找构造这个实例相关联的对象，2.再从从这个相关联的对象继续向上找创建这个对象相关联的对象，3.以此类推一直到Object.prototype (null)终止。 原型链通过什么连接和寻找 通过构造函数prototype 和 实例对象的proto 进行寻找 原型对象prototype 有什么特点 构造函数的prototype 由此构造函数创建的多个实例共同使用的对象 instanceof的原理 判断实例对象:proto 和构造函数:prototype 两者的引用是否是同一个原型的引用地址(比如Object.prototype ) 在原型链上的构造函数都会返回true 面向对象类与实例1234567891011var P = function (name) &#123; this.name = name&#125;class P &#123; constructor (name) &#123; this.name = name &#125;&#125;const p = new P(&apos;name&apos;) new 操作符使用1234567// 使用new 操作符直接创建实例var p1 = new Person(&apos;laoyang&apos;, &apos;22&apos;, &apos;coding&apos;)// 不使用new 操作符var p2 = new Object() // p2 创建成为一个对象 这时p2的原型是ObjectPerson.call(p2, &apos;xiaoyang&apos;, &apos;2&apos;, &apos;test&apos;) // Person构造函数在 p2 对象的环境内执行 这时p2已经是一个具有Person属性的实例了，但原型是Objectp2.__proto__ = Object.create(Person.prototype) // 最后创建一个原型为Person.prototype 的p2.__proto__，让p2的原型为Person.prototype new 操作符做了什么 创建一个空对象，它继承自构造函数Person.prototype 构造函数Person被执行，执行时相应的参数会被传入，同时上下文this会被指定为这个新实例 如果构造函数Person返回了一个对象，那么这个对象会取代整个new 出来的结果，如果构造函数没有返回对象，那么new 出来的结果为创建的对象123456789101112var new = function(func) &#123; var o = Object.create(func.prototype) var k = function.call(o) if (typeof k === &apos;object&apos;) &#123; return k &#125; else &#123; return o &#125;&#125;var obj = new(P)obj instanceof P // trueobj.__proto__.constructor === P // true 继承有几种方式 借助构造函数实现继承 123456789function Parent () &#123; this.name = &apos;parent&apos;&#125;Parent.prototype.fn = function () &#123;&#125;function Child () &#123; Parent.call(this) this.type = &apos;child&apos;&#125;缺点: Parent 的原型对象prototype 无法继承 借助原型链实现继承 1234567891011121314function Parent () &#123; this.name = &apos;parent&apos; this.arr = [1,2,3]&#125;function Child () &#123; this.type = &apos;child&apos;&#125;Child.prototype = new Parent()优点: 解决了Parent 原型对象的继承缺点: 由Child 创建的多个实例对象共享父类的引用类型var c1 = new Child()var c2 = new Child()c1.arr.push(4)c2.arr // [1, 2, 3, 4] 前两种的组合方式 1234567891011function Parent () &#123; this.name = &apos;parent&apos; this.arr = [1, 2, 3, 4]&#125;function Child () &#123; Parent.call(this) this.type = &apos;child&apos;&#125;Child.prototype = new Parent()优点: 不仅实现了父类prototype 的继承，也通过Parent.call(this) 创建了各实例独自的arr 复杂类型缺点: 不够优雅，可以优化 组合方式优化1 1234567891011function Parent () &#123; this.name = &apos;parent&apos; this.arr = [1, 2, 3]&#125;function Child () &#123; Parent.call(this) this.type = &apos;child&apos;&#125;Child.prototype = Parent.prototype优点: \bChild不仅继承了Parent 的prototype，而且实现优雅缺点: Child 创建的实例constructor 指向是Parent, 而且修改了Parent.prototype 会同时改变Child.prototype 和由Child 创建实例的__proto__ 组合方式优化2 1234567891011function Parent () &#123; this.name = &apos;parent&apos; this.arr = [1, 2, 3]&#125;function Child () &#123; Parent.call(this) this.type = &apos;child&apos;&#125;Child.prototype = Object.create(Parent.prototype) // 创建一个纯净的对象Child.prototype.constructor = Child // 把Child 原型的constructor 指向自己优点: 不仅完成了继承，同时把Child.prototype.constructor 指向自己，使得每个实例的__proto__.constructor 都指向Child构造函数，更规范。使用Object.create(proto) 方法创建了一个原型对象为Parent.prototype 但是又和Parent.prototype 彻底分离的纯净对象，与Child.prototype 两者互不影响。","categories":[{"name":"Font-End Basis","slug":"Font-End-Basis","permalink":"http://yoursite.com/categories/Font-End-Basis/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"前端基础重点回顾2:HTTP协议","slug":"前端基础重点回顾2:HTTP协议","date":"2018-01-24T08:50:04.000Z","updated":"2018-01-24T08:54:24.000Z","comments":true,"path":"2018/01/24/前端基础重点回顾2:HTTP协议/","link":"","permalink":"http://yoursite.com/2018/01/24/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E9%87%8D%E7%82%B9%E5%9B%9E%E9%A1%BE2:HTTP%E5%8D%8F%E8%AE%AE/","excerpt":"","text":"HTTP协议的主要特点 简单快速URI固定，处理简单 灵活http协议可以通过修改header 指定传输的数据类型，一个http 传输可以完成不同数据类型的传输 无连接http协议每次传输后连接都会断开 无状态客户端和服务端是两块，客户端再次访问服务端是无法区分客户端的(单从http 协议上是无法区分客户端身份的) HTTP报文组成请求报文 请求行http方法、请求地址、http协议版本 请求头header：key value 格式 空行(CR+LF)用于识别请求头和请求体的分隔符，CR+LF 回车+换行符 请求体 响应报文 状态行状态码、http协议版本 响应头header：key value 格式 空行(CR+LF)用于识别响应头和响应体的分隔符，CR+LF 回车+换行符 响应体响应的实体内容 HTTP方法 get 获取 post 传输 put 更新 delete 删除 header 获得报文首部 options 对服务器预先请求告知 GET / POST 区别 get产生的url地址可以被收藏，post不可以 get会被浏览器主动缓存，post不会，除非手动设置 get只能进行url编码，post支持多种编码方式 get参数会被完整保留在浏览器历史记录里，post参数不会保留 get在url中参数有长度限制2kb，post没有限制 参数的数据类型：get只接受ASCII字符，post没有限制 get参数直接暴露在url上，不能传递敏感信息 get通过url传递，post放在request body中 HTTP状态码1xx: 指示信息 - 请求已接收2xx: 成功 - 请求被成功接收 200 OK 206 Partiaml Content 客户端发送了一个带Range头多get请求，服务器完成了它(音频、视频应用) 3xx: 重定向 301 Moved Permanently 所请求的资源已经转移至新的url地址 302 Found 所请求的资源临时转移至新url地址 304 Not Modified 客户端有缓存的文档并发出了一个条件性请求，服务器告诉客户端原来缓存的资源文件可以继续使用 4xx: 客户端错误 400 Bad Request 客户端存在语法错误，服务器无法理解 401 Unauthorized 请求未授权 必须和www-Authenticate 报头域一起使用(JWT鉴权应用) 403 Forbidden 请求被禁止访问(只能通过服务器端访问) 404 Not Found 请求的资源不存在 5xx: 服务器错误 500 Internal server Error 服务器错误 503 Server Unavailable 请求未完成或服务器临时过载当机 HTTP持久连接HTTP协议采用“请求-应答”模式，每进行一次http连接就会断开TCP连接 Keep-Alive Keep-Alive 模式，只要有一方未明确表示断开连接则保持TCP连接状态，此功能避免重复建立连接 HTTP/1.0 未标准化 HTTP/1.1 版本默认支持 HTTP管线化在HTTP/1.1 版本使用Keep-Alive 下可以使用管线化(pipelining)方式发送请求 123456789// 未使用管线化 单个请求req1 &gt; serverres1 &lt; serverreq2 &gt; serverres2 &lt; serverreq3 &gt; serverres3 &lt; server 12345678// 使用管线化 打包发送req1 &gt; serverreq2 &gt; serverreq3 &gt; serverres1 &lt; serverres2 &lt; serverres3 &lt; server 管线化只通过Keep-Alive 完成，http/1.1 才支持 只有get 和head 方法请求才可以，post 有限制 初次创建连接不启动管线化机制，因为对方服务器不一定支持http/1.1 管线化不会影响服务器响应顺序 http/1.1 要求服务端支持管线化处理不失败即可 chrmoe firefox 默认未开启管线化支持，因为管线化功能不一定能带来性能提升，服务器支持也不好。 Cookie 维持客户端访问状态浏览器每次访问会携带cookie 信息，服务器可以设置cookie，通过这个特性可以创建带状态(session)的http 访问连接123456// 客户端首次访问服务端client -----------无cookie------------&gt; serverclient &lt;-----set-cookie: sid=user1----- server// 客户端再次访问服务端client -----cookie: sid=user1---------&gt; serverclient &lt;--------确认是user1访问---------- server session 就是服务端手动维护每个客户端访问的cookie，可以维护在内存里也可以维护在redis 缓存中。","categories":[{"name":"Font-End Basis","slug":"Font-End-Basis","permalink":"http://yoursite.com/categories/Font-End-Basis/"}],"tags":[{"name":"http","slug":"http","permalink":"http://yoursite.com/tags/http/"}]},{"title":"前端基础重点回顾1:CSS盒模型、DOM、数据类型","slug":"前端基础重点回顾1:CSS盒模型、DOM、数据类型","date":"2018-01-22T13:42:52.000Z","updated":"2018-01-22T13:56:52.000Z","comments":true,"path":"2018/01/22/前端基础重点回顾1:CSS盒模型、DOM、数据类型/","link":"","permalink":"http://yoursite.com/2018/01/22/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E9%87%8D%E7%82%B9%E5%9B%9E%E9%A1%BE1:CSS%E7%9B%92%E6%A8%A1%E5%9E%8B%E3%80%81DOM%E3%80%81%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","excerpt":"","text":"CSS盒模型标准模型与IE模型的区别 计算高度宽度不同 标准盒模型的width 是以盒模型的content 来计算的IE盒模型的width 是以盒模型的border + padding + content 来计算的 CSS如何设置这两种模型 通过设置元素的box-sizing 属性 标准盒模型设置为box-sizing: content-boxIE盒模型设置为box-sizing: border-box JS如何设置获取盒模型对应的宽和高12// 获取内联样式dom.style.width / height 12// 获取渲染后的属性 IE 支持dom.currentStyle.width / height 12// 获取元素渲染后计算完毕的样式，所有浏览器支持window.getComputedStyle(dom).width / height 12// 计算元素的绝对位置dom.getBoundingClientRect().width / height dom.getBoundingClientRect() 函数不仅可以得到元素的宽高还能获得此元素在页面中的位置。[图片上传失败…(image-a1291e-1516628501105)] BFC什么是BFCBFC(block formatting context) 是一个块级格式化上下文，它形成了一个独立的布局环境。 怎么创建一个BFC1 设置float，值不为”none”2 设置overflow，值不为”visible”（hidden，auto，scroll）3 设置display的值为 “table-cell”, “table-caption”,或 “inline-block”4 设置position，值不为 “static” 或 “relative”（absolute，fixed） BFC 有什么特点1 BFC 元素内的各元素会在垂直方向上从顶部一个接一个的放置。2 BFC中的元素的布局是不受外界的影响,内外元素不会互相影响。3 BFC元素不会与浮动元素的区域重叠4 计算BFC元素高度的时候浮动元素也会参与计算 代码5 属于同一个BFC的两个相邻Box的margin会发生叠加 代码 BFC 的使用场景 解决margin叠加问题 代码 用于布局 代码 用于清除浮动 代码 DOMDOM事件的级别12// DOM0级el.onclick=function()&#123;&#125; 12// DOM2级el.addEventListenter(&apos;click&apos;, function()&#123;&#125;, &apos;是否捕获阶段触发&apos;: boolean) 12// DOM3级 区别DOM2级增加了更多的事件类型el.addEventListenter(&apos;keyup&apos;, function()&#123;&#125;, &apos;是否捕获阶段触发&apos;: boolean) DOM事件模型 事件捕获 事件冒泡 DOM事件流DOM事件流(event flow)三阶段 事件触发(触发元素) =&gt; 事件捕获阶段(事件下传) =&gt; 处于目标阶段(达到目标元素) =&gt; 事件冒泡阶段(事件上传) 描述DOM事件捕获的具体流程12// IE 只有冒泡流程window =&gt; document =&gt; html(document.documentElement) =&gt; body =&gt; ... =&gt; 目标元素 如何自定义事件Event 对象1234567// 创建var event = new Event(&apos;custome&apos;)// 注册el.addEventListener(&apos;custome&apos;, function()&#123; console.log(&apos;custome&apos;)&#125;)el.dispatchEvent(event) // 触发 CustomEvent 对象123456var event = new CustomEvent(&apos;build&apos;, &#123; &apos;detail&apos;: elem.dataset.time &#125;);function eventHandler(e) &#123; console.log(&apos;The time is: &apos; + e.detail);&#125;el.addEventListener(&apos;custome&apos;, eventHandler)el.dispatchEvent(event) // 触发 Event对象的常见应用12345event.preventDefault() // 阻止默认event.stopPropagation() // 阻止冒泡event.stopImmediatePropagation() // 按钮绑定两个click，A点击时候不出发B，A会成功阻止B, 事件响应优先级event.target // 可以用于事件委托，由父级注册事件event.currentTarget currentTarget vs targettarget在事件流的目标阶段；currentTarget在事件流的捕获，目标及冒泡阶段。只有当事件流处在目标阶段的时候，两个的指向才是一样的， 而当处于捕获和冒泡阶段的时候，target指向被单击的对象而currentTarget指向当前事件活动的对象（一般为父级）。 类型转换 数据类型 原始类型 Boolean, String, Number, Null, Undefined, Symbol 复杂类型(对象) Object 显式类型转换Number函数 简单类型: 直接转换end复杂类型: valueOf() =&gt; 简单类型 =&gt; 直接转换end || 复杂类型 =&gt; toString() =&gt; 简单类型 =&gt;直接转换end String函数 简单类型: 直接转换end复杂类型: toString() =&gt; 简单类型 =&gt; 直接转换end || 复杂类型 =&gt; valueOf() =&gt; 简单类型 =&gt;直接转换end || 复杂类型error Boolean函数 \b 空字符串、Null、undefined、false、0 转化为false","categories":[{"name":"Font-End Basis","slug":"Font-End-Basis","permalink":"http://yoursite.com/categories/Font-End-Basis/"}],"tags":[{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"},{"name":"dom","slug":"dom","permalink":"http://yoursite.com/tags/dom/"}]},{"title":"Vue组件.sync修饰符","slug":"Vue组件-sync修饰符","date":"2018-01-22T05:09:11.000Z","updated":"2018-01-22T05:09:33.000Z","comments":true,"path":"2018/01/22/Vue组件-sync修饰符/","link":"","permalink":"http://yoursite.com/2018/01/22/Vue%E7%BB%84%E4%BB%B6-sync%E4%BF%AE%E9%A5%B0%E7%AC%A6/","excerpt":"","text":"12345&lt;div id=&quot;app&quot;&gt; &lt;div&gt;父组件bar: &#123;&#123;bar&#125;&#125;&lt;/div&gt; &lt;comp :foo.sync=&quot;bar&quot;&gt;&lt;/comp&gt; &lt;!-- &lt;comp :foo=&quot;bar&quot; @update:foo=&quot;val =&gt; bar = val&quot;&gt;&lt;/comp&gt; --&gt;&lt;/div&gt; 1234567891011121314151617&lt;script&gt;Vue.component(&apos;comp&apos;, &#123; template: &apos;&lt;div&gt;&lt;button @click=&quot;increment&quot;&gt;点我更新子组件foo++&lt;/button&gt;&lt;div&gt;子组件foo: &#123;&#123;foo&#125;&#125;&lt;/div&gt;&lt;/div&gt;&apos;, props: [&apos;foo&apos;], methods: &#123; increment: function() &#123; this.foo++; this.$emit(&apos;update:foo&apos;, this.foo); &#125; &#125;&#125;);new Vue(&#123; el: &apos;#app&apos;, data: &#123;bar: 0&#125;&#125;);&lt;/script&gt; :foo.sync=&quot;bar&quot; 实际就是 :foo=&quot;bar&quot; @update:foo=&quot;val =&gt; bar = val&quot; 的语法糖.sync demo","categories":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/tags/Vue/"}]},{"title":"CSS3总结","slug":"CSS3总结","date":"2018-01-22T05:07:54.000Z","updated":"2018-01-22T05:08:22.000Z","comments":true,"path":"2018/01/22/CSS3总结/","link":"","permalink":"http://yoursite.com/2018/01/22/CSS3%E6%80%BB%E7%BB%93/","excerpt":"","text":"##CSS3 calc() 计算属性12width: calc(100% - 50px)calc内可以写 + - * / 运算符 记得留空格 ##CSS3效果的简单事例圆角， 圆形div 阴影2D 转换：放大、缩小、偏移、旋转3D 转换：移动、旋转背景色渐变过渡效果动画CSS3效果 ##全屏过渡效果全屏过渡 ##loading效果loading1loading2 本博客版权归 本人和饥人谷所有，转载需说明来源","categories":[{"name":"css","slug":"css","permalink":"http://yoursite.com/categories/css/"}],"tags":[{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"}]},{"title":"使用sftp操作远程服务器","slug":"使用sftp操作远程服务器","date":"2018-01-22T05:07:02.000Z","updated":"2018-01-22T05:07:27.000Z","comments":true,"path":"2018/01/22/使用sftp操作远程服务器/","link":"","permalink":"http://yoursite.com/2018/01/22/%E4%BD%BF%E7%94%A8sftp%E6%93%8D%E4%BD%9C%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8/","excerpt":"","text":"远程连接服务器12sftp user@xxx.xxx.xxxexit // 退出 与Bash相似的功能1234pwd // 查看当前路径ls ls -lacd 进行本地操作123lpwd // 查看本地路径llslcd 使用sftp传输文件12345678// 下载文件get remote_file_name// 下载重命名get remote_file_name local_file_name// 下载文件夹get -r some_directory_name// 下载并保持信息get -Pr some_directory_name 1234// 上传文件put local_file_name// 上传文件夹put -r local_directory_name 查看磁盘123df -h // 查看磁盘大小! // 切换本地使用bash命令exit // 返回远程服务器进行sftp操作 参考文章","categories":[{"name":"network","slug":"network","permalink":"http://yoursite.com/categories/network/"}],"tags":[{"name":"sftp","slug":"sftp","permalink":"http://yoursite.com/tags/sftp/"}]},{"title":"数组去重","slug":"数组去重","date":"2018-01-22T05:06:14.000Z","updated":"2018-01-22T05:06:38.000Z","comments":true,"path":"2018/01/22/数组去重/","link":"","permalink":"http://yoursite.com/2018/01/22/%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D/","excerpt":"","text":"基础类型数组去重1const arr = [1, 1, 2, 3, 3, 4, 5] ES5123function unique(arr) &#123; return arr.filter((item, index, array) =&gt; array.indexOf(item) === index)&#125; ES612345678function unique (arr) &#123; const seen = new Map() return arr.filter((a) =&gt; !seen.has(a) &amp;&amp; seen.set(a, 1))&#125;// orfunction unique(array) &#123; return [...new Set(array)]&#125; 复杂类型数组去重1const array = [&#123;value: 1&#125;, &#123;value: 1&#125;, &#123;value: 2&#125;] ES51234function unique(arr) &#123; var obj = &#123;&#125; return arr.filter((item, index, array) =&gt; !obj.hasOwnProperty(JSON.stringify(item)) &amp;&amp; (obj[JSON.stringify(item)] = true))&#125; ES61234function unique (arr) &#123; const seen = new Map() return arr.filter((a) =&gt; !seen.has(JSON.stringify(a)) &amp;&amp; seen.set(JSON.stringify(a), 1))&#125;","categories":[{"name":"Font-End Basis","slug":"Font-End-Basis","permalink":"http://yoursite.com/categories/Font-End-Basis/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"Vue生命周期","slug":"Vue生命周期","date":"2018-01-22T05:05:18.000Z","updated":"2018-01-22T05:05:46.000Z","comments":true,"path":"2018/01/22/Vue生命周期/","link":"","permalink":"http://yoursite.com/2018/01/22/Vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/","excerpt":"","text":"vue里的生命周期是什么？vue实例从创建到销毁的过程称之为vue的生命周期 vue的生命周期各阶段都做了什么？beforeCreate 实例创建前：这个阶段实例的data、methods是读不到的created 实例创建后：这个阶段已经完成了数据观测(data observer)，属性和方法的运算， watch/event 事件回调。mount挂载阶段还没开始，$el 属性目前不可见，数据并没有在DOM元素上进行渲染beforeMount：在挂载开始之前被调用：相关的 render 函数首次被调用。mounted：el选项的DOM节点 被新创建的 vm.$el 替换，并挂载到实例上去之后调用此生命周期函数。此时实例的数据在DOM节点上进行渲染beforeUpdate：数据更新时调用，但不进行DOM重新渲染，在数据更新时DOM没渲染前可以在这个生命函数里进行状态处理updated：这个状态下数据更新并且DOM重新渲染，当这个生命周期函数被调用时，组件 DOM 已经更新，所以你现在可以执行依赖于 DOM 的操作。当实例每次进行数据更新时updated都会执行beforeDestory：实例销毁之前调用。destroyed：Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。 vue生命周期在真实场景下的业务应用created：进行ajax请求异步数据的获取、初始化数据mounted：挂载元素内dom节点的获取nextTick：针对单一事件更新数据后立即操作domupdated：任何数据的更新，如果要做统一的业务逻辑处理watch：监听具体数据变化，并做相应的处理","categories":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/tags/Vue/"}]},{"title":"Vue.nextTick的实现","slug":"Vue-nextTick的实现","date":"2018-01-22T05:04:21.000Z","updated":"2018-01-22T05:04:51.000Z","comments":true,"path":"2018/01/22/Vue-nextTick的实现/","link":"","permalink":"http://yoursite.com/2018/01/22/Vue-nextTick%E7%9A%84%E5%AE%9E%E7%8E%B0/","excerpt":"","text":"这是一篇继event loop和MicroTask 后的vue.nextTick API实现的源码解析。 预热，写一个sleep函数123456789function sleep (ms) &#123; return new Promise(resolve =&gt; setTimeout(resolve, ms)&#125;async function oneTick (ms) &#123; console.log(&apos;start&apos;) await sleep(ms) console.log(&apos;end&apos;)&#125;oneTick(3000) 解释下sleep函数async 函数进行await PromiseFn()时函数执行是暂停的，我们也知道现在这个PromiseFn是在microTask内执行。当microTask没执行完毕时，后面的macroTask是不会执行的，我们也就通过microTask在event loop的特性实现了一个sleep函数，阻止了console.log的执行 流程1执行console.log(‘start’)2执行await 执行暂停，等待await函数后的PromiseFn在microTask执行完毕3在sleep函数内，延迟ms返回4返回resolve后执行console.log(‘end’) nextTick API vue中nextTick的使用方法 123vue.nextTick(() =&gt; &#123; // todo...&#125;) 了解用法后看一下源码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263const nextTick = (function () &#123; const callbacks = [] let pending = false let timerFunc // 定时函数 function nextTickHandler () &#123; pending = false const copies = callbacks.slice(0) // 复制 callbacks.length = 0 // 清空 for (let i = 0; i &lt; copies.length; i++) &#123; copies[i]() // 逐个执行 &#125; &#125; if (typeof Promise !== &apos;undefined&apos; &amp;&amp; isNative(Promise)) &#123; var p = Promise.resolve() var logError = err =&gt; &#123; console.error(err) &#125; timerFunc = () =&gt; &#123; p.then(nextTickHandler).catch(logError) // 重点 &#125; &#125; else if (&apos;!isIE MutationObserver&apos;) &#123; var counter = 1 var observer = new MutationObserver(nextTickHandler) // 重点 var textNode = document.createTextNode(string(conter)) observer.observe(textNode, &#123; characterData: true &#125;) timerFunc = () =&gt; &#123; counter = (counter + 1) % 2 textNode.data = String(counter) &#125; &#125; else &#123; timerFunc = () =&gt; &#123; setTimeout(nextTickHandler, 0) // 重点 &#125; &#125; return function queueNextTick (cb, ctx) &#123; // api的使用方式 let _resolve callbacks.push(() =&gt; &#123; if (cb) &#123; try &#123; cb.call(ctx) &#125; catch (e) &#123; err &#125; &#125; else if (_resolve) &#123; _resolve(ctx) &#125; &#125;) if (!pending) &#123; pending = true timerFunc() &#125; if (!cb &amp;&amp; typeof Promise !== &apos;undefined&apos;) &#123; return new Promise((resolve, reject) =&gt; &#123; _resolve =resolve &#125;) &#125; &#125;&#125;)() // 自执行函数 大致看一下源码可以了解到nextTick api是一个自执行函数既然是自执行函数，直接看它的return类型，return function queueNextTick (cb, ctx) {…} 1234567891011121314151617181920212223return function queueNextTick (cb, ctx) &#123; // api的使用方式 let _resolve callbacks.push(() =&gt; &#123; if (cb) &#123; try &#123; cb.call(ctx) &#125; catch (e) &#123; err &#125; &#125; else if (_resolve) &#123; _resolve(ctx) &#125; &#125;) if (!pending) &#123; pending = true timerFunc() &#125; if (!cb &amp;&amp; typeof Promise !== &apos;undefined&apos;) &#123; return new Promise((resolve, reject) =&gt; &#123; _resolve =resolve &#125;) &#125; &#125; 只关注主流程queueNextTick函数把我们传入的() =&gt; { // todo… } 推入了callbacks内 1234567891011121314151617181920212223if (typeof Promise !== &apos;undefined&apos; &amp;&amp; isNative(Promise)) &#123; var p = Promise.resolve() var logError = err =&gt; &#123; console.error(err) &#125; timerFunc = () =&gt; &#123; p.then(nextTickHandler).catch(logError) // 重点 &#125;&#125; else if (&apos;!isIE MutationObserver&apos;) &#123; var counter = 1 var observer = new MutationObserver(nextTickHandler) // 重点 var textNode = document.createTextNode(string(conter)) observer.observe(textNode, &#123; characterData: true &#125;) timerFunc = () =&gt; &#123; counter = (counter + 1) % 2 textNode.data = String(counter) &#125;&#125; else &#123; timerFunc = () =&gt; &#123; setTimeout(nextTickHandler, 0) // 重点 &#125;&#125; 这一段我们可以看到标注的三个点表明在不同浏览器环境下使用Promise, MutationObserver或setTimeout(fn, 0) 来执行nextTickHandler 12345678910111213function nextTickHandler () &#123; pending = false const copies = callbacks.slice(0) // 复制 callbacks.length = 0 // 清空 for (let i = 0; i &lt; copies.length; i++) &#123; copies[i]() // 逐个执行 &#125; &#125;``` nextTickHandler就是把我们之前放入callbacks的 () =&gt; &#123; // todo... &#125; 在当前tasks内执行。## 写一个简单的nextTick源码可能比较绕，我们自己写一段简单的nextTick const simpleNextTick = (function () { let callbacks = [] let timerFunc return function queueNextTick (cb) { callbacks.push(() =&gt; { // 给callbacks 推入cb() cb() }) timerFunc = () =&gt; { return Promise.resolve().then(() =&gt; { const fn = callbacks.shift() fn() }) } timerFunc() // 执行timerFunc，返回到是一个Promise }})() simpleNextTick(() =&gt; { setTimeout(console.log, 3000, ‘nextTick’)})12我们可以从这里看出nextTick的原理就是返回出一个Promise，而我们todo的代码在这个Promise中执行，现在我们还可以继续简化 const simpleNextTick = (function () { return function queueNextTick (cb) { timerFunc = () =&gt; { return Promise.resolve().then(() =&gt; { cb() }) } timerFunc() }})() simpleNextTick(() =&gt; { setTimeout(console.log, 3000, ‘nextTick’)})12直接写成这样。 const simpleNextTick = function queueNextTick (cb) { timerFunc = () =&gt; { return Promise.resolve().then(() =&gt; { cb() }) } timerFunc() } simpleNextTick(() =&gt; { setTimeout(console.log, 3000, ‘nextTick’)})12这次我们把自执行函数也简化掉 const simpleNextTick = function queueNextTick (cb) { return Promise.resolve().then(cb) } simpleNextTick(() =&gt; { setTimeout(console.log, 3000, ‘nextTick’)})1234现在我们直接简化到最后，现在发现nextTick最核心的内容就是Promise，一个microtask。现在我们回到vue的nextTick API官方示例 var vm = new Vue({ el: ‘#example’, data: { message: ‘123’ }})vm.message = ‘new message’ // 更改数据vm.$el.textContent === ‘new message’ // falseVue.nextTick(function () { vm.$el.textContent === ‘new message’ // true})12345原来在vue内数据的更新后dom更新是要在下一个事件循环后执行的。nextTick的使用原则主要就是解决单一事件更新数据后立即操作dom的场景。既然我们知道了nextTick核心是利用microTasks，那么我们把简化过的nextTick和开头的sleep函数对照一下。 const simpleNextTick = function queueNextTick (cb) { return Promise.resolve().then(cb) } simpleNextTick(() =&gt; { setTimeout(console.log, 3000, ‘nextTick’) // 也可以换成ajax请求})12345678910```function sleep (ms) &#123; return new Promise(resolve =&gt; setTimeout(resolve, ms) // 也可以换成ajax请求&#125;async function oneTick (ms) &#123; console.log(&apos;start&apos;) await sleep(ms) console.log(&apos;end&apos;)&#125;oneTick(3000) 我们看出nextTick和我么写的oneTick的执行结果是那么的相似。区别只在于nextTick是把callback包裹一个Promise返回并执行，而oneTick是用await执行一个Promise函数，而这个Promise有自己包裹的webapi函数。 那在用ajax请求的时候我们是不是直接这样使用axios可以返回Promise的库 12345async function getData () &#123; const data = await axios.get(url) // 操作data的数据来改变dom return data&#125; 这样也可以达到同nextTick同样的作用 最后我们也可以从源码中看出，当浏览器环境不支持Promise时可以使用MutationObserver或setTimeout(cb, 0) 来达到同样的效果。但最终的核心是microTask","categories":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/tags/Vue/"}]},{"title":"继异步编程的async/await函数补充","slug":"继异步编程的async-await函数补充","date":"2018-01-22T05:01:48.000Z","updated":"2018-01-22T05:04:08.000Z","comments":true,"path":"2018/01/22/继异步编程的async-await函数补充/","link":"","permalink":"http://yoursite.com/2018/01/22/%E7%BB%A7%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E7%9A%84async-await%E5%87%BD%E6%95%B0%E8%A1%A5%E5%85%85/","excerpt":"","text":"这个执行函数顺序的问题是继之前EventLoop 和 MicroTask的文章的补充1234567891011121314151617181920async function async1() &#123; console.log(&apos;async1 start&apos;); // 问题1 async1 start 在script 里执行是什么样的 await async2(); // 问题2 为什么async2 在promise1 前执行 console.log(&apos;async1 end&apos;); // 问题3 为什么async1 end 会在 promise2 后执行&#125;async function async2() &#123; console.log(&apos;async2&apos;);&#125;console.log(&apos;script start&apos;);setTimeout(function() &#123; console.log(&apos;setTimeout&apos;);&#125;, 0);async1();new Promise(function(resolve) &#123; console.log(&apos;promise1&apos;); resolve(); &#125;).then(function() &#123; console.log(&apos;promise2&apos;); &#125;);console.log(&apos;script end&apos;); 执行结果1234567891. script start2. async1 start3. async24. promise15. script end6. promise27. async1 end// stack 清空8. setTimeout 问题1 async1 start 在script 里执行是什么样的?先看下async 函数 babel 后样子 可以看出async 函数只是执行了_asyncToGenerator 这个函数, 再看下_asyncToGenerator 原来_asyncToGenerator 函数只是返回了一个 new Promise()，async1() 的执行也就是在script 里执行里一个new Promise() 问题2 为什么async2 在promise1 前执行从问题1可以知道async2 () 也是一个new Promise() ，不过async2() 多了一个aiwait，看下mdn 的描述 await 表达式会暂停当前 async function 的执行，等待 Promise 处理完成。若 Promise 正常处理(fulfilled)，其处理结果作为 await 表达式的值，继续执行 async function。 再看一下babel 后的babel 后只不过前面多了yield，await async()变成了yield new Promise()，\byield 是一个暂停执行的标记而后面的语句是已经执行完了，async2 也就先于promise1 在script 中执行。 问题3 为什么async1 end 会在 promise2 后执行这里引用阮一峰的对Generator-函数异步应用的解释 传统的编程语言，早有异步编程的解决方案（其实是多任务的解决方案）。其中有一种叫做”协程”（coroutine），意思是多个线程互相协作，完成异步任务。协程有点像函数，又有点像线程。它的运行流程大致如下。第一步，协程A开始执行。第二步，协程A执行到一半，进入暂停，执行权转移到协程B。第三步，（一段时间后）协程B交还执行权。第四步，协程A恢复执行。上面流程的协程A，就是异步任务，因为它分成两段（或多段）执行。 这里的async1 end 与 promise2 的执行就是因为yield 的“协程”，我们这里改写一下问题，让问题更清晰1234567891011121314151617181920async function async1() &#123; console.log(&apos;async1 start&apos;); new Promise(function(resolve) &#123; // 我们把new Promise 放到async1内部 console.log(&apos;promise1&apos;); resolve(); &#125;).then(function() &#123; // await 通过yield 协程的功能 把上下两段分割 console.log(&apos;promise2&apos;); &#125;); await async2(); // yield 协程分割，但是async2 先执行完毕 console.log(&apos;async1 end&apos;); // await 通过yield 协程的功能 把上下两段分割&#125;async function async2() &#123; console.log(&apos;async2&apos;);&#125;console.log(&apos;script start&apos;);setTimeout(function() &#123; console.log(&apos;setTimeout&apos;);&#125;, 0);async1();console.log(&apos;script end&apos;); 从上面的改写看出await async2 通过协程把上promise2 和 async1 end 分割成两部分，这里将会把上半部分的microtask 的任务都执行完毕才会执行下一段的代码。 这段代码的执行顺序不仅考察了异步执行主要考察了对async / await 函数的降级理解，了解到这一层后发现async / await 函数确实是js 异步执行的好方式。 babel编译","categories":[{"name":"Font-End Basis","slug":"Font-End-Basis","permalink":"http://yoursite.com/categories/Font-End-Basis/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"EventLoop事件循环中的 MacroTask与 MicroTask","slug":"EventLoop事件循环中的 MacroTask与 MicroTask","date":"2018-01-22T04:34:47.000Z","updated":"2018-01-22T04:36:51.000Z","comments":true,"path":"2018/01/22/EventLoop事件循环中的 MacroTask与 MicroTask/","link":"","permalink":"http://yoursite.com/2018/01/22/EventLoop%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E4%B8%AD%E7%9A%84%20MacroTask%E4%B8%8E%20MicroTask/","excerpt":"","text":"问题来源在学习Promise时在stackoverflow上看到一个解释Promise运行顺序回答。之前在学习异步编程中讲解了MacroTask和MicroTask， 但在最近深入EventLoop后又有了更多的了解 EventLoop、MacroTask、MicroTask之间的关系 macrotasks 与 microtasks 各自的 APImacrotasks: setTimeout, setInterval, setImmediate, requestAnimationFrame, I/O, UI renderingmicrotasks: process.nextTick, Promises, Object.observe, MutationObserver 一张图先了解microtasks 与macrotasks 在eventloop队列里的位置这里用了上一章EventLoop 事件循环文章里的图，并在回调队列里标注里microtask的位置。 microtasks 与macrotasks 在eventloop 里的流程在没有引入microtasks 概念前事件循环是这样执行的123while (queue是否有task) &#123; 执行task&#125; 引入microtasks 概念后1234while (queue是否有macrotasks) &#123; if (microtasks) 执行空microtasks 再执行macrotasks&#125; microtasks 与macrotasks 在eventloop 里实际执行结果1234567891011121314// 例1console.log(&apos;script start&apos;);setTimeout(function() &#123; console.log(&apos;setTimeout&apos;);&#125;, 0);Promise.resolve().then(function() &#123; console.log(&apos;promise1&apos;);&#125;).then(function() &#123; console.log(&apos;promise2&apos;);&#125;);console.log(&apos;script end&apos;); 12345678// 结果script startscript endpromise1promise2setTimeout// 当前循环结束// 进入下一个循环 从webapi在Eventloop的执行环境我们可以知道setTimeout在当前事件循环中将会在script end后执行，这是没问题的。而promise作为microtasks将会在当前事件循环内的macrotasks之前执行完毕。setTimeout作为macrotasks在例1中是最后执行的。 12345678910111213141516171819例2setImmediate(function()&#123; console.log(1);&#125;,0);setTimeout(function()&#123; console.log(2);&#125;,0);new Promise(function(resolve)&#123; console.log(3); resolve(); console.log(4);&#125;).then(function()&#123; console.log(5);&#125;);console.log(6);process.nextTick(function()&#123; console.log(7);&#125;);console.log(8); 12// 执行顺序3 4 6 8 7 5 2 1 例2process.nextTick在node环境中，属于microtasksetImmediate在macrotasks，优先级小于setTimeout定义new Promise() 是同步代码，在栈内先执行 1234567891011121314151617181920212223242526例3const p = new Promise((res, rej) =&gt; &#123; res(1) console.log(&apos;定义new Promise - 同步&apos;)&#125;).then(val =&gt; &#123; console.log(&apos;microtask start&apos;) console.log(&apos;执行then，enqueue micarotask 1&apos;) console.log(val) // 1&#125;)Promise.resolve(&#123; then(res, rej) &#123; console.log(&apos;执行then，enqueue micarotask 2&apos;) res(5) &#125;&#125;).then(val =&gt; &#123; console.log(&apos;执行then，enqueue micarotask 3&apos;) console.log(val) // 5&#125;)console.log(&apos;逐行执行1 - 同步&apos;)console.log(&apos;逐行执行2 - 同步&apos;)console.log(3) // 3setTimeout(console.log, 0, &apos;macrotask start&apos;) // 4 setTimeout(console.log, 0, 4) // 4 执行结果如下1234567891011121314151617定义new Promise - 同步逐行执行1 - 同步逐行执行2 - 同步3// 同步队列执行完毕为空 进入下一个栈microtask start执行then，enqueue micarotask 11执行then，enqueue micarotask 2执行then，enqueue micarotask 35// microtask执行完毕为空 进入下一个栈macrotask start4// macrotask执行完毕为空 结束 例3定义new Promise是同步函数Promise.resolve等api为异步micarotask 123456789101112131415161718192021222324252627282930例4&lt;div class=&quot;outer&quot;&gt; &lt;div class=&quot;inner&quot;&gt;&lt;/div&gt;&lt;/div&gt;var outer = document.querySelector(&apos;.outer&apos;);var inner = document.querySelector(&apos;.inner&apos;);new MutationObserver(function() &#123; console.log(&apos;mutate&apos;);&#125;).observe(outer, &#123; attributes: true&#125;);function onClick() &#123; console.log(&apos;click&apos;); setTimeout(function() &#123; console.log(&apos;timeout&apos;); &#125;, 0); Promise.resolve().then(function() &#123; console.log(&apos;promise&apos;); &#125;); outer.setAttribute(&apos;data-random&apos;, Math.random());&#125;inner.addEventListener(&apos;click&apos;, onClick);outer.addEventListener(&apos;click&apos;, onClick); 123456789// 同时点击到两个div时执行结果clickpromisemutateclickpromisemutatetimeouttimeout 例4执行效果没点击前：1绑定new MutationObserver 存入浏览器资源2绑定两个div元素的click事件 存入浏览器资源 3触发outer元素click的onClick 存入浏览器资源4触发inner元素click的onClick 存入浏览器资源5先执行outer的回调6输出click7执行setTimeout - macrotask存入浏览器资源8执行outer.setAttribute(‘data-random’, Math.random())，触发MutationObserver - marcotask 等待microtask先执行9执行Promise.resolve - microtask 输出promise10microtask 执行完毕，执行MutationObserver输出mutate—–下面执行的并不是outer回调里的setTimeout——11执行inner的回调12输出inner回调的click13执行inner回调的setTimeout - macrotask存入浏览器资源14执行inner回调outer.setAttribute(‘data-random’, Math.random())，触发MutationObserver - marcotask 等待microtask先执行15执行inner回调的Promise.resolve - microtask 输出promise16microtask 执行完毕，执行MutationObserver输出mutate–最后因为两个setTimeout都是在触发inner回调后存入浏览器资源的–所以最后两个setTimeout回调完成排入队列执行.","categories":[{"name":"Font-End Basis","slug":"Font-End-Basis","permalink":"http://yoursite.com/categories/Font-End-Basis/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"Event Loop 事件循环","slug":"Event Loop 事件循环","date":"2018-01-22T04:32:59.000Z","updated":"2018-01-22T04:36:08.000Z","comments":true,"path":"2018/01/22/Event Loop 事件循环/","link":"","permalink":"http://yoursite.com/2018/01/22/Event%20Loop%20%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/","excerpt":"","text":"名词解释 “event-loop”: 事件循环“non-blocking”: 非堵塞“callback”: 回调函数“asynchronous”: 异步“single-threaded”: 单线程“concurrency”: 并发“web-api”: DOM, ajax, setTimeout… JS在浏览器中的环境先看一张图图片出自 V8引擎内的JS根据上图，首先可以得到的JS在V8引擎中有一个堆(heap)和栈(stack)的概念堆(heap): 对象被分配的区域栈(stack): 函数调用形成的栈帧 问题1: 执行JS时候发生了什么代码112345678910111213var a, bfunction foo () &#123; return a +=1&#125;function bar () &#123; return b += 2&#125;function baz () &#123; bar () foo () console.log( a + b )&#125;baz() 解释1 栈内：1执行baz() 进入栈2执行bar() 进入栈 - bar() return 退出栈3执行foo() 进入栈 - foo() return 退出栈4执行console.log 进入栈 无return并退出栈5baz() 执行完毕退出栈 JS操作WebApi根据图中WebApi所在的位置我们发现它并没有在V8引擎内，而是由stack内执行后再V8资源外层出现然后进入回调队列，并进行了一次event loop的事件 问题2: JS操作WebApi发生了什么?WebApi的执行不在V8内那在哪里?代码212345console.log('hi')setTimeout(function () &#123; console.log('ha')&#125;, 5000)console.log('heng') 解释2 栈内:1执行console.log(‘hi’) 进入栈 - 退出栈2执行setTimout 进入栈 - 把回调函数cb放入浏览器资源内(相对V8) - 退出栈3执行console.log(‘heng’)进入栈 - 退出栈4当前栈清空当前事件循环(event loop)结束 栈外:5通过while(queue.length)不停的检查队列(queue)是否为空6存放在浏览器资源内的setTimeout回调cb在5秒完成后进入队列(queue)7事件循环while(queue.length)检查到队列(queue)有回调cb8在当前循环内把cb推入栈内 栈内:9执行cb，console.log(‘ha’)进入栈 - 退出栈10清空栈 问题3: 如果setTimeout(cb, 0) 会是什么情况?代码312345console.log('hi')setTimeout(function () &#123; console.log('ha')&#125;, 0)console.log('heng') 解释3 同解释2，但是再第6步: 存放在浏览器资源内的setTimeout回调cb在5秒完成后进入队列(queue)应该变为cb直接进入队列(queue) 问题4: ajax是什么情况?代码412345console.log('hi')$.get(url, function (data) &#123; console.log(data)&#125;)console.log('heng') 解释4 同解释2，但是再第6步: 存放在浏览器资源内的setTimeout回调cb在5秒完成后进入队列(queue)应该变为ajax取得数据后cb进入队列()所以这也解释了为什么使用setTimeout来模拟ajax 问题5: WebApi中Event事件是什么情况？代码512345678console.log('start')$el.on('click', function fn() &#123; console.log('clicked')&#125;)setTimeout(function cb() &#123; console.log('timeout')&#125;, 5000)console.log('done') 解释5 栈内:1执行console.log(‘start’)进入栈 - 退出栈2执行$el.on(‘click’)进入栈 - 整个click事件包括回调函数fn放入浏览器资源内 - 退出栈3执行setTImeout 进入栈 - 把回调函数cb放入浏览器资源内 - 退出栈4执行console.log(‘done’)进入栈 - 退出栈 栈外:5通过while(queue.length)不停的检查队列(queue)是否为空6存放在浏览器资源内的setTimeout回调cb在5秒完成后进入队列(queue)7事件循环while(queue.length)检查到队列(queue)有回调cb8在当前循环内把cb推入栈内 栈内:9执行cb，console.log(‘ha’)进入栈 - 退出栈10清空栈 浏览器中:11用户点击$el触发’click’ 事件，回调函数fn进入队列中12事件循环while(queue.length)检查到队列(queue)有回调fn13在当前循环内把fn推入栈内执行并清空 问题6 - 列表滚动优化与Debounce去抖函数从问题5中可以知道，当我们连续不停的点击$el触发click时，队列(queue)内将会排满回调函数，这就是页面造成卡顿的原因。造成这种情况出现最多的就是列表滚动scroll事件, 窗口resize事件。常用的优化方法就是使用debounce去抖函数, 先看一下他的实现方法:1234567891011function debounce(fn, delay) &#123; var timer return function() &#123; var context = this var args = arguments clearTimeout(timer) timer = setTimeout(function() &#123; fn.apply(context, args) &#125;, delay) &#125;&#125; 分析debouncedebounce函数里有一个重点，就是clearTimeout(timer)现在模拟一个绑定事件1234document.addEventListener('scroll', debounce(function() &#123; console.log('scroll')&#125;, 1000), false); 当scroll事件在栈内执行回调函数被注册到浏览器资源后，当我们触发scroll事件时，我们都会把debounce(function(){console.log(&#39;scroll&#39;)}, 1000)排到队列(queue)里，在通过事件循环放入栈内执行。 如果1秒内只触发1次，那么debounce函数的回调就会因为内部的setTimeout放入浏览器资源等到1秒到后排如队列内在推入栈内执行。\b 但1秒内我们不停的触发scroll事件呢，那么debounce函数内部的clearTimeout(timer)将起到关键作用: 把前一次触发scroll事件放入浏览器资源的setTimeout回调给清空掉并放入新的setTimeout回调直到最后一次触发scroll，把浏览器资源内的setTimeout回调都清空只留下最后一个，等待1秒后回调排入队列(queue)等待推入栈内执行。 此方法相比问题5中的情况大大减少了浏览器资源的占用，使得在固定时间内队列(queue)内都只有一个回调在等待而不是一大堆。 异步执行12345678910代码1[1,2,3,4].forEach(function (i) &#123; console.log(i)&#125;)代码2[1,2,3,4].forEach(function (i) &#123; setTimeout(function (i) &#123; console.log(i) &#125;, 0, i)&#125;) 分析代码1中打印1，2，3，4 很明显它们都是直接在栈内执行console.log()输出的代码2页打印相同的结果，但是不同的是每次console.log的执行都是通过setTImeout放入队列(queue)内再推入栈内执行的，这就通过浏览器资源和V8资源的区别实现了一段异步执行的代码我们可以第二段代码改写成这样, 制作一个异步执行的forEach12345678function asyncForEach(arr, cb) &#123; arr.forEach(function (i) &#123; setTimeout(cb, 0, i) &#125;)&#125;asyncForEach([1,2,3,4], function(i) &#123; console.log(i)&#125;)","categories":[{"name":"Font-End Basis","slug":"Font-End-Basis","permalink":"http://yoursite.com/categories/Font-End-Basis/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"http 缓存","slug":"http缓存","date":"2018-01-22T04:27:35.000Z","updated":"2018-01-24T10:05:55.000Z","comments":true,"path":"2018/01/22/http缓存/","link":"","permalink":"http://yoursite.com/2018/01/22/http%E7%BC%93%E5%AD%98/","excerpt":"","text":"4种缓存方式HTTP缓存控制参考 分类和区别规定了过期时间： 响应header 描述 常用响应返回内容 推荐 特点 缺点 场景 Cache-Control 在多少秒内进行缓存 public, max-age=秒 是 固定时间 Expires 在此时间前进行缓存 格林威治时间 否 绝对时间 受客户端时间影响 兼容http1.0 需进行比较，会返回304状态码： 响应header 请求header 描述 常用响应返回内容 推荐 特点 缺点 场景 ETag If-None-Match 固定字符串 md5 是 检测文件完整性 Last-Modified If-Modified-Since 在某时间后没再更改 格林威治时间 否 浏览器根据返回的时间自己决定缓存 浏览器差异 Tips：Cache-Control与Expires一样，都是在某个时间未到来前进行缓存默认第一个请求(主页)的请求头里会自动加上Cache-Control: max-age=0，这个请求无论响应头的Cache-Control是什么设置都不会缓存，减少请求次数同时减少下载次数ETag方式通过检查request.headers里的if-None-Match里的32位md5字符串来检测文件完整性决定是否更新, 如果md5匹配成功则返回304，只减少下载次数 Cache-Control 与 Last-Modified / if-Modified-Since 比较 对于所有可以缓存的资源都可以同时使用这两种策略进行缓存Cache-Control/Expires的优先级要高于Last-Modified/ETag Cache-Control:1设置固定过期时间2文件在过期时间没到之前都不进行请求也不进行下载更新3解决方法只能通过加时间戳改变文件名解决 Last-Modified / if-Modified-Since:1通过给文件内容进行哈希算法来确定文件内容版本2通过对请求头if-Modified-Since的字符串来检测文件内容有没改变3文件内容没改变则不更新资源，跟请求资源的文件名关系不大但每次都需要请求4可以通过标识文件版本名、加长缓存时间的方式来减少304响应。 结论 1需要兼容HTTP1.0的时候需要使用Expires，不然可以考虑直接使用Cache-Control2需要处理一秒内多次修改的情况，或者其他Last-Modified处理不了的情况，才使用ETag，否则使用Last-Modified。3对于所有可缓存资源，需要指定一个Expires或Cache-Control，同时指定Last-Modified或者Etag。4可以通过标识文件版本名、加长缓存时间的方式来减少304响应。HTTP缓存控制参考 MD5hash算法任何文件或数据都可以通过MD5算法转化成一个32位的固定字符串场景：1检查缓存的文件内容是否有变化2检查下载文件是否下载完毕(cat xxx.mp4 | md5)","categories":[{"name":"http","slug":"http","permalink":"http://yoursite.com/categories/http/"}],"tags":[{"name":"http","slug":"http","permalink":"http://yoursite.com/tags/http/"}]},{"title":"flex布局","slug":"flex","date":"2018-01-22T04:02:11.000Z","updated":"2018-01-22T04:24:40.000Z","comments":true,"path":"2018/01/22/flex/","link":"","permalink":"http://yoursite.com/2018/01/22/flex/","excerpt":"","text":"flex之前 文档流布局 float + clear 相对定位 + 绝对定位 display inline-block 负margin flex特点 布局与方向无关 空间自动分配、自动对齐 适用于简单的线性布局 基本概念基本flex flex container的六个属性(父元素) 在下面demo的父元素里审查元素加上各种属性试试1flex-direction2flex-wrap &amp; flex-direction3缩写flex-flow: [direction] [wrap] 4justify-content5align-items6align-content flex item的六个属性1flex-grow2flex-shrink3flex-basis4缩写flex: [grow] [shrink] [basis]5order6align-self demo1手机页面布局topbar+main+tabs上下固定2产品列表ul&gt;li*9抛弃负margin3PC页面布局中间自适应抛弃双飞翼4完美居中 参考css-tricksflex布局-阮一峰","categories":[{"name":"css","slug":"css","permalink":"http://yoursite.com/categories/css/"}],"tags":[{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"}]},{"title":"Hello World","slug":"hello-world","date":"2018-01-21T14:02:59.000Z","updated":"2018-01-21T14:02:59.000Z","comments":true,"path":"2018/01/21/hello-world/","link":"","permalink":"http://yoursite.com/2018/01/21/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"React","slug":"React","permalink":"http://yoursite.com/categories/React/"},{"name":"http","slug":"http","permalink":"http://yoursite.com/categories/http/"},{"name":"Font-End Basis","slug":"Font-End-Basis","permalink":"http://yoursite.com/categories/Font-End-Basis/"},{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/categories/Vue/"},{"name":"css","slug":"css","permalink":"http://yoursite.com/categories/css/"},{"name":"network","slug":"network","permalink":"http://yoursite.com/categories/network/"}],"tags":[{"name":"React","slug":"React","permalink":"http://yoursite.com/tags/React/"},{"name":"http","slug":"http","permalink":"http://yoursite.com/tags/http/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/tags/Vue/"},{"name":"Redux","slug":"Redux","permalink":"http://yoursite.com/tags/Redux/"},{"name":"React Tips","slug":"React-Tips","permalink":"http://yoursite.com/tags/React-Tips/"},{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"},{"name":"dom","slug":"dom","permalink":"http://yoursite.com/tags/dom/"},{"name":"sftp","slug":"sftp","permalink":"http://yoursite.com/tags/sftp/"}]}
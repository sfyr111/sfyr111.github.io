{"meta":{"title":"Minimalist","subtitle":null,"description":null,"author":"Yang Ran","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"react 内部原理","slug":"react 内部原理 ","date":"2022-01-21T06:40:33.000Z","updated":"2023-09-23T15:00:22.403Z","comments":true,"path":"2022/01/21/react 内部原理 /","link":"","permalink":"http://yoursite.com/2022/01/21/react%20%E5%86%85%E9%83%A8%E5%8E%9F%E7%90%86%20/","excerpt":"","text":"内部原理JSX 语法、内部数据结构、协调器对比算法、算法优化的假设条件、setState 更新、合成事件、Fiber JSX 语法内部数据结构 React ElementReact.createElement 的结果12345678ReactElement &#123; _owner: null, // parent internal instance _store: Object &#123;&#125;, key: null, props: Object &#123;&#125;, ref: null, type: Function|string&#125; Public Instancecomponent 组件实例 this123456789101112131415161718192021222324Component &#123; _reactInternalInstance: ReactCompositeComponentWrapper, context: Object, props: Object, refs: Object, state: Object, updater: Object, __proto__: ReactComponent &#123; constructor: Function, componentWillMount: Function, render: Function, componentDidMount: Function, componentWillReceiveProps: Function, shouldComponentUpdate: Function, componentWillUpdate: Function, componentDidUpdate: Function, componentWillUnmount: Function, __proto__: &#123; constructor: Function, forceUpdate: Function, setState: (partialState, callback) &#125; &#125;&#125; Internal Instance组件的额外信息123456789101112131415161718192021222324252627282930313233343536373839404142ReactCompositeComponent &#123; _compositeType: Impure|Pure|StatelessFunctional, _context: Object, _currentElement: ReactElement, _instance: ***Public Instance***, _isOwnerNecessary: false, _mountImage: null, _mountIndex: 0, _mountOrder: 2, _pendingCallbacks: null, _pendingElement: null, _pendingStateQueue: null, _renderedComponent: ***ReactDOMComponent***, _rootNodeID: &quot;.0&quot;, _topLevelWrapper: ***ReactCompositeComponentWrapper***, _warnedAboutRefsInRender: false&#125;ReactCompositeComponent.prototype &#123; _checkPropTypes: Function, _instantiateReactComponent: Function, _maskContext: Function, _performComponentUpdate: Function, _processChildContext: Function, _processContext: Function, _processPendingState: Function, _processProps: Function, _renderValidatedComponent: Function, _renderValidatedComponentWithoutOwnerOrContext: Function, _replaceNodeWithMarkupByID: Function, _updateRenderedComponent: Function, attachRef: Function, construct: Function, constructor: Function, detachRef: Function, getName: Function, getPublicInstance: Function, mountComponent: Function, performUpdateIfNecessary: Function, receiveComponent: Function, unmountComponent: Function, updateComponent: Function,&#125; Rendered Componentcomponent 组件实例 render 方法的返回结果 ReactDOM1234567891011121314151617ReactDOMComponent &#123; _currentElement: ReactElement _isOwnerNecessary: false _mountImage: null _mountIndex: 0 _nodeWithLegacyProperties: null _previousStyle: null _previousStyleCopy: null _processedContextDev: Object _renderedChildren: null _rootNodeID: &quot;.0&quot; _tag: &quot;div&quot; _topLevelWrapper: null _unprocessedContextDev: Object _warnedAboutRefsInRender: false _wrapperState: null&#125; 协调器算法(对比算法) 标记组件 dirty 是否需要更新 渲染所有实例等待更新 通过 对照变化 reconcile change 构建 新的变化 mutation list（new fiber tree） 更新 DOM 对比算法的优化https://www.zhihu.com/question/66851503两颗 tree diff 遍历比较差异 O(n2) 再计算最小转化成本还要遍历一次，就是O(n3)。 react 通过假设只要遍历一遍 O(n)： 不同类型的元素不需要比较，直接删除 元素不能垂直移动 列表通过 key 进行重用 setState只有 setState 和 ReactDOM.render 能触发更新 从 setState 调用到 DOM更新的完整内部生命周期 batchedUpdates1234567891011121314function batchedUpdates&lt;A, R&gt;(fn: (a: A) =&gt; R, a: A): R &#123; const previousIsBatchingUpdates = isBatchingUpdates; // 初始为 false isBatchingUpdates = true; try &#123; return fn(a); // 执行组件绑定的方法, 走到 requestWork 里 &#125; finally &#123; // setState 最终 enqueueUpdates 全部走到 requestWork 后变回 false 再一同 performSyncWork 才真正的执行并改变 state isBatchingUpdates = previousIsBatchingUpdates; // 变回 false // 如果是 setTimeout(() =&gt; &#123; this.setState &#125;) setTimeout 走到这里后才执行 this.setState 这时上下文环境是 window isBatchingUpdates 已经 false，setState 就是同步的 if (!isBatchingUpdates &amp;&amp; !isRendering) &#123; performSyncWork(); // 当所有 setState 执行完全部enqueueUpdates 后代替 requestWork 来调度 &#125; &#125;&#125; requestWork123456789101112131415161718192021222324252627function requestWork(root: FiberRoot, expirationTime: ExpirationTime) &#123; addRootToSchedule(root, expirationTime); // 把当前 root设置为最高优先级 // isRendering 调度已经在执行了, 循环已经开始了 if (isRendering) &#123; return; &#125; // 批量处理相关 // 调用 setState 时在 enqueueUpdates 前 batchedUpdates 会把 isBatchingUpdates 设置成 true if (isBatchingUpdates) &#123; // Flush work at the end of the batch. if (isUnbatchingUpdates) &#123; // unbatchedUpdates API 调用 // ...unless we&#x27;re inside unbatchedUpdates, in which case we should // flush it now. nextFlushedRoot = root; nextFlushedExpirationTime = Sync; performWorkOnRoot(root, Sync, true); &#125; return; // isBatchingUpdates true // 普通的 setState 在进入 enqueueUpdates 时在这里直接不执行了，下面其实没进入调度 &#125; // TODO: Get rid of Sync and use current time? if (expirationTime === Sync) &#123; // 同步的调用 js 代码 performSyncWork(); &#125; else &#123; // 异步调度 独立的 react 模块包，利用浏览器有空闲的时候进行执行，设置 deadline 在此之前执行 scheduleCallbackWithExpirationTime(root, expirationTime); // 在 secheduler 文件夹下的单独模块 &#125; 合成事件 事件跨浏览器跨平台兼容 事件池便于事件对象复用 document 顶层事件委托 react 17 改成 root 委托 event.persist() v16版本https://deepscan.io/docs/rules/react-missing-event-persist event poolreact v17 不再使用事件池，现代浏览器不需要重用不同事件之间的事件对象以提高旧浏览器的性能，并将它们之间的所有事件字段设置为 null。https://stackoverflow.com/questions/36114196/what-is-event-pooling-in-react/36115815 Fiberhttps://stackoverflow.com/questions/45341423/what-is-difference-between-react-vs-react-fiber 什么是 fiberFiber 是重新实现了 reconciler 更新机制的新架构。一种虚拟堆栈帧，每个 fiber 都是一个任务一个帧。可暂停&#x2F;可优先&#x2F;可记忆&#x2F;可中止本身不关心渲染，尽管 renderers 需要更改以支持并利用 fiber。 为什么用 fiber 动画、用户输入（动画流畅、UI 响应）， 需要主线程 16ms 运行一次，当 script 执行任务时就会阻塞主线程直到 script 任务完成。 16版本之前的协调器算法一旦开始就停止不了，很大程度上 reconciler 依赖于递归调用, 所以很难使它停止再继续。1234567891011121314151617181920212223function reconcile(parentDom, instance, element) &#123; if (instance == null) &#123; // Create instance // .. return newInstance; &#125; else if (instance.element.type === element.type) &#123; // Update instance //.. instance.childInstances = reconcileChildren(instance, element); return instance; &#125; else &#123; // Replace instance .. &#125;&#125;function reconcileChildren(instance, element) &#123; //... for (let i = 0; i &lt; count; i++) &#123; //... const newChildInstance = reconcile(dom, childInstance, childElement); // reconcile 递归 &#125; return newChildInstances;&#125; 通过重写协调器算法，可以确定工作的优先级并加快整体帧速率。基于 fiber 的reconciler 更新 fiber 结构关系 fiber 优先级12345678ReactPriorityLevel &#123; NoWork: 0, // No work is pending. SynchronousPriority: 1, // For controlled text inputs. Synchronous side-effects. AnimationPriority: 2, // For controlled text inputs. Synchronous side-effects. HighPriority: 3, // Interaction that needs to complete pretty soon to feel responsive. LowPriority: 4, // Data fetching, or result from updating stores. OffscreenPriority: 5, // Won&#x27;t be visible but do the work in case it becomes vis&#125;; fiber 会出现的问题 componentWillUpdate 可能在 componentDidUpdate 之前被多次调用 没有哪个帧会保证何时会发生更新 可暂停&#x2F;可优先&#x2F;可记忆&#x2F;可中止导致 在 async mode 模式下，组件更新&#x2F;渲染可能会被推迟，因此 react 可以提供一些高优先级的东西。这意味着每次 react 开始在你的组件上工作时都会调用 willUpdate，但它可能不会完成完整的更新，因此每次它开始在这个组件上工作时都会调用 willUpdate，但只会在这个过程完成后调用一次 didUpdate。https://stackoverflow.com/questions/54533907/react-componentwillupdate-getting-called-twice从 v16.3.0 开始，componentWillUpdate 命周期方法已被弃用，鼓励在 componentDidUpdate 中处理任何副作用，这将在 render 方法之后触发 参考https://github.com/pomber/didact","categories":[{"name":"react","slug":"react","permalink":"http://yoursite.com/categories/react/"}],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"}]},{"title":"React 合成事件 SyntheticEvent","slug":"React 合成事件 SyntheticEvent ","date":"2020-05-04T10:41:35.000Z","updated":"2023-09-23T15:00:39.595Z","comments":true,"path":"2020/05/04/React 合成事件 SyntheticEvent /","link":"","permalink":"http://yoursite.com/2020/05/04/React%20%E5%90%88%E6%88%90%E4%BA%8B%E4%BB%B6%20SyntheticEvent%20/","excerpt":"","text":"合成事件在 react 中的机制1.原生事件冒泡到 document2.document 执行事件监听回调，把原生事件在 dispatchEvent 里派发合成事件3.通过 event.target 找到组件和元素4.dispatchEvent 中执行 batchUpdate batchUpdate (fn, a) =&gt; fn(a), fn 是组件元素绑定的方法，a 是 event 合成事件实例5.react 会在事件池 eventPool 中重复使用 event 实例。 React事件初探 为什么要用合成事件 浏览器兼容，顶层事件代理机制，能报保证事件冒泡一致性，可以跨浏览器执行 更好的跨平台，不同平台事件模拟成合成事件 document 事件代理只在内存中开辟了一块空间，节省资源同时减少了dom操作，提高性能 对于新添加的元素也会有之前的事件 避免频繁解绑, 只在组件销毁时解绑 方便事件的统一管理和事务机制 react 合成事件流程 合成事件在 react 中的表现合成事件对象模拟了 event.preventDefault event.stopPropagation 方法，同时为了提高性能在事件池重复使用 event 对象，每次重复使用后都会把 event 对象信息清空，在 setState 和异步 api 中可以使用 event.persist 方法或暂存值 onChange=&#123;(&#123; value &#125;) =&gt; handle(value)&#125; 的方式获取正确的属性。Synthetic Events in Reactevent.persist()React SyntheticEvent reuse官方 event-pooling 应用示例 合成事件源码分析dispatch 分发事件顶层监听 123456789101112131415161718export function trapBubbledEvent( topLevelType: DOMTopLevelEventType, element: Document | Element,) &#123; if (!element) &#123; return null; &#125; const dispatch = isInteractiveTopLevelEventType(topLevelType) ? dispatchInteractiveEvent : dispatchEvent; // 原生 dom 事件监听 addEventBubbleListener( element, // document 对象 getRawEventName(topLevelType), // Check if interactive and wrap in interactiveUpdates dispatch.bind(null, topLevelType), );&#125; dispatchEvent, 这里的 bookkeeping 是重用的，与 eventpool 重用相似。 123456789101112131415161718192021222324252627282930313233343536export function dispatchEvent( topLevelType: DOMTopLevelEventType, nativeEvent: AnyNativeEvent,) &#123; if (!_enabled) &#123; return; &#125; const nativeEventTarget = getEventTarget(nativeEvent); // 找到 event.target 触发事件的元素 let targetInst = getClosestInstanceFromNode(nativeEventTarget); // 找到 fiber 实例 if ( targetInst !== null &amp;&amp; typeof targetInst.tag === &#x27;number&#x27; &amp;&amp; !isFiberMounted(targetInst) ) &#123; // If we get an event (ex: img onload) before committing that // component&#x27;s mount, ignore it for now (that is, treat it as if it was an // event on a non-React tree). We might also consider queueing events and // dispatching them after the mount. targetInst = null; &#125; // 复用 bookKeeping，保存了事件触发的相关实例信息 const bookKeeping = getTopLevelCallbackBookKeeping( topLevelType, nativeEvent, targetInst, ); try &#123; // Event queue being processed in the same cycle allows // `preventDefault`. batchedUpdates(handleTopLevel, bookKeeping); // 批量处理的方式进行分发 &#125; finally &#123; releaseTopLevelCallbackBookKeeping(bookKeeping); // 推入 pool &#125;&#125; batchedUpdates(handleTopLevel, bookKeeping); 中的 handleTopLevel 1234567891011121314// EventPluginHub.jsfunction handleTopLevel(bookKeeping) &#123; let targetInst = bookKeeping.targetInst; // ... 确定 bookKeeping 上的组件信息 for (let i = 0; i &lt; bookKeeping.ancestors.length; i++) &#123; targetInst = bookKeeping.ancestors[i]; runExtractedEventsInBatch( // 在触发的组件实例上执行批量事件 bookKeeping.topLevelType, targetInst, bookKeeping.nativeEvent, getEventTarget(bookKeeping.nativeEvent), // 统一不同浏览器的事件名 ); &#125;&#125; runExtractedEventsInBatch 最终会执行到 executeDispatchesAndRelease 方法 12345678910111213141516171819/** * Dispatches an event and releases it back into the pool, unless persistent. * dispatch 事件并将其释放回池中，除非是持久的。 * @param &#123;?object&#125; event Synthetic event to be dispatched. * @param &#123;boolean&#125; simulated If the event is simulated (changes exn behavior) * @private */const executeDispatchesAndRelease = function( event: ReactSyntheticEvent, simulated: boolean,) &#123; if (event) &#123; executeDispatchesInOrder(event, simulated); // 如果合成事件没有 persist ， 才推入到 eventPool 中进行复用 if (!event.isPersistent()) &#123; event.constructor.release(event); &#125; &#125;&#125;; SyntheticEvent 合成事件对象SyntheticEvent.js 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253function SyntheticEvent( dispatchConfig, targetInst, nativeEvent, nativeEventTarget,) &#123; // ... persist: function() &#123; this.isPersistent = functionThatReturnsTrue; &#125;, isPersistent: functionThatReturnsFalse,// ...function getPooledEvent(dispatchConfig, targetInst, nativeEvent, nativeInst) &#123; const EventConstructor = this; if (EventConstructor.eventPool.length) &#123; // 重用合成事件 const instance = EventConstructor.eventPool.pop(); EventConstructor.call( instance, dispatchConfig, targetInst, nativeEvent, nativeInst, ); return instance; &#125; return new EventConstructor( // 如何合成事件持久化了则创建新的合成事件 dispatchConfig, targetInst, nativeEvent, nativeInst, );&#125;// 只在未持久化 isPersistent 为 false 才用到function releasePooledEvent(event) &#123; const EventConstructor = this; invariant( event instanceof EventConstructor, &#x27;Trying to release an event instance into a pool of a different type.&#x27;, ); event.destructor(); // 重置合成事件，属性全设置为 null if (EventConstructor.eventPool.length &lt; EVENT_POOL_SIZE) &#123; EventConstructor.eventPool.push(event); // &#125;&#125;function addEventPoolingTo(EventConstructor) &#123; EventConstructor.eventPool = []; // 事件池 EventConstructor.getPooled = getPooledEvent; // 获取事件池事件进行使用和复用 EventConstructor.release = releasePooledEvent; // 发布事件到事件池中&#125;&#125;export default SyntheticEvent; 总结合成事件是 react 模拟原生 dom 事件所有能力的一个事件对象，用于兼容浏览器方便 react 统一管理。 react 合成事件是通过模拟不同浏览器事件差异，顶层监听在 document 上保证了事件冒泡的统一性。 当事件原生 dom 事件触发冒泡至 document 时，react 通过 event.target 找到事件触发的组件实例，并 dispatchEvent 派发合成事件 event ，把 event 通过 batchUpdates 交由绑定事件的处理函数。 react 会重复使用合成 event，如果 event 已经 persisted 则不会推入 eventPool 中每次处理 handle 时都会重新生成一个 event。 react 合成事件兼容模拟浏览器事件差异，使用事件代理方式节省了内存只开辟一块空间，在组件销毁时解绑，避免频繁解绑方便事件的统一管理。","categories":[{"name":"react","slug":"react","permalink":"http://yoursite.com/categories/react/"}],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"}]},{"title":"Vue3 为什么要用 Proxy 代替 Object-defineProperty 实现响应式","slug":"Vue3 为什么要用 Proxy 代替 Object.defineProperty 实现响应式 ","date":"2020-04-19T15:30:02.000Z","updated":"2023-09-26T13:50:26.246Z","comments":true,"path":"2020/04/19/Vue3 为什么要用 Proxy 代替 Object.defineProperty 实现响应式 /","link":"","permalink":"http://yoursite.com/2020/04/19/Vue3%20%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8%20Proxy%20%E4%BB%A3%E6%9B%BF%20Object.defineProperty%20%E5%AE%9E%E7%8E%B0%E5%93%8D%E5%BA%94%E5%BC%8F%20/","excerpt":"","text":"Object.defineProperty 劫持数据 只是对对象的属性进行劫持 无法监听新增属性和删除属性需要使用 vue.set, vue.delete 深层对象的劫持需要一次性递归1234567var obj = &#123; a: 1, o: &#123; b: 2, o1: &#123;&#125; &#125;&#125; 劫持数组时需要重写覆盖部分 Array.prototype 原生方法 Proxy 劫持数据 真正的对对象本身进行劫持 可以监听到对象新增删除属性 只在 getter 时才对对象的下一层进行劫持(优化了性能) 能正确监听原生数组方法 无法 polyfill 存在浏览器兼容问题 Object.defineProperty 实现响应式123456789101112131415161718192021222324252627282930313233343536373839404142function defineReactive(target, key, value) &#123; observer(value) // 对 value 深层监听 Object.defineProperties(target, key, &#123; get() &#123; // dep.addSubs(watcher) // 添加到监听队列 return value &#125;, set(newValue) &#123; if (newValue !== value) &#123; observer(newValue) // 再次劫持新 value value = newValue // dep.notify() // 通知依赖触发监听队列的更新 &#125; &#125; &#125;)&#125;function observer(target) &#123; if (typeof target !== &#x27;object&#x27; || !target) &#123; return target &#125; if (Array.isArray(target)) &#123; target.__proto__ = newArrProto &#125; for (let key of target) &#123; defineReactive(target, key, target[key]) &#125;&#125;const oldArrProto = Array.prototypeconst newArrProto = Object.create(oldArrProto)[&#x27;push&#x27;, &#x27;pop&#x27;, &#x27;shift&#x27;, &#x27;unshift&#x27;, &#x27;splice&#x27;, &#x27;sort&#x27;, &#x27;reverse&#x27;].forEach(methodName =&gt; &#123; newArrProto[methodName] = function(...args) &#123; // dep.notify() oldArrProto[methodName].apply(this, args) &#125;&#125;) Dep 和 Watcher 具体实现可以参考之前的文章 实现响应式原理 Object.defineProperty 缺点 无法监听新增属性和删除属性需要使用 vue.set, vue.delete 深层对象的劫持需要一次性递归1234567891011function observer(target) &#123; ... for (let key of target) &#123; defineReactive(target, key, target[key]) &#125;&#125;function defineReactive(target, key, value) &#123; observer(target) // 首次监听时就对 value 的属性进行递归 ...&#125; 监听原生数组的部分方法需要重写覆盖 Array.prototype[&#39;push&#39;, &#39;pop&#39;, &#39;shift&#39;, &#39;unshift&#39;, &#39;splice&#39;, &#39;sort&#39;, &#39;reverse&#39;] 会改变原数组的原生方法不会被 Object.defineProperty 劫持，需要重新写数组的原生方法添加更新触发 Proxy 实现响应式123456789101112131415161718192021222324252627282930313233343536373839function reactive(target = &#123;&#125;) &#123; if (typeof target !== &#x27;object&#x27; || target == null) &#123; return target &#125; const proxyConfig = &#123; get(target, key, receiver) &#123; const ownKeys = Reflect.ownKeys(target) if (ownKeys.includes(key)) &#123; // dep.subs(watcher) // 添加监听 &#125; const result = Reflect.get(target, key, receiver) return reactive(result) // 只在 getter 时才再次劫持 &#125;, set(target, key, val, receiver) &#123; if (val === target[key]) &#123; return &#125; const ownKeys = Reflect.ownKeys(target) if (ownKeys.includes(key)) &#123; // 已有值 &#125; else &#123; // 新增值 &#125; const result = Reflect.set(target, key, val, receiver) // dep.noitfy() // 通知监听队列进行更新 return result &#125;, deleteProperty(target, key) &#123; const result = Reflect.deleteProperty(target, key) return result &#125; &#125; const observed = new Proxy(target, proxyConfig) return observed&#125; Proxy 解决的问题 可以监听到对象新增删除属性 只在 getter 时才对对象的下一层进行劫持(优化了性能)12345678get(target, key, receiver) &#123; const ownKeys = Reflect.ownKeys(target) if (ownKeys.includes(key)) &#123; // dep.subs(watcher) // 添加监听 &#125; const result = Reflect.get(target, key, receiver) return reactive(result) // 只在 getter 时才再次劫持&#125;, 能正确监听原生数组方法 总结Object.defineProperty 是对对象属性的劫持Proxy 是对整个对象劫持 Object.defineProperty 无法监听新增和删除Object.defineProperty 无法监听数组部分方法需要重写Object.defineProperty 性能不好要对深层对象劫持要一次性递归 Proxy 能正确监听数组方法Proxy 能正确监听对象新增删除属性Proxy 只在 getter 时才进行对象下一层属性的劫持 性能优化Proxy 兼容性不好 Object.defineProperty 和 Proxy在 getter 时进行添加依赖 dep.addSub(watcher) 比如 绑定 view 层，在函数中使用在 setter 时触发依赖通知 dep.notify() 比如 修改属性","categories":[],"tags":[]},{"title":"浏览器输入 URL 到页面呈现及其优化","slug":"浏览器输入 URL 到页面呈现及其优化 ","date":"2019-10-30T08:33:09.000Z","updated":"2023-09-26T13:48:54.189Z","comments":true,"path":"2019/10/30/浏览器输入 URL 到页面呈现及其优化 /","link":"","permalink":"http://yoursite.com/2019/10/30/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5%20URL%20%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%91%88%E7%8E%B0%E5%8F%8A%E5%85%B6%E4%BC%98%E5%8C%96%20/","excerpt":"","text":"输入 url: 浏览器先检查缓存，然后解析本地-路由器-全网 dns，指向服务器 ip 强缓存 request Cache-Control1.max-age&#x3D;0，只 if-none-match 协商 etag 的 hash2.no-cache, 都不缓存 强缓存 response Cache-Control1.max-age&#x3D;0, no-cache, 只 etag 对 if-none-match 协商 hash2.no-store 都不缓存 隐私 DNS 缓存1.浏览器缓存的 dns2.本机 host 文件的映射3.路由器的映射4.网络服务商的映射 (本地DNS服务器为止)5.root 域名服务器6.顶级域名-主域名服务器-结果缓存在本地DNS服务器 默认访问 http 重定向到 httpsHSTS 策略: response headers: Strict-Transport-Security: max-age&#x3D;31536000 把所有请求都访问为 https，首次访问不知道配置可以注册在公网上。 请求远程服务器: 建立 TLS 连接2次RTT， TCP 三次握手RTT，nginx 转发到对应的资源上，服务器检查缓存 优化 TLS 2次 RTT, 浏览器缓存对称密钥1.client 发送 k1 和加密方案列表2.server 发送 k2、证书、公钥、确定的加密方案3.client 验证证书、公钥加密 k3 发送4.server 密钥解 k35.client server 使用 k1 k2 k3 对称加密通信123ssl_session_tickets on;ssl_session_ticket_key current.key;ssl_session_ticket_key previous.key; 优化 TCP 三次握手 RTT request header：connection: keep-alive 重用 TCP 连接 管线化 http 1.1 keep-alive 基础上 请求一次发出 响应按顺序 还是有阻塞可能 管线化和多路复用区别 管线化在 keep-alive 基础上复用 TCP 3次握手 管线化一次发送多个请求返回仍是一个个的顺序不变 多路复用是 http2 多个请求响应都是并行 服务器断开连接的四次挥手 客户端请求断开连接 服务端确认断开请求 服务端发送完毕剩下的数据 close 客户端close 回复 浏览器检查状态码，304 协商缓存，301，302 重定向 304 req:if-none-match, res:etag 协商 hash 301 永久重定向会浏览器缓存 302 临时重定向浏览器不缓存 解析返回内容，重排重绘 页面生成过程 html 解析成 dom 树 css 解析成 cssom 结合 dom 树和 cssom 生成 render tree 进行布局 flow 将 渲染树的 节点进行合成 进行绘制 paint 至屏幕上 文档解析过程的事件触发1 开始解析 html 文档触发 readystatechange: load2 DOMContentLoaded 事件，原始 html 解析不包含样式资源加载, 同时触发 readystatechange: interactive3 load 事件，资源加载完毕样式资源加载完毕后才触发, 同时触发 readystatechange: complete defer async 资源的script 都不阻塞，普通 script 下载阻塞再执行阻塞defer 先下载 html 解析完后执行，没什么阻塞async 下载好后直接执行，阻塞执行阶段 重排1.dom 的增删改查2.浏览器窗口的变化滚动3.用户的输入4.dom的形状大小动画5.重排必定发生重绘6.影响范围大，最好固定 dom 容器大小不影响到其他 dom 重绘1.dom 的颜色背景2.dom border 样式 如圆角内陷3.每次重绘前执行 requestAnimationFrame 重排重绘优化 目标 dom 父容器固定大小，重排不会影响其他 dom 12345678// 改变 p 里的 dom 也会影响 h5 和 h4，固定 p 的大小&lt;body&gt; &lt;div class=&quot;hello&quot;&gt; &lt;h4&gt;h4&lt;/h4&gt; &lt;p&gt;&lt;strong&gt;Name:&lt;/strong&gt;BDing&lt;/p&gt; &lt;h5&gt;h5&lt;/h5&gt; &lt;/div&gt;&lt;/body&gt; 读写操作分离 123456789// 只发生一次重绘重排, 读取操作在写入操作完成后才进行, 有的浏览器低下仍会进行4次div.style.left = &#x27;10px&#x27;;div.style.top = &#x27;10px&#x27;;div.style.width = &#x27;20px&#x27;;div.style.height = &#x27;20px&#x27;;console.log(div.offsetLeft);console.log(div.offsetTop);console.log(div.offsetWidth);console.log(div.offsetHeight); 样式集中改变 123// 使用添加 className 和 cssText 的方式一次操作el.className += &quot; otherclass&quot;el.style.cssText += &quot;; left: &quot; + left + &quot;px; top: &quot; + top + &quot;px;&quot;; 缓存布局信息 12345678// bad 同时又读写操作 强制刷新 触发两次重排div.style.left = div.offsetLeft + 1 + &#x27;px&#x27;;div.style.top = div.offsetTop + 1 + &#x27;px&#x27;;// good 缓存布局信息 读写分离var curLeft = div.offsetLeft;var curTop = div.offsetTop;div.style.left = curLeft + 1 + &#x27;px&#x27;;div.style.top = curTop + 1 + &#x27;px&#x27;; dom 离线更改 1234567891011dom.display = &#x27;none&#x27;// 修改dom样式dom.display = &#x27;block&#x27;----const fragment = document.createDocumentFragment();// DocumentFragment 上批量操作 domlist.appendChild(fragment);----复制 dom，操作完后替换掉原 domvar p = document.getElementById(&quot;para1&quot;),var p_prime = p.cloneNode(true); 绝对定位 固定定位position属性为absolute或fixed 的dom 重排消耗小 优化动画动画移动 1px 增加为 3px 减少 重排启动 GPU 操作 react 调度优化 调度模块原理 - 实现 requestIdleCallback \u001c 重绘的一帧 16.67，性能低是 33.33 rAF 计算出当前帧开始时间和下一帧开始时间 把 react 更新任务推入 addEventLisnter 队列中 每一帧更新顺序：队列 react 任务 -&gt; UI 渲染动画 -&gt; idle 回调 每一次循环队列开始根据 react 任务过期时间判断是否过期，过期了执行 react 更新，再执行 UI 操作 参考","categories":[],"tags":[]},{"title":"React 源码解析 - commitRoot 更新任务 dom 节点","slug":"React 源码解析 - commitRoot 更新任务 dom 节点 ","date":"2019-08-23T08:35:46.000Z","updated":"2023-09-19T15:19:01.517Z","comments":true,"path":"2019/08/23/React 源码解析 - commitRoot 更新任务 dom 节点 /","link":"","permalink":"http://yoursite.com/2019/08/23/React%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%20-%20commitRoot%20%E6%9B%B4%E6%96%B0%E4%BB%BB%E5%8A%A1%20dom%20%E8%8A%82%E7%82%B9%20/","excerpt":"","text":"commitRoot 三个阶段 准备 commit 阶段 commit 阶段的三次循环 commit 后收尾工作 commitRoot 准备阶段核心任务 标记全局变量, 保存 root.pendingCommitExpirationTime 正在等待提交的任务的 expirationTime 标记 fiberRoot 子树最早更新时间 root.nextExpirationTimeToWorkOn 和 root.expirationTime 检查 finishedWork 是否也有 effect ，如有插入 effect 链表中 标记全局变量 标记 fiberRoot 的 markCommittedPriorityLevels 方法主要是找到子树中 NoWork 的节点，对 任务完成后剩余时间 root.nextExpirationTimeToWorkOn 和 root.expirationTime 进行更新，同时更新 root 下子树最早更新和最晚更新的 [ root.earliestPendingTime, root.latestPendingTime ] 区间 检查 finishedWork 是否也有 effect ，如有插入 effect 链表中finishedWork 就是当前 commit 处理的任务 effectTag 列表 根据 finishedWork 自身是否有 effect 构建成最后的 nextEffect 链表 commitRoot 第一次循环执行核心任务在 class 组件中通过 prevProps, prevState 获取状态快照，用于 componentDidUpdate 生命周期状态快照的获取通过 getSnapshotBeforeUpdate 生命周期 (旧 componentWillUpdate) 执行后的返回值这个循环中，这个节点即将更新但是还没更新。 getSnapshotBeforeUpdate 生命周期 componentDidUpdate 第三个参数的 snapshot 就是 getSnapshotBeforeUpdate 的返回值 commitBeforeMutationLifecyclescommitRoot 的第一次循环主要是对 nextEffect 链表的任务执行 commitBeforeMutationLifecycles commitBeforeMutationLifecycles 根据 nextEffect.effectTag 是否有 Snapshot 把 nextEffect.alternate fiber 对象和 nextEffect 传入 commitBeforeMutationLifeCycles 中 commitBeforeMutationLifeCycles 中只有在更新任务是 classComponent 时才有工作，根据 current(nextEffect.alternate) 是否存在判断是否是初次加载，组件初次加载执行 DidMount 生命周期函数不走 DidUpdate 不需要保存快照对象，最后快照对象保存在 instance.__reactInternalSnapshotBeforeUpdate 上 commitRoot 第二次循环执行核心任务重置文本节点操作 ref执行 插入、更新、删除的 effect 操作真正的对 dom 进行操作 commitAllHostEffects对 nextEffects 链表任务开始第二次循环 commitAllHostEffects 中对不同 effectTag 进行不同操作 commitPlacement 插入节点 首先通过 getHostParentFiber 找到 finishedWork 的父节点 parentFiber 再从 finishedWork 当前 commit 的节点开始进行深度优先遍历 parentFiber 有 HostComponent(dom 标签)、HostRoot(fiberRoot)、HostPortal(portal api) 操作 dom 使用 insertBefore api 找到需要操作 insertBefore 的 dom 节点 before 当遍历到 class 组件时候，before 通过 node.child 指定 从 finishedWork 开始遍历三种类型的 node.tag 进行操作，有 before 进行 insertBefore，没有 before 进行 append 如果遍历的 node.tag 不是上面三种类型，还有 node.child, 那就是 class 组件，这时 node &#x3D; node.child 开始下一次循环，因为这里 class 组件的操作就是对 child, 组件第一个包裹的 dom 标签操作 commitWork 更新节点 commitWork 只会更新 HostComponent(dom 节点) 和 HostText(文本节点) 对于更新 HostComponent 会从当前任务 finishWork 中取出 updateQueue 、newProps、oldProps、和 dom 内容传入 commitUpdate 中更新到 dom 上 通过 commitUpdate 更新 dom 属性 updateProperties 对属性进行 diff updateDOMProperties 把 updateQueue: [k1, v1, k2, v2] 结构的内容进行更新 commitDeletion 删除节点 commitDeletion 对子树进行深度优先遍历标记变量，标记所有要处理节点 tag，遇到 HostComponent 节点进行 commitNestedUnmounts 然后删除节点, 遇到 HostPortal 继续循环删除 portal 内的内容, 都不满足条件就是 class 组件，直接 commitUnmount。 commitNestedUnmounts 遍历内容进行 commitUnmount commitUnmount 卸载 ref， 执行 componentWillUnmount 生命周期 commitRoot 第三次循环执行核心工作首次渲染执行\bcomponentDidMount更新渲染执行 componentDidUpdate执行 setState 的 callback 回调函数捕获错误 源码流程 执行 commitAllLifeCycles commitAllLifeCycles commitLifeCycles 根据 current 来判断首次渲染和更新渲染执行不同的生命周期，最后执行 commitUpdateQueue commitUpdateQueue 会找到此次更新 setState 的回调进行执行，当更新中有捕获错误的回调函数也会在这里执行 回顾一下捕获错误的回调为啥在这里有执行 commitLifeCycles HostRoot 在 ReactDOM.render 中的操作 commitRoot 收尾工作结束 commitRoot 还原变量，通知 开发工具，如果生命周期中产生了新的更新会更新 rooFiber 树的子树中的更新最早最晚区间","categories":[],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"}]},{"title":"React 源码解析 - renderRoot 完成节点更新任务","slug":"React 源码解析 - renderRoot 完成节点更新任务 ","date":"2019-06-21T10:08:07.000Z","updated":"2023-09-19T15:18:36.792Z","comments":true,"path":"2019/06/21/React 源码解析 - renderRoot 完成节点更新任务 /","link":"","permalink":"http://yoursite.com/2019/06/21/React%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%20-%20renderRoot%20%E5%AE%8C%E6%88%90%E8%8A%82%E7%82%B9%E6%9B%B4%E6%96%B0%E4%BB%BB%E5%8A%A1%20/","excerpt":"","text":"completeUnitOfWork当 beginWork 遍历到 fiber 树的单侧最下方时 next 为 null，这时候就会调用 completeUnitOfWork 完成节点并按遍历顺序设置新的 next 进行操作 performUnitOfWork 遍历 fiber 树的顺序 核心功能 根据是否中断调用不同的处理方法 当一侧的子节点被 beginWork 更新组件完了执行 beginWork 完成各个组件的 update，然后返回他的 child 判断是否有兄弟节点来执行不同的操作 完成节点之后复 effect 链 completeUnitOfWork 没有报错的处理流程 当 workInProgress.effectTag 标记的不是 Incomplete，没有错误捕获1if ((workInProgress.effectTag &amp; Incomplete) === NoEffect) &#123; //.. &#125; completetWork 完成节点更新 resetChildExpirationTime 重置 childExpirationTime 构建 effect 链 按照遍历 fiber 树的顺序确定下 next 节点 resetChildExpirationTime 重置 workInProgress.childExpirationTime 在 completeWork 完成节点更新后执行 重置的是 workInProgress 上的 childExpirationTime 属性 在当前节点上找到子节点把所有子节点中不是 NoWork 的最早过期时间赋值给当前节点的 childExpirationTime childExpirationTime 来表示当前节点所有子节点中最高的更新的优先级 completeWork 完成节点更新核心功能 pop 出各种 context 相关功能 对 HostComponent 进行初始化 初始化监听事件 对大部分 tag 不进行操作或者只是 pop context 只有 HostComponent, HostText, SuspenseComponent 有操作 HostComponent tag 的更新tag 为 HostComponent 表示普通 dom 节点，如: div 核心功能 diffProperties 计算需要更新的内容 vdom 进行对比是否真的要更新 不同 dom property 处理方式不同 根据 current 原 fiber 节点和 workInProgress.stateNode 当前 dom 判断首次渲染还是更新渲染 初始更新 createInstance 根据当前更新的节点创建新的 dom 对象并记录创建的 fiber 和 props 属性 appendAllChildren 构建 dom 树，遍历顺序是从底向上只构建第一层的 child, child.sibling finalizeInitialChildren 初始化属性，初始化事件监听 markUpdate 标记 effect &#x3D; UPDATE，在 workInProgress.stateNode 上记录 instance createInstance 创建 dom 创建 dom 节点 在 dom 节点对象上记录此次创建的 fiber 和 props 信息 createElement 创建 dom 对象 appendAllChildren 构建 dom 树构建 dom 树， 都是 append 第一层 child 和 child.sibling，不会 append 嵌套的，嵌套的会在他自己是 workInProgress 时 append finalizeInitialChildren 初始化属性，初始化事件监听 事件监听初始化 执行 setInitialProperties 返回 shouldAutoFocusHostComponent 告知是否需要 auto focus switch 必要标签的操作 绑定事件 trapBubbledEvent, 区分事件类型实现不同的事件绑定 input option select textarea 交互组件有不同的操作 执行 setInitialProperties 对应不同标签绑定事件 再执行 setInitialDOMProperties12345678// ... setInitialDOMProperties( tag, domElement, rootContainerElement, props, isCustomComponentTag, ); setInitialDOMProperties 设置属性和事件绑定 ensureListeningTo 事件绑定 listenTo 进行绑定事件 HostComponent 更新 DOM 时进行的 diff 判断 updateHostComponent diffProperties 根据不同的节点做不同的操作 生成 updatePayload 赋值给 workInProgress.updateQueue 最后标记 workInProgress.effect &#x3D; UPDATE 虚拟 dom 就是根据 props 描述生成的 dom 对象 根据不同标签节点提取新老 props 准备比较 第一次遍历老 props 把要删除的属性都设置为 null 第二次遍历新 props 比较 style 样式对象, 最后(updatePayload = updatePayload || []).push(STYLE, styleUpdates); 最后 return updatePayload: [k1,v1,k2,v2,k3,v3] 的属性 completeWork 对于 HostText 的更新 核心是 document.createTextNode renderRoot 错误处理 核心 给报错的节点增加 Incomplete 副作用 effect 给父链上具有 error boundary 的节点增加副作用 创建错误相关的更新 onUncaughtError 致命错误设置为 NoWork，不构建 effect 链 nextFlushedRoot.expirationTime &#x3D; NoWork; 取消当前 root 的更新 throwException 错误处理 给报错节点组件 增加 Incomplete effect， 清空报错节点的 effect 链 suspened 异步组件抛出的 promise 构建错误对象 throwException 处理错误节点 向上遍历 class 组件找可以处理错误的 class 组件生命周期 一直找到 Root 节点执行内置错误处理 给能处理错误的节点组件的 effect 都加了 ShouldCapture 创建错误更新，入 workInProgress.updateQueue 更新队列来更新 getDerivedStateFromError 生命周期直接赋值在 update.payload 上 componentDidCatch 生命周期作为 callback 处理 createClassErrorUpdate 创建 class 组件处理错误的 update createRootErrorUpdate 创建 root 节点处理错误的 update 最后 enqueueCaptureUpdate，类似 enqueueUpdate 交给 react 更新 completeUnitOfWork 处理报错节点 报错的节点直接进入 completeUnitOfWork 完成 不渲染子节点 报错节点在 completeUnitOfWork 内走 unwindWork 流程 unwindWork 的处理 类似 completeWork 对不同组件进行处理 对 shouldCapture 组件设置 DidCapture effect 副作用 大部分没动作， 其余也多是 pop context 只有 HostComponent, HostText, SuspenseComponent 有操作 与 completeWork 最大的区别就是会判断 ShouldCapture throwException 处理错误节点时给能处理错误的节点组件的 effect 都加了 ShouldCapture 当前报错组件能处理错误重新标记 effect next 存在能处理错误保留 HostEffectMask 以上的 effect","categories":[],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"}]},{"title":"React 源码解析 - 更新流程 renderRoot 渲染阶段","slug":"React 源码解析 - 更新流程 renderRoot 渲染阶段 ","date":"2019-06-03T10:05:11.000Z","updated":"2023-09-19T15:18:15.326Z","comments":true,"path":"2019/06/03/React 源码解析 - 更新流程 renderRoot 渲染阶段 /","link":"","permalink":"http://yoursite.com/2019/06/03/React%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%20-%20%E6%9B%B4%E6%96%B0%E6%B5%81%E7%A8%8B%20renderRoot%20%E6%B8%B2%E6%9F%93%E9%98%B6%E6%AE%B5%20/","excerpt":"","text":"往期回顾React 源码解析 React 的更新 React 源码解析 - React 创建更新回顾和 React 的批量更新 React 源码解析 - 调度模块原理 - 实现 requestIdleCallback \u001c React 源码解析 - reactScheduler 异步任务调度 renderRoot 入口 ReactFiberScheduler.js1234567891011121314151617181920212223242526272829function renderRoot(root: FiberRoot, isYieldy: boolean, isExpired: boolean) &#123; // ... if ( // 将要执行的任务 root 和 expirationTime 和 nextRenderExpirationTime、nextRoot 预期的不一样， 应该是之前任务被高优先级的任务打断了。 expirationTime !== nextRenderExpirationTime || root !== nextRoot || nextUnitOfWork === null // 更新结束 fiber 的 child，下一个节点, 首次 = null ) &#123; // 初始化的内容 resetStack(); // 重置 nextRoot = root; nextRenderExpirationTime = expirationTime; // root.nextExpirationTimeToWorkOn; nextUnitOfWork = createWorkInProgress( // 拷贝了一份 fiber 对象操作 nextRoot.current, null, nextRenderExpirationTime, ); root.pendingCommitExpirationTime = NoWork; // 设置成 NoWork // ... &#125;// 开始进入 workLoop do &#123; try &#123; workLoop(isYieldy); // 进行每个节点的更新 &#125; catch (thrownValue) &#123; // ... break; // 遇到了某种错误跳出 &#125; while(true)&#125; workLoop 中所有发生的错误都会被 render 阶段 catch，render 阶段会根据捕获的错误具体内容进行相应的操作123456789101112131415function workLoop(isYieldy) &#123; if (!isYieldy) &#123; // 不可中断 Sync 和 超时任务不可中断 // Flush work without yielding // nextUnitOfWork 是 fiber 对象，为 null 已经是 root 节点 fiber return 的 null 了 // 用于记录render阶段Fiber树遍历过程中下一个需要执行的节点。在resetStack中分别被重置,他只会指向workInProgress while (nextUnitOfWork !== null) &#123; // 不停的更新，不为 null 就不停执行 next 的 child 的更新 nextUnitOfWork = performUnitOfWork(nextUnitOfWork); // 进行更新 &#125; &#125; else &#123; // Flush asynchronous work until the deadline runs out of time. while (nextUnitOfWork !== null &amp;&amp; !shouldYield()) &#123; // 判断 shouldYield = false 当前时间片是否有时间更新 nextUnitOfWork = performUnitOfWork(nextUnitOfWork); &#125; &#125;&#125; workLoop 只是根据时间片是否有任务调用 performUnitOfWork 进行更新, 只有当 nextUnitOfWork &#x3D;&#x3D;&#x3D; null 时才代表任务已经更新完了performUnitOfWork 在 beginWork 中对当前 fiber 进行更新，更新到此 fiber 的最后时会去找兄弟节点，最后返回给 workLoop 中的 while(nextUnitOfWork) 中继续执行 beginWork核心功能 验证当前 fiber 树是否需要更新 更新传入的节点类型进行对应的更新 更新后调和子节点 第一步验证当前 fiber 树是否需要更新 比较当前节点 props 是否有变化 检查当前节点是否有更新或是否比当前 root 的更新优先级大 没更新或优先级低就跳过，bailoutOnAlreadyFinishedWork bailoutOnAlreadyFinishedWork 可以判断 current 是否有 child 更新 bailoutOnAlreadyFinishedWork 会判断这个 fiber 的子树是否需要更新，如果有需要更新会 clone 一份到 workInProgress.child 返回到 workLoop 的 nextUnitOfWork, 否则为 null 根据 fiber 的 tag 类型进行更新进行更新先把当前 fiber 的 expirationTime 设置为 NoWork，根据 tag 进行不同组件的更新 ClassComponent: class 组件 HostRoot: HostComponent: html 标签 HostText: 文本内容… workInProgress 更新所用到的 fiber 对象属性 type当函数组件时是 function当为 class 组件时就是 class 构造函数当 dom 原生组件时就是标签 div 这种字符串 pendingPropsfiber 更新带来的新 props 更新函数会用到的参数 currentworkInProgress.alternate，指向当前 fiber 没更新的对象 ComponentworkInProgress.type，此时 fiber 节点组件的类型，function，class，标签 字符串 nextPropsworkInProgress.pendingProps，此次更新带来的新 props renderExpirationTimefiberRoot.expirationTime，fiberRoot 上最大优先级的值 FunctionComponent 更新1234567891011121314151617181920function updateFunctionComponent( current, workInProgress, Component, nextProps: any, renderExpirationTime,) &#123; // ... context 相关 let nextChildren; // Component 组件方法，这里就是我们声明组件的方式 function(props, context) &#123;&#125; nextChildren = Component(nextProps, context); // 把 nextChildren 这些 ReactElement 变成 Fiber 对象, 在 workInProgress.child 挂载 fiber reconcileChildren( current, workInProgress, nextChildren, renderExpirationTime, ); return workInProgress.child;&#125; reconcileChildren核心点 根据 props.children 生成 fiber 子树 判断 fiber 对象是否可以复用, 在第一次渲染就渲染了 fiber 子树，state 变化可能会导致不能复用，但是大部分是可以复用的 列表根据 key 优化 根据首次渲染或更新渲染进行操作 current &#x3D;&#x3D;&#x3D; null 首次渲染, mountChildFibers current !&#x3D;&#x3D; null 更新渲染, reconcileChildFibers mountChildFibers 和 reconcileChildFibers 都是由 ChildReconciler 返回的函数，区别只在参数不同12export const reconcileChildFibers = ChildReconciler(true);export const mountChildFibers = ChildReconciler(false); reconcileChildFibers reconcileChildFibers 是 ChildReconciler 返回的最终函数 先判断 newChild 是不是 Fragment 节点 typeof newChild &#x3D;&#x3D;&#x3D; object 是函数组件和 class 组件返回的 jsx - reconcileSingleElement typeof newChild &#x3D;&#x3D;&#x3D; string 是 textNode - reconcileSingleTextNode 判断 newChild 是个数组 判断是 iterator 函数 都不符合抛错 提醒组件没有合法的返回值 最后删除所有的节点 return deleteRemainingChildren(returnFiber: new, currentFirstChild: old); placeSingleChild更新渲染时 placeSingleChild 会把新创建的 fiber 节点标记为 Placement, 待到提交阶段处理其中 ReactElement, Portal, TextNode 三种类型的节点需要进行处理x reconcileSingleElement 更新 ReactElement调和单个子节点 第一段逻辑，从原 fiber 节点的兄弟节点遍历，比较 fiber 节点和 nextChilren key 值 符合复用条件，标记此 fiber 节点的所有兄弟节点 effect 在提交阶段删除达到只复用干净的这个 fiber 节点的目的，返回这个可以复用的节点 如果 key 相等，不符合复用条件直接跳出, 进入第二段逻辑 如果 key 不相等逐渐标记删除遍历的 fiber 节点, 进入第二段逻辑 这里调和单个子节点, 如果 key 不存在为 null 我们也认为他是相等的，判断 type \b和 elementType 来看他们是否一是个组件函数 deleteChild 标记删除 deleteRemainingChildren 删除多余的兄弟节点 第二段逻辑，没有可以复用的节点，根据 elment nextChildren 的类型创建 Fragment 或者 Element 类型的 fiber。 reconcileSingleTextNode 更新 textNode currentFirstChild 原 fiber 节点 child 是文本节点符合复用条件 currentFirstChild 不是文本节点，现在要更新为文本节点删除后重新创建 useFiber 创建复用的节点 reconcileChildrenArray 调和数组 children react 新老 children 对比的过程算法 尽量减少节点的遍历次数来达到判断节点是否可复用的过程 第一次遍历(优化加速) 找到新老节点中不能复用的节点才跳出 判断新老节点的 index 判断新老 key 是否相同来复用 不能复用就 break 跳出当前遍历 能复用就构建链表结构 updateSlot 根据 newChild 的类型和 oldChild.key 进行判断操作 返回 null 表示后面都不能复用了直接跳出 textNode 文本节点 oldFiber 不是 textNode 还有 key 值，是在数组里的，新的 textNode 不能复用返回 null oldFiber 不是 textNode 创建新的 textNode 否则直接更新 textNode 内容 ReactElement 节点和 isArray 数组节点 ReactElement 时 updateElement Fragment 时与 ReactElement 的处理相似，复用处理的内容为 newChild.props.children break 或者遍历完毕后的情况 newIdx &#x3D;&#x3D;&#x3D; newChildren.length 新的 children 已经在 updateSlot 中创建新的对象了, 新数组操作完成了, 所有新节点都已经创建 oldFiber &#x3D;&#x3D;&#x3D; null 老的已经被复用完了, 新的节点还有部分没有创建, 找到最后没有能复用的节点了 直接创建剩下的新节点构建链表 情况一 按新数组 newChildren.length 的长度遍历完了 这时 updateSlot 没有返回 null，所有节点都复用或新建的，都标记好了位置 这个情况是最快的，如果 oldFiber 老节点还有没遍历完的就删掉 情况二 老的节点已经被复用完了, 新的节点还有部分没有创建, 遍历到最后没有能复用的节点了 newChildren 剩下的节点就直接创建，同时进行同样的 place 标记构建链表结构 核心通用操作，构建 map 复用 newChildren 没有创建完，oldFiber 又有兄弟节点，数组存在顺序的变 根据老节点的 key 或 index 构建 map 对象 遍历剩下的 newChildren 根据 key 或 index 直接在 map 里找可以复用的对象或创建新的对象 再构建链表 更新 classComponent 组件 首次渲染 instance &#x3D;&#x3D;&#x3D; null constructClassInstance 生成实例 mountClassInstance 挂载实例 渲染被中断 instance !&#x3D;&#x3D; null, current &#x3D;&#x3D;&#x3D; null resumeMountClassInstance 复用实例但还是调用首次渲染的生命周期 更新渲染 instance !&#x3D;&#x3D; null, current !&#x3D;&#x3D; null updateClassInstance，调用 didUpdate 和 componentWillReceiveProp 生命周期 都是复用或创建 instance，通过 processUpdateQueue 计算新的 state 赋值到 fiber workInProgress.memoizedState 和 instance 上面记录 最终执行 finishClassComponent, 进行错误判断的处理和判断是否可以跳过更新的过程，重新调和子节点 reconcileChildren 首次渲染 class 组件 instance &#x3D;&#x3D;&#x3D; null constructClassInstance 创建实例 instance 赋值在 workInProgress.stateNode 上1234567891011121314151617function constructClassInstance( workInProgress: Fiber, ctor: any, props: any, renderExpirationTime: ExpirationTime,): any &#123; // ... // 从这里开始，ctor 就是 element.type 的 Compnent，这里生成 class 组件实例 const instance = new ctor(props, context); const state = (workInProgress.memoizedState = // memoizedState 为实例的 state, 没有就为 null instance.state !== null &amp;&amp; instance.state !== undefined ? instance.state : null); adoptClassInstance(workInProgress, instance); // ... return instance;&#125; 为 instance.updater 赋值 classComponentUpdater, 用于组件通过何种方式进行 ReactDOM.render 和 setState 进行更新123456// 为实例确定 updater 对象function adoptClassInstance(workInProgress: Fiber, instance: any): void &#123; instance.updater = classComponentUpdater; // 给 class 组件实例的 updater 设置 workInProgress.stateNode = instance; // instance 赋值给当前 workInProgress.stateNode ReactInstanceMap.set(instance, workInProgress); // 给 instance._reactInternalFiber 赋值当前的 fiber 对象&#125; mountClassInstance 首次挂载实例 初始化 class 组件创建 updateQueue 计算更新 state 判断和执行 getDerivedStateFromProps, componentWillMount 生命周期，都会更新当前 state 可以看到 componentWillMount 完全可以进行 setState，会创建 updateQueue 计算更新当前 state 最后标记 componentDidMount 生命周期，待到提交阶段更新完 dom 后执行 processUpdateQueue 计算更新 state updateQueue 的更新都是通过 baseState 计算的，执行 queue 的更新会检查这次更新的优先级，优先级低待到下次更新 每个 update 都会计算出当前的 state 结果，如果 setState 有第二个参数 callback 会标记 effect 待到提交阶段执行，这样 callback 就能得到准确的 state getStateFromUpdate 根据 update.tag 计算 state 的结果，会判断 setState 传入的函数或对象两种情况1 函数时会指定上下文，传入 prevState, nextProps2 对象时就是最终要更新的 state 对象3 最后通过 Object.assign 生成新的 state 对象 resumeMountClassInstance 复用实例 \b中断后恢复的组件复用实例仍然按新组件挂载来执行 检查得到 shouldUpdate，执行 willMount 和标记 didMount shouldUpdate 由组件的 shouldComponentUpdate 判断，pureComponent 会自动比较 props updateClassInstance 更新实例 过程与 resumeMountClassInstance 相似, 不过执行的是 willUpdate, 标记 didUpdate, getSnapshotBeforeUpdate finishClassComponent 完成 class 组件更新没错误捕获又不需要更新 没错误捕获也没更新直接跳过 effect 的错误标记会在外侧 catch 中添加 捕获错误的操作 class 组件没有 getDerivedStateFromError， nextChildren &#x3D; null class 组件有 getDerivedStateFromError ，直接执行 instance.render() 获得最新的 nextChildren, getDerivedStateFromError 在函数外 catch 到错误并且执行立即更新为正确的 state, 所以可以执行 instance.render() 没捕获错误 执行 instance.render() 最后执行的 reconcileChildren IndeterminateComponent 更新 fiber 刚创建的时候 fiberTag 都为 IndeterminateComponent 类型，只有当 class 组件有 construct 才为 class 组件类型 符合 class 组件条件按 class 组件更新 否则就按函数组件类型更新 只存在于首次更新的时候，只有首次更新的时候不确定 fiberTag 类型 更新 HostComponent 原生 dom 标签 原生标签 小写的 标签 判断标签内容是不是纯文本 是纯文本没子节点，不是纯文本根据之前的 props 标记更新 跟 classCompnent 一样有 makeRef 能使用 ref updateHostComponent dom 标签内是纯文本 nextChildren 为 null，直接渲染文本内容 原 props 是文本，现在换成节点标记 effect 提交阶段操作 和 classComponent 一样可以使用 ref 的原因是都有 markRef 判断 concurrentMode 异步组件是否有 hidden 属性，异步组件 hidden 永不更新 最后进行 reconcileChildren shouldSetTextContent 特殊标签 textarea，option，noscript 直接渲染文本 props.children 为 string，number 直接渲染 dangerouslySetInnerHTML 属性 直接渲染 HostText 文本节点updateHostText文本内容不需要构建 fiber 结构，直接在提交阶段更新就行了 12345678function updateHostText(current, workInProgress) &#123; if (current === null) &#123; tryToClaimNextHydratableInstance(workInProgress); &#125; // Nothing to do here. This is terminal. We&#x27;ll do the completion step // immediately after. return null; // 文本没有子节点不需要调和, 到 提交阶段直接就更新了&#125; ForwardRef 更新 实现了 React.forwardRef((props, ref) &#x3D;&gt; { 传入了 ref }) 传递 ref 的功能 Mode 组件 React 提供的组件 标签 标签 updateMode 执行，const nextChildren &#x3D; workInProgress.pendingProps.children; Memo 组件 functionComponent 具有 pureComponent 功能 memo 组件 Component.type 就是 传入的function组件， memo(function(props) {}) memo 组件的 props 都要作用于 function 组件内 memo 组件意义不多只是进行了一次包裹的比较 创建的 child 没有调和 reconcileChildren 初次渲染 根据 React.memo() 传入的函数组件进行判断 SimpleFunctionComponent 的判断, 没有 defaulteProps, 不是构造函数, 简单函数组件只进行浅比较1234567export function isSimpleFunctionComponent(type: any) &#123; return ( typeof type === &#x27;function&#x27; &amp;&amp; !shouldConstruct(type) &amp;&amp; type.defaultProps === undefined );&#125; updateSimpleMemoComponent 更新渲染 优先级低，进行 PureComponent 功能的比较 有必要更新直接创建节点，构建 fiber 树 没有调和 reconcileChildrenreconcileChildren 也是把 nextChildren 结果的 ReactElement 生成 fiber 后赋值给 workInprogress.child 上不过多了很多 类型的判断, memo 组件有必要更新是直接创建后 赋值在 workInprogress.child 上了，memo 组件编写只会返回常规的 ReactElement 组件内容 completeUnitOfWork 根据是否中断调用不同的处理方法 当一侧的子节点被 beginWork 更新组件完了执行 beginWork 完成各个组件的 update，然后返回他的 child 判断是否有兄弟节点来执行不同的操作 完成节点之后复 effect 链 完成节点更新，重置 childExpirationTime 构建 effect 链，供 commitRoot 提交阶段使用 单侧节点查找向上寻找节点 performUnitOfWork 遍历 fiber 树的顺序 总结 renderRoot 阶段，通过 fiberRoot.current 构建 nextUnitOfWork 在 workLoop 中对 nextUnitOfWork 的每个节点进行更新，从 fiberRoot 应用的第一个子节点开始 workLoop 中 while 循环 执行 nextUnitOfWork &#x3D; performUnitOfWork(nextUnitOfWork) performUnitOfWork 中以 nextUnitOfWork.alternate 和 nextUnitOfWork 做两个 fiber 的对照，通过 beginWork 依次遍历复用和创建 fiber 构建成新的 nextUnitOfWork.child ，再返回 workLoop 中的 performUnitOfWork beginWork 根据 tag 属性判断当前 nextUnitOfWork 的节点类型与 alternate 对照来进行对应组件的复用更新，最后构建成新的 fiber 树，对节点上的操作进行 effect 标记 当 beginWork 遍历完单侧子树后会通过 completeUnitOfWork 构建 effect 更新链，方便 commit 提交阶段更新 completeUnitOfWork 在构建完此侧边树的 effect 链后, 向上寻找当前 workInProgress 的 兄弟节点，继续 beginWork。 completeUnitOfWork 中如果找不到 workInProgress 的兄弟节点就继续找父节点的兄弟节点，直到找到 root 节点顶点返回 null，进入 commitRoot 提交阶段 renderRoot 通过前后 fiberRoot.current 的对照逐层的复用更新，构建出一个新的 fiber 树，标记节点 effect 等到提交阶段操作 参考文章实现 fiber 架构","categories":[],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"}]},{"title":"TCP 拥塞控制","slug":"TCP 拥塞控制","date":"2019-05-21T09:41:52.000Z","updated":"2023-09-18T15:16:45.903Z","comments":true,"path":"2019/05/21/TCP 拥塞控制/","link":"","permalink":"http://yoursite.com/2019/05/21/TCP%20%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/","excerpt":"","text":"TCP 拥塞控制背景 作用于网络，防止过多的包发送到网络中，避免网络负载过大，网络拥塞的情况 检测网络传输的情况进行动态控制 作用 TCP 通过维护一个拥塞窗口来进行拥塞控制 网络中没有出现拥塞，拥塞窗口的值就可以再增大一些，以便把更多的数据包发送出去 网络出现拥塞，拥塞窗口的值就应该减小一些，以减少注入到网络中的数据包数。 名词 ACK 确认，确认方收到包后的确认报文 拥塞窗口值 cwnd， ssthresh （slow start threshold）慢启动阈值 MSS (Maximum segment size) 最大分段大小 RTT (round-trip time) 往返时间，来回通信延迟 RTO (retransmission timeout) 重传超时 拥塞控制的三种情况 收到正确的 ACK 确认，表明当前单次发送量小于网络的承载量 收到三条同一分组的确认，重复的三条确认，单次发送量一般大于3 发送 0 10 20 30 40 ，20序号丢失 返回 0 10 20 20 20 , 得到3个20的重复确认 对某条分组的确认超时未收到确认 发送 0 10 20 30 40 , 30序号丢失 返回 0 10 20 30 30 , 2次重复，单次发送大于3，更繁忙 慢启动 TCP 刚建立连接，逐渐提速试探网络承受能力1 慢启动初始启动时设置拥塞窗口值（cwnd）为1、2、4或10个MSS2 cwnd 大小每当收到一个ACK增加，每个 RTT 内成倍增加, 呈指数上升3 当达到慢启动阈值 ssthresh 时 cwnd &gt;&#x3D; ssthresh，进入拥塞避免算法-线性增长阶段 拥塞避免 拥塞窗口值 cwnd &gt;&#x3D; ssthresh 慢启动阈值时，cwnd 进入线性增长阶段 cwnd 大小每当收到一个ACK增加，每个 RTT 只增加 1, 呈线性上升 快速重传 Tahoe：如果收到三次重复确认——即第四次收到相同确认号的分段确认，并且分段对应包无负载分段和无改变接收窗口——的话，Tahoe算法则进入快速重传，将慢启动阈值改为当前拥塞窗口的一半，将拥塞窗口降为1个MSS，并重新进入慢启动阶段。 设置 ssthresh 为当前 cwnd 的一半 cwnd 变为 1MSS， 重新进入慢启动 - 指数上升再线性上升 对于RTO，将拥塞窗口降为1个MSS，然后进入慢启动阶段 快速恢复 Reno：如果收到三次重复确认，Reno算法则进入快速重传，只将拥塞窗口减半来跳过慢启动阶段，将慢启动阈值设为当前新的拥塞窗口值，进入一个称为“快速恢复”的新设计阶段。 设置 ssthresh 为当前 cwnd 的一半 cwnd 也设置为 ssthresh 大小 进入拥塞避免阶段 - 线性上升 对于RTO，将拥塞窗口降为1个MSS，然后进入慢启动阶段 快速重传 Tahoe，快速恢复 Reno 图解 参考https://zh.wikipedia.org/wiki/TCP%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6https://zh.wikipedia.org/wiki/%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6https://juejin.im/entry/5b7fcd13f265da4372473199https://zhuanlan.zhihu.com/p/59656144https://blog.csdn.net/lpjishu/article/details/51366691https://blog.csdn.net/Go_hack/article/details/79850183","categories":[{"name":"http","slug":"http","permalink":"http://yoursite.com/categories/http/"}],"tags":[{"name":"http","slug":"http","permalink":"http://yoursite.com/tags/http/"}]},{"title":"webpack 源码-资源加载","slug":"webpack 源码-资源加载","date":"2019-04-01T09:02:21.000Z","updated":"2023-10-12T15:53:17.485Z","comments":true,"path":"2019/04/01/webpack 源码-资源加载/","link":"","permalink":"http://yoursite.com/2019/04/01/webpack%20%E6%BA%90%E7%A0%81-%E8%B5%84%E6%BA%90%E5%8A%A0%E8%BD%BD/","excerpt":"","text":"准备编译的代码资源一共四个文件资源 1234567891011121314151617181920// index.jsimport &#123; varA, varB &#125; from &#x27;./mod1&#x27;import m2 from &#x27;./mod2&#x27;let b = &#x27;bbb&#x27;console.log(varA, varB, m2)// mod1.jsexport const varA = &#x27;aaa&#x27;export const varB = &#x27;bbb&#x27;// mod2.jsimport &#123; c &#125; from &#x27;./modc.js&#x27;export default &#123; m1: &#x27;m1&#x27;, m2: &#x27;m2&#x27;&#125;// modc.jsexport const c = &#x27;cccc&#x27; webpack 资源加载 - 主流程1.Compiler.js - run，在 run 方法中执行 this.compile() 2.Compiler.js - compile，生成 Compiltaion 实例执行 make hooksmake hooks 的实现在 SingleEntryPlugin 插件里，生成 SingleEntryDependency \b调用 compilation 实例的 addEntry 方法. 3.Compilation.js - addEntry - 处理入口 entry 执行 _addModuleChainaddEntry 中把 SingleEntryPlugin 生成的 dep 也就是 entry 传入执行 _addModuleChain，发现执行的 _addModuleChain 回调有在 this.entries 中 push 一个 module 的线索 4.Compilation.js - _addModuleChain - factory 创建 module - addModule 到 this.modules_addModuleChain 创建 module，此时第一个 module 出现，这个 module 是以为 entry 创建的 5.Compilation.js - _addModuleChain - addModule 把 module push 到 this.modules 中 5.Compilation.js - _addModuleChain - buildModule - 对 entry 的 module 进行 Loader 处理buildModule 由 NormalModule.js 实现，对远吗执行 loader 并收集依赖此时 compilation 实例中 enties 和 modules 各自有一个 module , 这个 module 都是 entry 入口文件生成的。此时 entry 的 module 已经分析出了 import 导入的模块语法entry 的 module 的源码也被 babel-loader 处理成了 ES5 的代码 6.Compilation.js - _addModuleChain - afterBuild - 主入口 module 处理完毕在 processModuleDependencies 中对 entry 的 module 的依赖进行递归调用 buildModule，分析出所有的 module 放入到 this.modules 中最后进入 seal 阶段。此时 modues 已经不止 entry 的 module 了，把所有 import 语句导入的 module 都收集完毕。 Compilation.js - _addModuleChain 做了什么1.传入 entry 信息2.moduleFactory 创建 entry 的 module, 添加到 this.modules 和 this.enties 中3.调用 buildModule，对 entry 的 module 进行 loader 调用、分析 entry 源码中的 import 导入模块语句分析出依赖信息。4.执行 afterBuild 在 processModuleDependencies 中处理 entry module 的依赖文件，处理成 module 放入 this.modules 中，完成资源加载 buildModulebuildModule 中执行当前 module 类型的 module.build 进入 NormalModule.js 的 doBuild 执行 LoaderRunner.js 文件 runLoaders 这里遇到 LOADER_EXECUTION 函数，里面 的 fn 就是 loader， args 是 loader 处理前的源码 到这一步中间就在 loader 中执行，经过 loader 出来后的代码就是 arguments， 这里已经转译成 ES5 了, 执行的 callback 是 doBuild 的回调 带着 loader 处理后的源码回到 doBuild 回调中走\bthis.parser.parse 中 带着 loader 处理后的源码进入 parse 出来 ast 对象 通过 acorn 三方模块对源码分析出 ast ，描述源码的语义 parse 最后就是返回一个 state，这时 state 中 module.dependencies 还是空的 源码生成的 ast 经过 walker 的处理，在 state 上分析出了所有 import 文件的信息 用这种语法彻底描述出源码中的依赖关系 此时 entry 文件的就处理完了，此时 compilation 实例上的 this.modules 仍然只有一个 entry module，但是现在 webpack 已经通过 ast 解析出了所有 entry module 中的依赖模块的信息，后面就根据这些依赖信息生成各个模块 资源递归收集依赖对依赖进行处理，发现是 import 语义的依赖才进行处理处理收集 import 的依赖调用 addModuleDependencies，方法里与 buildModule 类似，工厂生成 module，addModule 加入到 this.modules 中，进行 loader 处理源码最后进入 afterBuild 判断当前处理的 module 结果是否继续有依赖进行递归处理 总结1.Compiler.js - compiler.run 执行 this.compile()2.Compiler.js - compile，生成 Compiltaion 实例执行 make hooks3.Compilation.js - addEntry - 处理入口 entry 执行 _addModuleChain4._addModuleChain 使用工厂函数创建 module，使用 module 自己的 build5.build 在 NormalModule 中执行 doBuild 调用 LoaderRunner.js 的 runLoaders 使用 loader 处理源码6.loader 处理完源码回到 doBuild 回调调用 Parser 的 parse7.使用 acorn 分析源码成 ast ，给 module.dependencies 添加依赖关系8.根据依赖关系在 afterBuild 中调用 processModuleDependencies 递归处理依赖文件9.最后把所有处理好的 module 都放入 compilation 实例的 this.modules 中进入 seal 阶段 参考资源加载","categories":[{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/categories/webpack/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/tags/webpack/"}]},{"title":"webpack 原理","slug":"webpack 原理","date":"2019-03-13T10:25:56.000Z","updated":"2023-10-07T15:32:32.585Z","comments":true,"path":"2019/03/13/webpack 原理/","link":"","permalink":"http://yoursite.com/2019/03/13/webpack%20%E5%8E%9F%E7%90%86/","excerpt":"","text":"webpack 核心核心概述 entry 入口文件：js 代码文件，可执行的 node 模块或打包的入口文件。 chunk 代码块：代码分割的代码块，按需加载的分块，装载多个不同模块和这些模块所依赖的模块文件经过 webpack 打包而成的代码块。 loader 文件转换器：把匹配规则的文件资源转换成想要的结果，比如 scss-loader 把 scss 文件当作模块转成 css 文件，loader 可以串行使用。 plugin 插件：用于扩展webpack的功能，在 webpack 构建过程中各个 hook 上扩展功能，调用 webpack API 改变输出结果。 module, chunk, bundle 之间的关系 module 模块：代码模块，由 import, require 等模块规范导出的代码片段。 chunk 代码块：由多个 module 组成，通常情况下 bundle 是由 chunk 对应生成。 bundle：由多个 module 组成，通常跟 chunk 对应，包含已经过加载和编译的最终生成的源文件。 一个例子介绍 module, chunk, bundle12345678910&#123; entry: &#123; foo: [&quot;lodash.js&quot;,&quot;./src/foo.js&quot;], bar: [&quot;./src/bar.js&quot;] &#125;, output: &#123; path: &quot;./dist&quot;, filename: &quot;[name].js&quot; &#125;&#125; module: lodash.js ，./src/foo.js, 还包括 foo.js 用 require, import 等方法导入的文件和依赖+ chunk: foo, bar bundles: foo.js, bar.js 文件 webpack 核心对象 Tapable与 nodejs 中的 eventEmiiter 模块类似, Compiler 和 Compilation 对象都继承于 Tapable，webpack 运行时通过 Tabpable 实例的 API 进行广播和监听 12345// 旧版本: 使用的 apply 和 plugin 广播和监听事件// 广播事件compiler.apply(&#x27;eventName&#x27;,params);// 监听事件compiler.plugin(&#x27;eventName&#x27;,function(params) &#123;&#125;); 1234567// 新版本: 使用 Hooks 进行广播和监听const &#123; SyncHook &#125; = require(&quot;tapable&quot;)let hook = new SyncHook([&#x27;自定义钩子名&#x27;]); // 订阅hook.tap(&#x27;自定义函数名&#x27;, function (params) &#123; // todo &#125;);// 发布hook.call(params);// 发布的时候触发订阅的函数 同时传入参数 参考 Tapable 的使用 CompilerCompiler 继承 Tapable 对象，可以广播和监听 webpack 事件。Compiler 对象是 webpack 的编译器，webpack 周期中只存在一个 Compiler 对象。Compiler 对象在 webpack 启动时创建实例，\u001ecompiler 实例中包含 webpack 的完整配置，包括 loaders, plugins 信息。 CompilationCompilation 继承 Tapable 对象，可以广播和监听 webpack 事件。Compilation 实例仅代表一次 webpack 构建和生成编译资源的的过程。webpack 开发模式开启 watch 选项，每次检测到入口文件模块变化时，会创建一次新的编译: 生成一次新的编译资源和新的 compilation 对象，这个 compilation 对象包含了当前编译的模块资源 module, 编译生成的资源，变化的文件, 依赖的的状态 Compiler 和 Compilation 的区别在于：Compiler 代表了整个 Webpack 从启动到关闭的生命周期，而 Compilation 只是代表了一次新的编译。 webpack 构建webpack 编译的过程有哪些阶段webpack 是如何从 entry 开始解析整个依赖树的laoders 在何时调用的 流程图 流程顺序解析webpack配置参数，合并的命令行启动传入和 webpack.config.js 文件里配置。 注册插件注册所有配置的插件，好让插件监听webpack构建生命周期的事件节点，以做出对应的反应。从配置的entry入口文件开始解析文件构建AST语法树，找出每个文件所依赖的文件，递归下去。在解析文件递归的过程中根据文件类型和loader配置找出合适的loader用来对文件进行转换。递归完后得到每个文件的最终结果，根据entry配置生成代码块chunk。输出所有chunk到文件系统。 注册插件12345678910111213141516171819202122const webpack = (options, callback) =&gt; &#123; // ... compiler = new Compiler(options.context); compiler.options = options; new NodeEnvironmentPlugin().apply(compiler); if (options.plugins &amp;&amp; Array.isArray(options.plugins)) &#123; // 加载 webpack.config.js 里的插件 for (const plugin of options.plugins) &#123; if (typeof plugin === &quot;function&quot;) &#123; plugin.call(compiler, compiler); &#125; else &#123; plugin.apply(compiler); &#125; &#125; // ... // 加载 webpack 自身的插件 compiler.options = new WebpackOptionsApply().process(options, compiler); // ... 有watch 配置执行 compiler.watch(watchOptions, callback) compiler.run(callback); &#125; return compiler; // ... WebpackOptionsApply WebpackOptionsApply 会根据配置注册对应的 webpack 内部插件 WebpackOptionsApply 一开始会注册一个处理 Entry 的插件仅仅是注册了 EntryOptionPlugin 插件, 这个插件会在 make 阶段调用 compilation 的 addEntry 把入口文件通过 parse 先解析成 AST 语法树，对 AST 进行遍历收集 require、import 这些导入的模块 module。1234567891011class WebpackOptionsApply &#123; process(options, compiler) &#123; // ... // 处理一个 Entry 插件 new EntryOptionPlugin().apply(compiler); // 调用 entryOption 钩子 注册 EntryOptionPlugin 插件，注册 DynamicEntryPlugin 等待 make 钩子触发执行 compilation 对象上的 addEntry compiler.hooks.entryOption.call(options.context, options.entry); // ... 加载 webpack 自身的插件 &#125;&#125; 注册的钩子 Hooks12345678910111213141516171819202122232425// EntryOptionPlugin.jsmodule.exports = class EntryOptionPlugin &#123; apply(compiler) &#123; compiler.hooks.entryOption.tap(&quot;EntryOptionPlugin&quot;, (context, entry) =&gt; &#123; // ... new DynamicEntryPlugin(context, entry).apply(compiler); return &#125; &#125;&#125;// DynamicEntryPlugin.js class DynamicEntryPlugin &#123; apply(compiler) &#123; // 等待触发 make 钩子进行 addEntry compiler.hooks.make.tapAsync(&#x27;DynamicEntryPlugin&#x27;, (compilation, callback) =&gt; &#123; const addEntry = (entry, name) =&gt; &#123; //... compilation.addEntry(...) &#125; &#125; // ... return addEntry(entry[name], name); &#125;&#125; compiler.runcompiler.run 才是 webpack 的编译的入口，run 会启动编译执行构建流程，在不同的生命周期执行相应的插件 compile 开始编译 make 从入口点分析模块及其依赖的模块，创建这些模块对象 build-module 构建模块 after-compile 完成构建 seal 封装构建结果 emit 把各个chunk输出到结果文件 after-emit 完成输出 12345678910111213141516171819202122232425262728293031323334353637383940// Compiler.jsclass Compiler extends Tapable &#123; run() &#123; // ... this.hooks.beforeRun.callAsync(this, // beforeRun this.hooks.run.callAsync(this, err =&gt; &#123; // run this.readRecords(err =&gt; &#123; this.compile(onCompiled); // 执行 this.compile &#125;); &#125;); &#125;); &#125;compile(callback) &#123; const params = this.newCompilationParams(); this.hooks.beforeCompile.callAsync(params, err =&gt; &#123; // 执行 beforeCompile hook if (err) return callback(err); this.hooks.compile.call(params); // 执行 compile hook const compilation = this.newCompilation(params); // 创建 compilation 编译资源实例 this.hooks.make.callAsync(compilation, err =&gt; &#123; // 执行 mak hook if (err) return callback(err); compilation.finish(); compilation.seal(err =&gt; &#123; // seal hook if (err) return callback(err); this.hooks.afterCompile.callAsync(compilation, err =&gt; &#123; // afterCompile hook if (err) return callback(err); return callback(null, compilation); &#125;); &#125;); &#125;); &#125;); &#125; &#125; 构建 Compilation 对象compiler.run 时会在 compiler 中 创建一个 Compilation 实例对象，compilation 对象中存放着 module, chunk, assets \b还有生成文件的 template 信息。同时 compilation 代表 webpack 构建生成d编译资源的过程，还具有 addEntry() , _addModuleChain() , buildModule() , seal() , createChunkAssets()等方法用于编译过程的各个阶段触发各种 hooks 来调用相应插件。 先从 make 钩子开始看，是由 compiler 触发的，之前在 WebpackOptionsApply 里处理 hooks.EntyOption 到 DynamicEntryPlugin 中订阅了的 compiler.hooks.mak.tapasync() 这个 make hook。 123456789101112131415161718192021222324252627// DynamicEntryPlugin.js compiler.hooks.make.tapAsync( &quot;DynamicEntryPlugin&quot;, (compilation, callback) =&gt; &#123; const addEntry = (entry, name) =&gt; &#123; const dep = DynamicEntryPlugin.createDependency(entry, name); return new Promise((resolve, reject) =&gt; &#123; compilation.addEntry(this.context, dep, name, err =&gt; &#123; if (err) return reject(err); resolve(); &#125;); &#125;); &#125;; Promise.resolve(this.entry()).then(entry =&gt; &#123; if (typeof entry === &quot;string&quot; || Array.isArray(entry)) &#123; addEntry(entry, &quot;main&quot;).then(() =&gt; callback(), callback); &#125; else if (typeof entry === &quot;object&quot;) &#123; Promise.all( Object.keys(entry).map(name =&gt; &#123; return addEntry(entry[name], name); &#125;) ).then(() =&gt; callback(), callback); &#125; &#125;); &#125; ); 在 mak hook 中调用了 compilation.addEntry 方法，读取 options 中的 entry 对象找到入口文件，addEntry 中还会调用私有方法 _addModuleChain 123addEntry(context, entry, name, callback) &#123; this._addModuleChain(context, entry, module =&gt; this.entries.push(module), callback)&#125; 在创建 module 之前，Compiler 会触发 make，并调用 Compilation.addEntry 方法，通过 options 对象的 entry 字段找到我们的入口js文件。之后，在 addEntry 中调用私有方法 _addModuleChain ，这个方法主要做了两件事情。一是根据模块的类型获取对应的模块工厂并创建模块，二是构建模块。在 module 创建之前， Compiler 实例会触发 make 钩子 12345678// Compiler.jsclass Compiler extends Tapable &#123; compile() &#123; // ... this.hook.make.callAsync(compilation, err =&gt; &#123;&#125;) // .. &#125;&#125; 调用 compilation 实例中的 addEntry之后再 addEntry 中调用私有方法 _addModuleChain在 _addModuleChain 中根据模块的类型获取对应模块的工厂函数创建模块，构建模块 1234567891011121314151617181920212223_addModuleChain(context, dependency, onModule, callback) &#123; //.. // dependency 就是传入的 entry const Dep = /** @type &#123;DepConstructor&#125; */ (dependency.constructor); // 找到 相应的工厂函数 const moduleFactory = this.dependencyFactories.get(Dep); // ... moduleFactory.create( // 创建 module &#123; contextInfo: &#123; issuer: &quot;&quot;, compiler: this.compiler.name &#125;, context: context, dependencies: [dependency] &#125;, (err, module) =&gt; &#123; // ... // 构建模块, buildModule 调用到 NormalModule 的 build this.buildModule(module, false, null, null, err =&gt; &#123; // ... &#125;) &#125;&#125; compilation 构建模块, buildModule 调用到 NormalModule 的 build, 执行 doBuild 对每个 require、import 的文件用对应的 loader 进行处理，最后生成 js 的 module。\b 123456789101112131415161718// NormalModule.jsbuild(options, compilation, resolver, fs, callback) &#123; // ... // 返回 doBuild return this.doBuild(options, compilation, resolver, fs, err =&gt; &#123; const result = this.parser.parse( this._ast || this._source.source(), // doBuild 函数里会给环境上下文赋值后执行回调 &#123; current: this, module: this, compilation: compilation, options: options &#125;, (err, result) =&gt; &#123; handleParseResult(result) &#125; ); &#125;)&#125; 123456789101112doBuild(options, compilation, resolver, fs, callback) &#123; const loaderContext = this.createLoaderContext(resolver, options, compilation, fs) // 进行 loader 处理 runLoaders(&#123; resource: this.resource, loaders: this.loaders, context: loaderContext, readResource: fs.readFile.bind(fs) (err, result) =&gt; &#123; // ... this._source = this.createSource(..) // 给环境上下文赋值 this._ast = extraInfo.webapckAST // 给环境上下文赋值 return callback() // 执行 doBuild 回调，进行 parser.parse &#125; &#125;, &#125; 调用 acorn 包把 loader 处理后文件解析成抽象语法树 AST 1234567891011121314class Parser extends Tapable &#123; parse() &#123; // ... ast = acorn.parse(code, &#123; ranges: true, locations: true, ecmaVersion: 2019, sourceType: &quot;module&quot;, onComment: null, plugins: &#123; dynamicImport: true &#125; &#125;&#125; 遍历 AST 构建其中模块依赖的模块，模块可能存在依赖其他模块的情况，遍历 AST 将 require、import 的模块通过 addDependency() 添加到此模块的依赖 dependenies 数组中。当前模块构建完成后，webpack 调用 processModuleDependencies 开始递归处理依赖的 module，接着就会重复之前的构建步骤。 processModuleDependencies 方法递归执行 addDependency 进行依赖解析并收集到 module.dependenies 中 把模块所依赖的模块收集到 module.dependenies 后，回到 compiler.js 中的 compile 方法里调用 compilation.seal 在所有模块和依赖模块构建完后， seal hook 调用各插件对构建后的结果进行处理，对每个 module 和 chunk 进行整理，生成编译后的源码 123456seal() &#123; //... 一大堆 hook 触发插件 this.createModuleAssets() this.createChunkAssets() // 最终生成资源文件 // 把 js 模块都收集到一起，entry 对应每个 chunk 比如 app.js ，使用代码分割会产生多个不同的 chunk&#125; createChunkAssets 这个方法遍历 this.chunks 生成对应 entry 的数量和命名的文件内容，同时 dependencies 记录依赖的 modules。最后把 chunk 携带的依赖树一起调用 MainTemplate 中的 render 插件生成最终的代码文件。 把 render 方法存放在 mainfest 里 遍历 mainfest 最后执行 render 生成 source 最后根据 生成 budle 文件的 模板遍历 chunk 的依赖树把 module 传入生成最终的 js 文件. 总结 webpack 实际是一个 插件的集合。 webpack 由 tapable 控制在各个插件在 hook 的事件流上运行 webpack 主要编译流程依赖于 compilation 和 module 两个对象 流程总结 webpack 根据配置注册对应的插件 生成 compile 实例，执行 compile.run 进入编译阶段 第一步创建 compilation 实例，compilation 实例注册处理不同类型 module 对应的工厂 factory 插件，用于处理不同的 module make 阶段，根据 entry 配置处理对应的 chunk 资源：1 调用 loaders 对模块资源进行处理(doBuild)\u001d，转换成统一标准的 js 代码(babel-loader)的 module2 在 parser.parse 中调用 acorn 对 AST 的 js 代码进行语法分析，收集 module 间的依赖关系，记录下来形成依赖树 最后在钩子 compilation.seal 进入 render 阶段，根据 module 的依赖，生成 module.source() 传入 MainTemplate 中进行 render 生成最终文件","categories":[{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/categories/webpack/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/tags/webpack/"}]},{"title":"React 源码解析 - reactScheduler 异步任务调度","slug":"React 源码解析 - reactScheduler 异步任务调度 ","date":"2019-02-27T14:07:11.000Z","updated":"2023-09-19T15:16:43.316Z","comments":true,"path":"2019/02/27/React 源码解析 - reactScheduler 异步任务调度 /","link":"","permalink":"http://yoursite.com/2019/02/27/React%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%20-%20reactScheduler%20%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%20/","excerpt":"","text":"reactScheduler 异步调度核心功能 维护时间片 模拟浏览器 requestldleCallback API (会等待浏览器执行完其他任务后有空闲时再回来执行回调)[requestIdleCallback MDN], [requestIdleCallback 后台任务调度] 调度列表和超时判断 时间片概念用户感觉流畅界面至少需要 1秒30帧的刷新频率，每一帧只有 33ms 来执行。 一帧 33ms，react 更新需要 20ms, 浏览器执行动画或用户反馈的时间只有 13ms，但是这一帧仍然是可以执行浏览器的动作。 如果 react 更新需要 43ms, 还需要向下一帧借用 10ms， 浏览器在这第一帧中就没有时间去执行自己的任务，就会造成卡顿。 requestldleCallback API 会在浏览器空闲时依次调用函数，让浏览器在每一帧里都有足够的时间去执行动画或用户反馈，防止 react 更新占用掉一帧的所有时间。 scheduleCallbackWithExpirationTime 异步任务调度进入 scheduleCallbackWithExpirationTime在 requestWork 中如果判断是异步调度的方法就会执行 scheduleCallbackWithExpirationTime 12345678function requestWork(root: FiberRoot, expirationTime: ExpirationTime) &#123; // ... if (expirationTime === Sync) &#123; // 同步的调用 js 代码 performSyncWork(); &#125; else &#123; // 异步调度 独立的 react 模块包，利用浏览器有空闲的时候进行执行，设置 deadline 在此之前执行 scheduleCallbackWithExpirationTime(root, expirationTime); // 在 secheduler 文件夹下的单独模块 &#125;&#125; scheduleCallbackWithExpirationTime 源码 把 FiberRoot 加入调度1234567891011121314151617181920212223242526272829// scheduler 调度function scheduleCallbackWithExpirationTime( root: FiberRoot, expirationTime: ExpirationTime,) &#123; // callbackExpirationTime 是上一次调度的任务优先级 if (callbackExpirationTime !== NoWork) &#123; // A callback is already scheduled. Check its expiration time (timeout). if (expirationTime &gt; callbackExpirationTime) &#123; // 当前优先级比之前正在执行的优先级低就停止 // Existing callback has sufficient timeout. Exit. return; &#125; else &#123; // 当前优先级更高 if (callbackID !== null) &#123; // Existing callback has insufficient timeout. Cancel and schedule a // new one. // 退出了 cancelDeferredCallback(callbackID); &#125; &#125; // The request callback timer is already running. Don&#x27;t start a new one. &#125; else &#123; startRequestCallbackTimer(); // 不看 &#125; callbackExpirationTime = expirationTime; // 保存当前任务 const currentMs = now() - originalStartTimeMs; // originalStartTimeMs 是 react 加载的最初时间, 记录当前时间差 const expirationTimeMs = expirationTimeToMs(expirationTime); // 转化成 ms const timeout = expirationTimeMs - currentMs; // 过期时间 callbackID = scheduleDeferredCallback(performAsyncWork, &#123;timeout&#125;); // 赖在 Scheduler 模块 返回 id 用来 cancel&#125; timeout 为当前任务的延迟过期时间，由过期时间 - 当前任务创建时间得出，超过时代表任务过期需要强制更新 通过 scheduleDeferredCallback 生成一个 callbackID，用于关闭任务 scheduleCallbackScheduler 包中的 scheduleCallback 实现细节 维护一个 firstCallbackNode 的任务环状链表结构 比较当前任务的优先级对 firstCallbackNode 的链表任务进行排序 对链表上的 callback 任务排好序后使用 ensureHostCallbackIsScheduled 进行调度 当 firstCallbackNode 链表的首个任务改变时调用 ensureHostCallbackIsScheduled 进行调度，firstCallbackNode 没改变按原来的优先级执行1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071// scheduleDeferredCallback, 传入 performAsyncWork, &#123; timeout &#125;function unstable_scheduleCallback(callback, deprecated_options) &#123; var startTime = currentEventStartTime !== -1 ? currentEventStartTime : getCurrentTime(); // 其实就是 Date.now() var expirationTime; if ( typeof deprecated_options === &#x27;object&#x27; &amp;&amp; deprecated_options !== null &amp;&amp; typeof deprecated_options.timeout === &#x27;number&#x27; ) &#123; // expirationTime 的逻辑有可能全部搬到 Scheduler 包里 expirationTime = startTime + deprecated_options.timeout; // Date.now() + timeout 只会进入这里 &#125; else &#123; // 以后是这个逻辑 switch (currentPriorityLevel) &#123; case ImmediatePriority: // sync expirationTime = startTime + IMMEDIATE_PRIORITY_TIMEOUT; break; case UserBlockingPriority: expirationTime = startTime + USER_BLOCKING_PRIORITY; break; case IdlePriority: expirationTime = startTime + IDLE_PRIORITY; break; case NormalPriority: default: expirationTime = startTime + NORMAL_PRIORITY_TIMEOUT; &#125; &#125; var newNode = &#123; callback, // performAsyncWork priorityLevel: currentPriorityLevel, // 用不到 expirationTime, // timeout + now() next: null, // 链表结构 previous: null, &#125;; // firstCallbackNode 是维护的单向链表头部 if (firstCallbackNode === null) &#123; // 单向链表头部 null 还没有元素, 当前 callback 就是第一个 // firstCallbackNode 链表 pre next 都为当前 callback 的 newNode firstCallbackNode = newNode.next = newNode.previous = newNode; ensureHostCallbackIsScheduled(); // firstCallbackNode 改变需要调用 进入调度过程 &#125; else &#123; // 链表上已经有多个 newNode 了 var next = null; var node = firstCallbackNode; do &#123; // 根据 expirationTime 排序，把优先级大的放在前面, 这里是跟 firstCallbackNode 链表头比较 if (node.expirationTime &gt; expirationTime) &#123; next = node; // next 变为 fristCallbackNode break; &#125; node = node.next; // 循环 &#125; while (node !== firstCallbackNode); if (next === null) &#123; // 当前优先级小，如果 node.expirationTime &lt; expirationTime, 当前的优先级是最小的 next = firstCallbackNode; // 当前优先级小，next 为原来的 firstCallbackNode &#125; else if (next === firstCallbackNode) &#123; // 当前优先级大，firstCallbackNode 优先级没有当前的大 firstCallbackNode = newNode; // 当前优先级大， firstCallbackNode 为当前的 ensureHostCallbackIsScheduled(); // firstCallbackNode 改变需要调用 进入调度过程 &#125; // next 为 fristCallbackNode 来看，把 next 放到原 firstCallbackNode 的位置，链表重新排序 var previous = next.previous; previous.next = next.previous = newNode; newNode.next = next; newNode.previous = previous; // 形成环状的链表结构 &#125; return newNode;&#125; ensureHostCallbackIsScheduled 检查是否用 callbackNode 正在执行，否则停止 判断 hostCallback 是否在调度，已经调度就取消 执行 requestHostCallback 方法12345678910111213141516function ensureHostCallbackIsScheduled() &#123; if (isExecutingCallback) &#123; // 代表已经有个 callbackNode 调用了 // Don&#x27;t schedule work yet; wait until the next time we yield. return; &#125; // Schedule the host callback using the earliest expiration in the list. var expirationTime = firstCallbackNode.expirationTime; if (!isHostCallbackScheduled) &#123; // 判断这个 callback 有没有进入调度 isHostCallbackScheduled = true; &#125; else &#123; // Cancel the existing host callback. cancelHostCallback(); // 已经有了就退出 &#125; // 执行 requestHostCallback(flushWork, expirationTime);&#125; requestHostCallback1234567891011121314151617requestHostCallback = function(callback, absoluteTimeout) &#123; scheduledHostCallback = callback; timeoutTime = absoluteTimeout; // absoluteTimeout &lt; 0 已经超时了，isFlushingHostCallback 强制执行 if (isFlushingHostCallback || absoluteTimeout &lt; 0) &#123; // 不等了直接调用 // Don&#x27;t wait for the next frame. Continue working ASAP, in a new event. window.postMessage(messageKey, &#x27;*&#x27;); &#125; else if (!isAnimationFrameScheduled) &#123; // isAnimationFrameScheduled = false 还没进入调度循环 // If rAF didn&#x27;t already schedule one, we need to schedule a frame. // TODO: If this rAF doesn&#x27;t materialize because the browser throttles, we // might want to still have setTimeout trigger rIC as a backup to ensure // that we keep performing work. isAnimationFrameScheduled = true; // 进入调度循环 requestAnimationFrameWithTimeout(animationTick); // 进入调度，竞争调用 animationTick &#125;&#125;; requestAnimationFrameWithTimeout requestAnimationFrameWithTimeout 里，把 animationTick callback 放入浏览器动画回调里，如果 100ms 后还没有执行就通过 timeout 自动执行。12345678910111213// 100ms 内竞争调用 本地 localRequestAnimationFrame 和 localSetTimeoutvar requestAnimationFrameWithTimeout = function(callback) &#123; // localRequestAnimationFrame 执行了，就取消 localSetTimeout, 互相竞争的关系 rAFID = localRequestAnimationFrame(function(timestamp) &#123; // 浏览器的 api localClearTimeout(rAFTimeoutID); callback(timestamp); // 传入动画时间戳 &#125;); // 如果 100ms localRequestAnimationFrame 里的 callback 没执行，就取消 localRequestAnimationFrame 自己执行 rAFTimeoutID = localSetTimeout(function() &#123; localCancelAnimationFrame(rAFID); callback(getCurrentTime()); // 传入当前时间 &#125;, ANIMATION_FRAME_TIMEOUT);&#125;; animationTick 处于浏览器 requestAnimationFrame 的回调中，为了节约时间不停地调用自己 通过 前后两次调用时间来判断当前浏览器的刷新频率 当 isMessageEventScheduled 变量为 \bfalse 后 通过 postMessage 发送事件给任务队列插入 react 任务，这才是一帧中做的事。12345678910111213141516171819202122232425262728293031// rafTime 就是 animationTick 调用的时间var animationTick = function(rafTime) &#123; if (scheduledHostCallback !== null) &#123; // 立马请求下一帧调用自己, 不停的调用, 队列有很多 callback requestAnimationFrameWithTimeout(animationTick); &#125; else &#123; // 没有方法要被调度 isAnimationFrameScheduled = false; return; &#125; // rafTime 调用的当前时间，frameDeadline 为 0， activeFrameTime 33 保持浏览器一秒 30 帧每一帧的执行时间-一帧完整的时间 // 下一帧我可以执行的时间是多少 var nextFrameTime = rafTime - frameDeadline + activeFrameTime; if ( nextFrameTime &lt; activeFrameTime &amp;&amp; previousFrameTime &lt; activeFrameTime ) &#123; // 如果连续两次帧的调用计算出来的时间是小于33ms 目前的帧时间的，就设置帧时间变小. 主要针对不同平台，比如 vr 120帧，设置平台的刷新平台设置 activeFrameTime if (nextFrameTime &lt; 8) &#123; nextFrameTime = 8; &#125; activeFrameTime = nextFrameTime &lt; previousFrameTime ? previousFrameTime : nextFrameTime; &#125; else &#123; // previousFrameTime = nextFrameTime; &#125; frameDeadline = rafTime + activeFrameTime; // 第一个 frameDeadLine if (!isMessageEventScheduled) &#123; isMessageEventScheduled = true; window.postMessage(messageKey, &#x27;*&#x27;); // 给任务队列插入 react 任务，等浏览器执行完自己的任务再执行这里队列里的 &#125;&#125;; idleTick 接受判断 react 任务 判断当前帧是否把时间用完了，帧时间用完了任务又过期了 didTimout 标志过期 没用完继续或调用动画，保存任务等它过期再调用 最后判断 callback 不为空，调用过期的 react 任务。 这个方法保证了动画最大限度的执行，react 更新任务只有到时间才会执行1234567891011121314151617181920212223242526272829303132333435363738394041424344window.addEventListener(&#x27;message&#x27;, idleTick, false); // 接受 react 任务队列 var idleTick = function(event) &#123; // 判断 key，避免接收到其他非 react 的消息 if (event.source !== window || event.data !== messageKey) &#123; return; &#125; isMessageEventScheduled = false; // 赋值再重置 scheduledHostCallback 是 requestHostCallback 传入的 flushWork var prevScheduledCallback = scheduledHostCallback; var prevTimeoutTime = timeoutTime; scheduledHostCallback = null; timeoutTime = -1; var currentTime = getCurrentTime(); var didTimeout = false; // 浏览器动画或用户反馈操作超过 33ms, 把这一帧的时间用完了，react 没有时间去更新了 if (frameDeadline - currentTime &lt;= 0) &#123; // prevTimeoutTime 也就是 timeoutTime &lt;= currentTime，当前任务也已经过期了，需要强行更新了 if (prevTimeoutTime !== -1 &amp;&amp; prevTimeoutTime &lt;= currentTime) &#123; didTimeout = true; // 准备强制更新 &#125; else &#123; // No timeout. 没过期直接调用 requestAnimationFrameWithTimeout if (!isAnimationFrameScheduled) &#123; isAnimationFrameScheduled = true; requestAnimationFrameWithTimeout(animationTick); &#125; scheduledHostCallback = prevScheduledCallback; timeoutTime = prevTimeoutTime; return; &#125; &#125; // callback 不为空 if (prevScheduledCallback !== null) &#123; isFlushingHostCallback = true; // 正在调用这个 callback try &#123; // 强制执行 prevScheduledCallback(didTimeout); &#125; finally &#123; isFlushingHostCallback = false; // 强制更新完恢复 false &#125; &#125; &#125;; flushWork 通过判断 callback 已经过期或当前帧还有时间才开始真正执行 finally 最后 firstCallbackNode 不为空调 isHostCallbackScheduled 为 true , ensureHostCallbackIsScheduled 会执行 cancelHostCallback 重置所有的调度常量，老 callback 就不会被执行1234567891011121314151617181920212223242526272829303132333435363738394041424344// 强制执行过期任务function flushWork(didTimeout) &#123; isExecutingCallback = true; // 开始真正调用 callback deadlineObject.didTimeout = didTimeout; try &#123; if (didTimeout) &#123; // firstCallbackNode 已经过期 // Flush all the expired callbacks without yielding. while (firstCallbackNode !== null) &#123; var currentTime = getCurrentTime(); // 第一个 expirationTime 肯定小于 currentTime, 为过期任务 if (firstCallbackNode.expirationTime &lt;= currentTime) &#123; do &#123; // 执行的同时进行链表操作 flushFirstCallback(); // 真正执行了回调, 一直到第一个没有过期的任务为止 &#125; while ( firstCallbackNode !== null &amp;&amp; firstCallbackNode.expirationTime &lt;= currentTime // 链表循环判断过期了 ); continue; &#125; break; &#125; &#125; else &#123; //继续刷新回调，直到帧中的时间不足为止。 // Keep flushing callbacks until we run out of time in the frame. if (firstCallbackNode !== null) &#123; do &#123; flushFirstCallback(); &#125; while ( firstCallbackNode !== null &amp;&amp; getFrameDeadline() - getCurrentTime() &gt; 0 // 帧还有时间空闲才执行 ); &#125; &#125; &#125; finally &#123; isExecutingCallback = false; if (firstCallbackNode !== null) &#123; ensureHostCallbackIsScheduled();// 这时候执行 isHostCallbackScheduled 为 true 会执行 cancelHostCallback 重置所有的调度常量，老 callback 就不会被执行 &#125; else &#123; isHostCallbackScheduled = false; &#125; flushImmediateWork(); &#125;&#125; deadlineObject.timeRemaining deadlineObject 上 还有个 timeRemaining 属性 剩余时间 remaining 表示 这一帧的渲染是否超过 在 shouldYield 中使用并判断12345678910111213141516171819202122232425var timeRemaining; // 剩余时间if (hasNativePerformanceNow) &#123; timeRemaining = function() &#123; if ( firstCallbackNode !== null &amp;&amp; firstCallbackNode.expirationTime &lt; currentExpirationTime // 不成立 不看 ) &#123; return 0; &#125; var remaining = getFrameDeadline() - performance.now(); return remaining &gt; 0 ? remaining : 0; // 这一帧的渲染是否超过 在 shouldYield 中使用并判断 &#125;;&#125; else &#123; // 不走这里 timeRemaining = function() &#123; // Fallback to Date.now() if ( firstCallbackNode !== null &amp;&amp; firstCallbackNode.expirationTime &lt; currentExpirationTime ) &#123; return 0; &#125; var remaining = getFrameDeadline() - Date.now(); return remaining &gt; 0 ? remaining : 0; // 判断这一帧是否已经超过 &#125;;&#125; shouldYield 用来 timeRemaining 剩余时间跟常量比较获取是否该跳出的判断1234567891011121314// 应该跳出了function shouldYield() &#123; if (deadlineDidExpire) &#123; return true; &#125; if ( deadline === null || deadline.timeRemaining() &gt; timeHeuristicForUnitOfWork // 通过比较常量 ) &#123; // 当前帧 return false 还有剩余时间可以执行 return false; &#125; deadlineDidExpire = true; // 这一帧的渲染时间已经超时 return true;&#125; flushFirstCallback 处理链表后执行 callback callbackID &#x3D; scheduleDeferredCallback(performAsyncWork, {timeout});123456789101112131415161718192021222324252627282930313233343536function flushFirstCallback() &#123; var flushedNode = firstCallbackNode; // Remove the node from the list before calling the callback. That way the // list is in a consistent state even if the callback throws. var next = firstCallbackNode.next; if (firstCallbackNode === next) &#123; // 链表当前元素等于下一个，已经为空了 // This is the last callback in the list. firstCallbackNode = null; next = null; &#125; else &#123; // 环状结构 var lastCallbackNode = firstCallbackNode.previous; firstCallbackNode = lastCallbackNode.next = next; next.previous = lastCallbackNode; &#125; flushedNode.next = flushedNode.previous = null; // Now it&#x27;s safe to call the callback. var callback = flushedNode.callback; var expirationTime = flushedNode.expirationTime; var priorityLevel = flushedNode.priorityLevel; var previousPriorityLevel = currentPriorityLevel; var previousExpirationTime = currentExpirationTime; currentPriorityLevel = priorityLevel; currentExpirationTime = expirationTime; var continuationCallback; try &#123; continuationCallback = callback(deadlineObject); // 执行 callback &#125; finally &#123; currentPriorityLevel = previousPriorityLevel; currentExpirationTime = previousExpirationTime; &#125;// ... 暂时没作用&#125; performWork 调度完成回到 ReactDOM performWork 通过 performAsyncWork 异步方式 和 performSyncWork 同步方式调用 异步情况给 performWork 设置的 minExpirationTime 是 NoWork 0，并且会判断dl.didTimeout，这个值是指任务的 expirationTime 是否已经超时，如果超时了，则通过 didExpireAtExpirationTime 直接设置 newExpirationTimeToWorkOn 为当前时间，表示这个任务直接执行就行了，不需要判断是否超过了帧时间 同步方式久比较简单了，设置 minExpirationTime 为 Sync 112345678910111213141516171819function performAsyncWork(dl) &#123; // true if (dl.didTimeout) &#123; // 任务过期，立即执行 if (firstScheduledRoot !== null) &#123; recomputeCurrentRendererTime(); // 设置当前渲染时间为当前时间 let root: FiberRoot = firstScheduledRoot; do &#123; // 标记 root 节点变量, 如果当前任务过期设置为当前时间为 expirationTime didExpireAtExpirationTime(root, currentRendererTime); root = (root.nextScheduledRoot: any); // 下一个 root &#125; while (root !== firstScheduledRoot); &#125; &#125; performWork(NoWork, dl);&#125;function performSyncWork() &#123; performWork(Sync, null);&#125; 核心功能 是否有 deadline 的区分时间片更新后还有没有时间 循环渲染 Root 的条件循环不同 root 和不同优先级任务来更新 超过时间片的处理dealine 这一帧的时间到了把执行权交回浏览器 源码 通过 findHighestPriorityRoot 找到优先级最高的下一个需要渲染的 root: nextFlushedRoot 和对应的 expirtaionTime: nextFlushedExpirationTime 根据 deadline 判断 performWorkOnRoot 参数 相同部分1234nextFlushedRoot !== null &amp;&amp; // 判断下一个输出节点不是 nullnextFlushedExpirationTime !== NoWork &amp;&amp; // 过期时间不是 NoWork(minExpirationTime === NoWork || // 超时时间是 NoWork minExpirationTime &gt;= nextFlushedExpirationTime) &amp;&amp; // 超时时间大于下个节点或 普通情况 minExpirationTime 应该就等于nextFlushedExpirationTime 因为都来自同一个 root，nextFlushedExpirationTime 是在 findHighestPriorityRoot 阶段读取出来的 root.expirationTime 异步的判断1234567891011121314 while ( nextFlushedRoot !== null &amp;&amp; nextFlushedExpirationTime !== NoWork &amp;&amp; (minExpirationTime === NoWork || minExpirationTime &gt;= nextFlushedExpirationTime) &amp;&amp; // deadlineDidExpire 判断时间片是否过期 shouldYield 中判断 (!deadlineDidExpire || currentRendererTime &gt;= nextFlushedExpirationTime) // currentRendererTime &gt;= nextFlushedExpirationTime 超时了 performWorkOnRoot( nextFlushedRoot, nextFlushedExpirationTime, currentRendererTime &gt;= nextFlushedExpirationTime, // 超时了 );// ...&#125; deadline 设置的 deadlineDidExpire 用来判断时间片是否到期的当前渲染时间 currentRendererTime 比较 nextFlushedExpirationTime 判断任务是否已经超时1(!deadlineDidExpire || currentRendererTime &gt;= nextFlushedExpirationTime) 同步的判断123456789 while ( nextFlushedRoot !== null &amp;&amp; nextFlushedExpirationTime !== NoWork &amp;&amp; (minExpirationTime === NoWork || minExpirationTime &gt;= nextFlushedExpirationTime) ) &#123; performWorkOnRoot(nextFlushedRoot, nextFlushedExpirationTime, true);// ...&#125; 全部流程12345678910111213141516171819202122232425262728293031323334353637383940414243444546// currentRendererTime 计算从页面加载到现在为止的毫秒数// currentSchedulerTime 也是加载到现在的时间，isRendering === true的时候用作固定值返回，不然每次requestCurrentTime都会重新计算新的时间function performWork(minExpirationTime: ExpirationTime, dl: Deadline | null) &#123; deadline = dl; // 找到优先级最高的下一个需要渲染的 root: nextFlushedRoot 和对应的 expirtaionTime: nextFlushedExpirationTime findHighestPriorityRoot(); if (deadline !== null) &#123; recomputeCurrentRendererTime(); // 重新计算 currentRendererTime currentSchedulerTime = currentRendererTime; if (enableUserTimingAPI) &#123; const didExpire = nextFlushedExpirationTime &lt; currentRendererTime; const timeout = expirationTimeToMs(nextFlushedExpirationTime); stopRequestCallbackTimer(didExpire, timeout); &#125; while ( nextFlushedRoot !== null &amp;&amp; nextFlushedExpirationTime !== NoWork &amp;&amp; (minExpirationTime === NoWork || minExpirationTime &gt;= nextFlushedExpirationTime) &amp;&amp; // deadlineDidExpire 判断时间片是否过期 shouldYield 中判断 (!deadlineDidExpire || currentRendererTime &gt;= nextFlushedExpirationTime) // currentRendererTime &gt;= nextFlushedExpirationTime 超时了 ) &#123; performWorkOnRoot( nextFlushedRoot, nextFlushedExpirationTime, currentRendererTime &gt;= nextFlushedExpirationTime, // 超时了 true ); findHighestPriorityRoot(); recomputeCurrentRendererTime(); currentSchedulerTime = currentRendererTime; &#125; &#125; else &#123; while ( nextFlushedRoot !== null &amp;&amp; nextFlushedExpirationTime !== NoWork &amp;&amp; (minExpirationTime === NoWork || minExpirationTime &gt;= nextFlushedExpirationTime) ) &#123; performWorkOnRoot(nextFlushedRoot, nextFlushedExpirationTime, true); findHighestPriorityRoot(); &#125; &#125; findHighestPriorityRoot正常情况 React 应用只会有一个 root 执行下面逻辑 123456if (root === root.nextScheduledRoot) &#123; // This is the only root in the list. root.nextScheduledRoot = null; firstScheduledRoot = lastScheduledRoot = null; break;&#125; 最后 &#x2F;&#x2F; 找到优先级最高的下一个需要渲染的 root: nextFlushedRoot 和对应的 expirtaionTime: nextFlushedExpirationTime performWorkOnRoot renderRoot 渲染阶段 completeRoot 提交阶段 同步异步调用 renderRoot 区别在于 isYieldy isYieldy &#x3D; false 和 shouldYield &#x3D; false 表示任务不可中断，执行的是同步任务或者已经过期的任务或时间片有剩余时间执行 同步情况直接进入 renderRoot 渲染阶段再进入 completeRoot 提交阶段 异步情况先进入 renderRoot 渲染阶段，然后根据 shouldYield(是否该暂停跳出) 判断是否需要中断 shouldYield &#x3D; false 当前帧还有时间，进入 completeRoot 提交阶段，true 则当前帧没有时间待到下一次 requestIdleCallback 之后执行 最后 isRendering &#x3D; false finishedWork 是已经完成 renderRoot 渲染阶段的任务，只有 renderRoot 后才不为 null completeRoot 只有在 renderRoot 渲染阶段完成 finishedWork 不为 null 时才能执行 判断 finishedWork !&#x3D;&#x3D; null 是因为当前时间片可能 renderRoot 结束了没时间 completeRoot，如果新的时间片中有完成 renderRoot 的 finishedWork 就直接 completeRoot12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455function performWorkOnRoot( root: FiberRoot, expirationTime: ExpirationTime, isExpired: boolean,) &#123; isRendering = true; if (deadline === null || isExpired) &#123; // 同步 let finishedWork = root.finishedWork; // 因为有可能 renderRoot 执行完了 finishedWork != null 但是没时间 completeRoot， 所以每次都判断一下 if (finishedWork !== null) &#123; completeRoot(root, finishedWork, expirationTime); &#125; else &#123; root.finishedWork = null; const timeoutHandle = root.timeoutHandle; if (timeoutHandle !== noTimeout) &#123; root.timeoutHandle = noTimeout; cancelTimeout(timeoutHandle); &#125; const isYieldy = false; renderRoot(root, isYieldy, isExpired); finishedWork = root.finishedWork; if (finishedWork !== null) &#123; completeRoot(root, finishedWork, expirationTime) &#125; &#125; &#125; else &#123; // 异步 let finishedWork = root.finishedWork; if (finishedWork !== null) &#123; completeRoot(root, finishedWork, expirationTime); &#125; else &#123; root.finishedWork = null; const timeoutHandle = root.timeoutHandle; if (timeoutHandle !== noTimeout) &#123; root.timeoutHandle = noTimeout; cancelTimeout(timeoutHandle); &#125; const isYieldy = true; renderRoot(root, isYieldy, isExpired); finishedWork = root.finishedWork; if (finishedWork !== null) &#123; if (!shouldYield()) &#123; // 不可以中断，进入 commit 阶段 completeRoot(root, finishedWork, expirationTime); &#125; else &#123; // 可以中断，记录 finishedWork, 此时只执行了 render 阶段 renderRoot 没执行 commit 阶段 completeRoot 待到下个时间段进入 performWorkOnRoot 判断 root.finishedWork = finishedWork; &#125; &#125; &#125; &#125; isRendering = false;&#125; renderRoot 的概览核心功能 进入 workLoop 进行循环单元更新对整颗 fiberTree 都遍历一遍 更新时捕获错误并进行处理 更新流程结束后的处理 nextUnitOfWork 是每个更新完的 fiber 的 child，也就是子节点 nextUnitOfWork &#x3D; createWorkInProgress() 拷贝一份 fiber 节点，在 nextUnitOfWork 中修改，防止改变当前 fiberTree1234567891011121314151617181920212223242526272829function renderRoot(root: FiberRoot, isYieldy: boolean, isExpired: boolean) &#123; // ... if ( // 将要执行的任务 root 和 expirationTime 和 nextRenderExpirationTime、nextRoot 预期的不一样， 应该是之前任务被高优先级的任务打断了。 expirationTime !== nextRenderExpirationTime || root !== nextRoot || nextUnitOfWork === null // 更新结束 fiber 的 child，下一个节点, 首次 = null ) &#123; // 初始化的内容 resetStack(); // 重置 nextRoot = root; nextRenderExpirationTime = expirationTime; // root.nextExpirationTimeToWorkOn; nextUnitOfWork = createWorkInProgress( // 拷贝了一份 fiber 对象操作 nextRoot.current, null, nextRenderExpirationTime, ); root.pendingCommitExpirationTime = NoWork; // 设置成 NoWork // ... &#125;// 开始进入 workLoop do &#123; try &#123; workLoop(isYieldy); // 进行每个节点的更新 &#125; catch (thrownValue) &#123; // ... break; // 遇到了某种错误跳出 &#125; while(true)&#125; ###\b执行流程 执行 workLoop 在 performUnitOfWork 中执行 beginWork 进行更新 1234567891011121314function workLoop(isYieldy) &#123; if (!isYieldy) &#123; // 不可中断 Sync 和 超时任务不可中断 // Flush work without yielding // nextUnitOfWork 是 fiber 对象，为 null 已经是 root 节点 fiber return 的 null 了 while (nextUnitOfWork !== null) &#123; nextUnitOfWork = performUnitOfWork(nextUnitOfWork); // 进行更新 &#125; &#125; else &#123; // Flush asynchronous work until the deadline runs out of time. while (nextUnitOfWork !== null &amp;&amp; !shouldYield()) &#123; // 判断 shouldYield = false 当前时间片是否有时间更新 nextUnitOfWork = performUnitOfWork(nextUnitOfWork); &#125; &#125;&#125; workLoop 过程中的 catch 1234567do &#123; try &#123; workLoop(isYieldy); // 进行每个节点的更新 &#125; catch (thrownValue) &#123; // ... break; // 遇到了某种错误跳出 &#125; while(true) workLoop 后的错误处理和提交 1234567891011// 致命错误if (didFatal) &#123; &#125;// workLoop break 中断的错误if (nextUnitOfWork !== null) &#123; &#125;// 可处理的错误if (nextRenderDidError) &#123; &#125;// 准备提交onComplete(root, rootWorkInProgress, expirationTime);plete()","categories":[],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"}]},{"title":"React 源码解析 - React 创建更新回顾和 React 的批量更新","slug":"React 源码解析 - React 创建更新回顾和 React 的批量更新 ","date":"2019-02-23T15:23:53.000Z","updated":"2023-09-19T15:19:06.887Z","comments":true,"path":"2019/02/23/React 源码解析 - React 创建更新回顾和 React 的批量更新 /","link":"","permalink":"http://yoursite.com/2019/02/23/React%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%20-%20React%20%E5%88%9B%E5%BB%BA%E6%9B%B4%E6%96%B0%E5%9B%9E%E9%A1%BE%E5%92%8C%20React%20%E7%9A%84%E6%89%B9%E9%87%8F%E6%9B%B4%E6%96%B0%20/","excerpt":"","text":"回顾 React 更新创建更新 ReactDOM.render 初始渲染每次调用都通过传入的 &lt;App /&gt;, getElementById(&#39;app&#39;) 构建 root 节点，每个 rootFiber 都有独立的 updateQueue 和 fiberTree，最后调用 ReactRoot.prototypye.render 来创建更新。 setState &amp; forceUpdate 更新渲染都是 Component 构造函数的原型方法，目的都是给节点的 fiber 对象上创建更新，区别在于更新的类型不同。创建更新 update，记录当前时间，计算 expirationTime，设置当前更新的 payload，再把 update 推入 fiber 对象的 updateQueue 属性上, 之后进入调度流程。\b expirationTime由 ReactFiberReconciler.js 包，updateContainer 中的 const expirationTime = computeExpirationForFiber(currentTime, current); 计算出 12345678910111213141516function computeExpirationForFiber(currentTime: ExpirationTime, fiber: Fiber) &#123; let expirationTime;// ... if (fiber.mode &amp; ConcurrentMode) &#123; if (isBatchingInteractiveUpdates) &#123; // This is an interactive update 高优先级 expirationTime = computeInteractiveExpiration(currentTime); &#125; else &#123; // This is an async update 低优先级 expirationTime = computeAsyncExpiration(currentTime); &#125; &#125; else &#123; // This is a sync update expirationTime = Sync; &#125;&#125; 简化 computeExpirationForFiber 函数 发现 expirationTime 正常情况是 Sync &#x3D; 1 同步的 只有在 fiber.mode 存在并且使用 ConcurrentMode 新版本的异步更新模式时才会真正的计算 expirationTime ConcurrentMode 模式下还会根据 isBatchingInteractiveUpdates 全局变量判断当前更新的上下文环境来决定 expirationTime 是高优先级还是低优先级的运算结果。(isBatchingInteractiveUpdates 在 batchedUpdates 中讲解） scheduleWork 开始调度核心功能 找到更新对应的 FiberRoot 节点setState 时传入的都是组件的 Fiber 节点而不是 FiberRoot 节点 符合条件时 - 重置 stack具有公共变量，用于调度和更新 符合条件时 - 请求工作调度 回顾 FiberTree FiberTree 属性1 child 为第一个子节点2 sibling 为兄弟节点3 return 为父节点，只有 RootFiber 对象 renturn 为 null4 FiberRoot.current 和 RootFiber.stateNode 互相引用 执行操作时的 Fiber 对象1 点击组件上的元素2 执行组件的原型方法调用 setState3 把 RootFiber 加入到调度中 scheduleWork 进入调度队列 每一次进入调度队列的只有 FiberRoot 对象, 更新也是从 FiberRoot 对象上开始的。 12345678910111213141516171819202122232425262728293031function scheduleWork(fiber: Fiber, expirationTime: ExpirationTime) &#123; // 找到 root 更新 FiberTree 上的所有 expirationTime const root = scheduleWorkToRoot(fiber, expirationTime); if (root === null) &#123; // 没有 FiberRoot 暂停 return; &#125; if ( !isWorking &amp;&amp; // 没有执行渲染 nextRenderExpirationTime !== NoWork &amp;&amp; // 任务是个异步的，执行到一半了，交还给浏览器执行 expirationTime &lt; nextRenderExpirationTime // 新的任务优先级高于现在的任务 ) &#123; // This is an interruption. (Used for performance tracking.) interruptedBy = fiber; // 记录 resetStack(); // 优先执行高优先级任务 &#125; markPendingPriorityLevel(root, expirationTime); if ( !isWorking || // 没有正在工作 isCommitting || // 或者正在提交，也就是更新dom 树的渲染阶段 nextRoot !== root // 不同的 root 一般不存在不同 ) &#123; const rootExpirationTime = root.expirationTime; requestWork(root, rootExpirationTime); // 请求工作 &#125; if (nestedUpdateCount &gt; NESTED_UPDATE_LIMIT) &#123; // Reset this back to zero so subsequent updates don&#x27;t throw. nestedUpdateCount = 0; invariant( false, 超出最大更新深度。 当组件在componentWillUpdate或componentDidUpdate中重复调用setState时，可能会发生这种情况。 React限制嵌套更新的数量以防止无限循环。 ); &#125;&#125; scheduleWorkToRoot 通过 Fiber 对象找到 RootFiber 对象进行调度\b 根据传入的 Fiber 对象向上寻找到 RootFiber 对象 同时更新所有子树上面的 expirationTime 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455function scheduleWorkToRoot(fiber: Fiber, expirationTime): FiberRoot | null &#123; // ... if ( // 更新 fiber 对象上 expirationTime fiber.expirationTime === NoWork || // 没有任何更新操作的 fiber.expirationTime &gt; expirationTime // 有更新产生，但是优先级低于新计算的 expirationTime ) &#123; // 设置成最新的 expirationTime fiber.expirationTime = expirationTime; &#125; let alternate = fiber.alternate; if ( alternate !== null &amp;&amp; (alternate.expirationTime === NoWork || alternate.expirationTime &gt; expirationTime) ) &#123; // 逻辑和上面一样，更新 alternate 的expirationTime alternate.expirationTime = expirationTime; &#125; // 通过 FiberTree 的属性向上寻找 FiberRoot 并更新每个子 fiber 对象的 expirationTime let node = fiber.return; // renturn 父节点， let root = null; // node === null 就是 FiberRoot 对象 if (node === null &amp;&amp; fiber.tag === HostRoot) &#123; root = fiber.stateNode; &#125; else &#123; // 循环查找 FiberRoot while (node !== null) &#123; alternate = node.alternate; if ( // 更新 expirationTime node.childExpirationTime === NoWork || node.childExpirationTime &gt; expirationTime ) &#123; node.childExpirationTime = expirationTime; if ( alternate !== null &amp;&amp; (alternate.childExpirationTime === NoWork || alternate.childExpirationTime &gt; expirationTime) ) &#123; alternate.childExpirationTime = expirationTime; &#125; &#125; else if ( alternate !== null &amp;&amp; (alternate.childExpirationTime === NoWork || alternate.childExpirationTime &gt; expirationTime) ) &#123; alternate.childExpirationTime = expirationTime; &#125; // 找到 FiberRoot 结束循环 if (node.return === null &amp;&amp; node.tag === HostRoot) &#123; root = node.stateNode; break; &#125; // 继续向父节点查找 node = node.return; &#125; &#125; resetStack 当发现当前任务的优先级大于下一个任务的优先级时，把下个任务的优先级重置执行当前任务 resetStack 在重置下个任务时，会先记录这个任务，等待以后执行，并且使用 unwindInterruptedWork 来重置这个任务 fiber 上级的状态 123456789if ( !isWorking &amp;&amp; // 没有执行渲染 nextRenderExpirationTime !== NoWork &amp;&amp; // 任务是个异步的，执行到一半了，交还给浏览器执行 expirationTime &lt; nextRenderExpirationTime // 新的任务优先级高于现在的任务) &#123; // This is an interruption. (Used for performance tracking.) interruptedBy = fiber; // 记录 resetStack(); // 优先执行高优先级任务&#125; 12345678910111213141516171819function resetStack() &#123; // nextUnitOfWork 被打断的任务 if (nextUnitOfWork !== null) &#123; // 记录，等待以后执行 let interruptedWork = nextUnitOfWork.return; while (interruptedWork !== null) &#123; // 退回任务 unwindInterruptedWork(interruptedWork); interruptedWork = interruptedWork.return; &#125; &#125; // 变回初始值，进行新任务更新 nextRoot = null; nextRenderExpirationTime = NoWork; nextLatestAbsoluteTimeoutMs = -1; nextRenderDidError = false; nextUnitOfWork = null;&#125; 何时执行 requestWorkisWorking, isCommitting 是 react 渲染的两个不同阶段， isWorkingworking 包含 committing(不可打断) isCommittingfiberTree 的更新已经结束，正在提交也就是更新dom 树的渲染阶段, 不可打断12345678if ( !isWorking || // 没有正在工作 isCommitting || // 或者正在提交，也就是更新dom 树的渲染阶段 nextRoot !== root // 不同的 root 一般不存在不同) &#123; const rootExpirationTime = root.expirationTime; // 重新查找 root expirationTime，因为可能会改变 requestWork(root, rootExpirationTime); // 请求工作&#125; requestWork核心功能 将 root 节点加入到 root调度队列中 判断是否是批量更新 最后根据 expirationTime 的类型判断调度的类型 requestWork 流程12345678910111213141516171819202122232425262728function requestWork(root: FiberRoot, expirationTime: ExpirationTime) &#123; addRootToSchedule(root, expirationTime); // 把当前 root设置为最高优先级 // isRendering 调度已经在执行了, 循环已经开始了 if (isRendering) &#123; return; &#125; // 批量处理相关 // 调用 setState 时在 enqueueUpdates 前 batchedUpdates 会把 isBatchingUpdates 设置成 true if (isBatchingUpdates) &#123; // Flush work at the end of the batch. if (isUnbatchingUpdates) &#123; // ...unless we&#x27;re inside unbatchedUpdates, in which case we should // flush it now. nextFlushedRoot = root; nextFlushedExpirationTime = Sync; performWorkOnRoot(root, Sync, true); &#125; return; // isBatchingUpdates true // 普通的 setState 在进入 enqueueUpdates 时在这里直接不执行了，下面其实没进入调度 &#125; // TODO: Get rid of Sync and use current time? if (expirationTime === Sync) &#123; // 同步的调用 js 代码 performSyncWork(); &#125; else &#123; // 异步调度 独立的 react 模块包，利用浏览器有空闲的时候进行执行，设置 deadline 在此之前执行 scheduleCallbackWithExpirationTime(root, expirationTime); // 在 secheduler 文件夹下的单独模块 &#125;&#125; addRootToSchedule 判断当前 root 是否调度过, 单个或多个 root 构建成单向链表结构 如果调度过，设置当前任务优先级最高 123456789101112131415161718192021222324252627function addRootToSchedule(root: FiberRoot, expirationTime: ExpirationTime) &#123; // root.nextScheduledRoot 用来判断是否有异步任务正在调度, 为 null 时会增加 nextScheduledRoot // 这个 root 还没有进入过调度 if (root.nextScheduledRoot === null) &#123; root.expirationTime = expirationTime; // lastScheduledRoot firstScheduledRoot 是单向链表结构，表示多个 root 更新 // 这里只有一个 root 只会在这里执行 if (lastScheduledRoot === null) &#123; firstScheduledRoot = lastScheduledRoot = root; root.nextScheduledRoot = root; &#125; else &#123; // 有个多个root 时进行单向链表的插入操作 lastScheduledRoot.nextScheduledRoot = root; lastScheduledRoot = root; lastScheduledRoot.nextScheduledRoot = firstScheduledRoot; &#125; &#125; else &#123; // 传入的 root 已经进入过调度, 把 root 的优先级设置最高 const remainingExpirationTime = root.expirationTime; // 如果 root 的 expirationTime 是同步或者优先级低，增加为计算出的最高优先级 if ( remainingExpirationTime === NoWork || expirationTime &lt; remainingExpirationTime ) &#123; root.expirationTime = expirationTime; // 把当前 root 的优先级设置为当前优先级最高的 &#125; &#125;&#125; batchedUpdates 批量更新 每次 react 创建更新都会执行 requestWork。如: setState 在 requestWork 中决定 react 的更新是异步调度还是同步执行 setState 的调用12345678910111213141516171819202122232425262728293031323334353637383940414243444546import React from &#x27;react&#x27;import &#123; unstable_batchedUpdates as batchedUpdates &#125; from &#x27;react-dom&#x27;export default class BatchedDemo extends React.Component &#123; state = &#123; number: 0, &#125; handleClick = () =&gt; &#123; // 方法一 // 事件处理函数自带`batchedUpdates` // this.countNumber() // 执行的结果是 0, 0, 0 // 方法二 // 主动`batchedUpdates` setTimeout(() =&gt; &#123; this.countNumber() // 执行的结果是 1，2，3 &#125;, 0) // 方法三 // setTimeout中没有`batchedUpdates` // setTimeout(() =&gt; &#123; // batchedUpdates(() =&gt; this.countNumber()) // 执行的结果是 0, 0, 0 // &#125;, 0) &#125; countNumber() &#123; const num = this.state.number this.setState(&#123; number: num + 1, &#125;) console.log(this.state.number) this.setState(&#123; number: num + 2, &#125;) console.log(this.state.number) this.setState(&#123; number: num + 3, &#125;) console.log(this.state.number) &#125; render() &#123; return &lt;button onClick=&#123;this.handleClick&#125;&gt;Num: &#123;this.state.number&#125;&lt;/button&gt; &#125;&#125; requestWork 当 setState 创建更新后进入调度，执行到 requestWork 里时会判断一个 isBatchingUpdates 的全局变量。 \b 在 requestWork 中断点12345678910111213141516171819function requestWork(root: FiberRoot, expirationTime: ExpirationTime) &#123; debugger // ... if (isRendering) &#123; return; &#125; // 批量处理相关 // 调用 setState 时在 enqueueUpdates 前 batchedUpdates 会把 isBatchingUpdates 设置成 true if (isBatchingUpdates) &#123; if (isUnbatchingUpdates) &#123; nextFlushedRoot = root; nextFlushedExpirationTime = Sync; performWorkOnRoot(root, Sync, true); &#125; return; // isBatchingUpdates true // 普通的 setState 在进入 enqueueUpdates 时在这里直接不执行了，下面其实没进入调度 &#125; // 只有异步模式任务时才会执行 &#125; 在 requestWork 中断点，发现在判断 isBatchingUpdates 变量时就直接返回了，虽然 expirationTime 是 Sync 但是下面的 performSyncWork() 并不会执行。 setState 时先执行了一个 batchedUpdates 的函数。 多次的 setState 在 enqueueUpdates 函数中，fiber 对象的 baseState 仍然是 0, 但是 fiber 对象上的 updateQueue 更新队列上已经记录好了多次 update 对象将要更新 state 的 payload。 batchedUpdates 的源码 setState 在 batchedUpdates 中先把 isBatchingUpdates 暂存为 previousIsBatchingUpdates, 再设置为 true 防止在 requestWork 中执行。 在 try 代码块中执行组件的方法 fn，fn 不论执行多少次 setState 执行完了都会通过 finally 进入把 isBatchingUpdates 再设置回 false。 最后通过执行 performSyncWork() 方法，而不是在 requestWork 中调用。1234567891011121314function batchedUpdates&lt;A, R&gt;(fn: (a: A) =&gt; R, a: A): R &#123; const previousIsBatchingUpdates = isBatchingUpdates; // 初始为 false isBatchingUpdates = true; try &#123; return fn(a); // 执行组件绑定的方法, 走到 requestWork 里 &#125; finally &#123; // setState 最终 enqueueUpdates 全部走到 requestWork 后变回 false 再一同 performSyncWork 才真正的执行并改变 state isBatchingUpdates = previousIsBatchingUpdates; // 变回 false // 如果是 setTimeout(() =&gt; &#123; this.setState &#125;) setTimeout 走到这里后才执行 this.setState 这时上下文环境是 window isBatchingUpdates 已经 false，setState 就是同步的 if (!isBatchingUpdates &amp;&amp; !isRendering) &#123; performSyncWork(); // 当所有 setState 执行完全部enqueueUpdates 后代替 requestWork 来调度 &#125; &#125;&#125; 方法二 setTimout 执行方式123setTimeout(() =&gt; &#123; batchedUpdates(() =&gt; this.countNumber())&#125;, 0) setTimeout 等浏览器 API 执行的方式结果都会把三次 setState 结算的结果打印出来，像是一种同步的执行方式 再次 debugger ，这时在 batchedUpdates 函数中的 fn 的执行内容只是 setTimeout。 当 setTimeout 执行完后直接进入了 finally 代码块中，isBatchingUpdates 变回了 false \b当 setTimeout 结束执行回调中的 setState 进入 requestWork 时 isBatchingUpdates 已经变为 false，requestWork 将会执行下去，最终执行自己 performSyncWork() 三次 setState 都会通过 requestWork 执行 performSyncWork()，而不是之前通过 batchedUpdates 执行一次，所以每次 setState 的 update 都会立刻改变 state，结果也是同步的输出。 方法三 使用 batchedUpdates API batchedUpdates 让 setState 的更新仍然为批量更新 123setTimeout(() =&gt; &#123; batchedUpdates(() =&gt; this.countNumber())&#125;, 0) batchedUpdates API 其实就是 batchedUpdates 函数 setTimeout 执行回调时 batchedUpdates API 又把 isBatchingUpdates 设置为 true，让 多次的 setState 又能进行批量更新。123456789101112function batchedUpdates&lt;A, R&gt;(fn: (a: A) =&gt; R, a: A): R &#123; const previousIsBatchingUpdates = isBatchingUpdates; // 初始为 false isBatchingUpdates = true; try &#123; return fn(a); // 执行组件绑定的方法, 走到 requestWork 里 &#125; finally &#123; isBatchingUpdates = previousIsBatchingUpdates; // 变回 false if (!isBatchingUpdates &amp;&amp; !isRendering) &#123; performSyncWork(); // 当所有 setState 执行完全部enqueueUpdates 后代替 requestWork 来调度 &#125; &#125;&#125; 总结 setState 是同步还是异步 setState 本身的方法调用时同步的，但是调用 setState 不表示 state 立即更新的，state 的更新是根据我们执行环境的上下文来判断的。 如果处于批量更新的情况下 state 就不是立即更新的，如果不处于批量更新情况下有可能立即更新. 现在有 asyncMode 异步渲染的情况，state 也不是立即更新的，需要进入异步调度的过程。","categories":[],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"}]},{"title":"React 源码解析 React 的更新","slug":"React 源码解析 React 的更新 ","date":"2019-02-02T15:06:55.000Z","updated":"2023-09-19T15:17:33.325Z","comments":true,"path":"2019/02/02/React 源码解析 React 的更新 /","link":"","permalink":"http://yoursite.com/2019/02/02/React%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%20React%20%E7%9A%84%E6%9B%B4%E6%96%B0%20/","excerpt":"","text":"React 的更新只解析到创建更新进入调度器 创建更新的方式 初始渲染ReactDOM.renderReactDOM.hydrate 更新渲染setStateforceUpdate (舍弃) ReactDOM.render步骤 创建 ReactRoot最顶点的对象 创建 FiberRoot 和 RootFiber 创建更新 update用来更新调度, 进入调度后 setState 或 ReactDOM.render 都的调度器去管理的 初始渲染ReactDOM.renderReactDOM.render(&lt;App /&gt;, document.getElementById(&#39;root&#39;)) 只是调用了 createReactElement 生成了ReactElementReactDOM.render 把 这个 ReactElement 渲染成 dom tree 初始渲染在 react-dom&#x2F;client&#x2F;ReactDOM.js 文件下, 有 render hydrate 两个方法， render 是用在浏览器环境内的，hydrate 用在服务器环境下，唯一的区别是调用 legacyRenderSubtreeIntoContainer 方法传入的第四个参数不同。 1234567891011121314151617181920212223242526272829const ReactDOM = &#123; // ... hydrate(element: React$Node, container: DOMContainer, callback: ?Function) &#123; // TODO: throw or warn if we couldn&#x27;t hydrate? return legacyRenderSubtreeIntoContainer( null, element, container, true, callback, ); &#125;, render( element: React$Element&lt;any&gt;, container: DOMContainer, callback: ?Function, ) &#123; return legacyRenderSubtreeIntoContainer( null, element, container, false, callback, ); &#125;, // ...&#125; legacyRenderSubtreeIntoContainer 中 container 就是首次渲染传入的, 这个dom 肯定不存在 _reactRootContainer 属性，所以 !root 内的就是初次渲染的逻辑 而 root 是由首次渲染逻辑时 由 legacyCreateRootFromDOMContainer 生成的一个 Fiber 对象。1234root = container._reactRootContainer = legacyCreateRootFromDOMContainer( container, forceHydrate,); 123456789101112131415161718192021222324252627282930function legacyRenderSubtreeIntoContainer( parentComponent: ?React$Component&lt;any, any&gt;, children: ReactNodeList, container: DOMContainer, forceHydrate: boolean, callback: ?Function,) &#123; // ... // container 就是首次渲染传入的&lt;div id=&quot;root&quot;&gt;, 这个dom 肯定不存在 _reactRootContainer 属性，所以 !root 内的就是初次渲染的逻辑 let root: Root = (container._reactRootContainer: any); if (!root) &#123; // Initial mount 初次渲染，进行 new ReactRoot, 创建一个 createFiberRoot 回来 root = container._reactRootContainer = legacyCreateRootFromDOMContainer( container, forceHydrate, ); if (typeof callback === &#x27;function&#x27;) &#123; // 回调封装 &#125; // Initial mount should not be batched. unbatchedUpdates 批量更新 DOMRenderer.unbatchedUpdates(() =&gt; &#123; if (parentComponent != null) &#123; // render, hydrate 传入的 parentComponent 都是 null // 批量更新回调, ReactDOM.render 不执行 &#125; else &#123; root.render(children, callback); // 主要执行 ReactRoot 实例的 render &#125; &#125;); &#125; else &#123; // 更新渲染的逻辑 &#125; return DOMRenderer.getPublicRootInstance(root._internalRoot); // _internalRoot 是 new ReactRoot 生成的 Fiber 对象&#125; legacyCreateRootFromDOMContainer 就是把 root dom， container 内的其余节点清空创建一个 new ReactRoot 实例12345678910111213141516171819function legacyCreateRootFromDOMContainer( container: DOMContainer, // ReactDOM.render 传入的 root forceHydrate: boolean, // render: false, hydrate: true, SSR 时进行节点复用，也是 render hydrate 唯一的区别): Root &#123; const shouldHydrate = forceHydrate || shouldHydrateDueToLegacyHeuristic(container); // First clear any existing content. if (!shouldHydrate) &#123; // false 客户端渲染 let warned = false; let rootSibling; // 把 root 的所有子节点删掉 while ((rootSibling = container.lastChild)) &#123; container.removeChild(rootSibling); &#125; &#125; // Legacy roots are not async by default. root 节点创建时同步的，isConcurrent: false const isConcurrent = false; return new ReactRoot(container, isConcurrent, shouldHydrate);&#125; ReactRoot 生成实例创建了一个 root 实例属性，root 由 react-reconcile 模块包里的 createContainer 方法 调用 createFiberRoot 生成一个 Fiber 对象，最后挂载到实例的 _internalRoot 上1234567891011121314151617function ReactRoot( container: Container, isConcurrent: boolean, hydrate: boolean,) &#123; // 创建一个 createFiberRoot const root = DOMRenderer.createContainer(container, isConcurrent, hydrate); this._internalRoot = root;&#125;// DOMRenderer.createContainer export function createContainer( containerInfo: Container, isConcurrent: boolean, hydrate: boolean,): OpaqueRoot &#123; return createFiberRoot(containerInfo, isConcurrent, hydrate);&#125; legacyCreateRootFromDOMContainer 最终执行的 root.render 就是 new ReactRoot 的原型方法 ReactRoot.prototype.render , 最终是调用 react-reconcile 模块包里的 updatecontainer123456789101112131415ReactRoot.prototype.render = function( children: ReactNodeList, callback: ?() =&gt; mixed,): Work &#123; const root = this._internalRoot; // 一个 fiber root const work = new ReactWork(); callback = callback === undefined ? null : callback; if (callback !== null) &#123; work.then(callback); &#125; // render 的重点调用 DOMRenderer.updateContainer(children, root, null, work._onCommit); return work;&#125;; DOMRenderer.updateContainer 中计算出一个 expirationTime 传入了 updateContainerAtExpirationTime.12345678910111213141516171819export function updateContainer( element: ReactNodeList, // App container: OpaqueRoot, // 一个 fiber root parentComponent: ?React$Component&lt;any, any&gt;, callback: ?Function,): ExpirationTime &#123; const current = container.current; const currentTime = requestCurrentTime(); // 创建一个时间差 // 计算出一个时间，ConcurrentMode 会用到 const expirationTime = computeExpirationForFiber(currentTime, current); // 主要执行 return updateContainerAtExpirationTime( element, container, parentComponent, expirationTime, callback, );&#125; updateContainerAtExpirationTime 中调用 scheduleRootUpdate12345678910111213141516171819export function updateContainerAtExpirationTime( element: ReactNodeList, container: OpaqueRoot, parentComponent: ?React$Component&lt;any, any&gt;, expirationTime: ExpirationTime, callback: ?Function,) &#123; // TODO: If this is a nested container, this won&#x27;t be the root. const current = container.current; const context = getContextForSubtree(parentComponent); if (container.context === null) &#123; container.context = context; &#125; else &#123; container.pendingContext = context; &#125; return scheduleRootUpdate(current, element, expirationTime, callback);&#125; scheduleRootUpdate 中 使用 createUpdate 创建 update 来标记 react 需要更新的点 设置完 update 属性再调用 enqueueUpdate 把 update 放入更新队列里react 更新会在一个节点上整体进行很多个更新，这个更新 queue 就是管理多次更新的作用 最后执行 scheduleWork 通知 react 进行调度，根据任务的优先级进行更新。 12345678910111213141516171819202122232425262728function scheduleRootUpdate( current: Fiber, element: ReactNodeList, expirationTime: ExpirationTime, callback: ?Function,) &#123; const update = createUpdate(expirationTime); // 用来标记 react 更新的节点 // Caution: React DevTools currently depends on this property // being called &quot;element&quot;. update.payload = &#123;element&#125;; callback = callback === undefined ? null : callback; if (callback !== null) &#123; warningWithoutStack( typeof callback === &#x27;function&#x27;, &#x27;render(...): Expected the last optional `callback` argument to be a &#x27; + &#x27;function. Instead received: %s.&#x27;, callback, ); update.callback = callback; &#125; // 把更新的对象加入到 fiber 对象上的 updateQueue 里， 会有很多更新在一个节点上产生 enqueueUpdate(current, update); // 开始进行调度 scheduleWork(current, expirationTime); return expirationTime;&#125; ReactDOM.render 阶段总结 初次渲染 传入 APP 组件和 getElementById(root) 执行 ReactDOM.render ReactDOM.render 返回并执行 legacyRenderSubtreeIntoContainer legacyRenderSubtreeIntoContainer 内调用 legacyCreateRootFromDOMContainer 把返回值挂载到 root 节点的 _reactRootContainer 属性上 而 legacyCreateRootFromDOMContainer 把 getElementById(root) 里的子节点清空，创建并返回 new ReactRoot 给 getElementById(root) 的 _reactRootContainer 属性上 ReactRoot 生成实例时调用 react-reconcile 模块的 createContainer 传入 getElementById(root) 执行 createFiberRoot 生成一个 FiberRoot 对象挂载到实例的 _internalRoot legacyRenderSubtreeIntoContainer 最终调用 上面生成的 ReactRoot 实例的 ReactRoot.prototype.render 原型方法 ReactRoot.prototype.render 把子节点和实例生成的 _internalRoot Fiber 对象传入 react-reconcile 模块的 updateContainer 中 在 updateContainer 中 react 计算出一个 expirationTime 传入 updateContainerAtExpirationTime 调用 scheduleRootUpdate 中做三件事1 使用 createUpdate 创建 update 来标记 react 需要更新的点2 设置完 update 属性再调用 enqueueUpdate 把 update 放入当前节点树整体的更新队列里3 最后执行 scheduleWork 通知 react 进行调度，根据任务的优先级进行更新。 ReactDOM.render 此时 创建了一个 ReactRoot 对象挂载到 getElementById(root) 的 _reactRootContainer 属性上 同时 在 ReactRoot 实例 _internalRoot 属性上生成了 Fiber 对象 调用 ReactRoot.prototype.render 执行 react-reconcile 模块的 updateContainer 计算 expirationTime，通过 expirationTime 来创建 update 对象，推入 updateQueue 内，最后根据优先级进行调度。 FiberRoot 整个应用的起点 包含了传入的 getElementById(root) 记录整个应用更新过程的各种信息 containerInfo \b(包含了 root 节点等信息) FiberRoot 对象结构 FiberRoot 是 ReactRoot 生成实例时调用 react-reconcile 模块的 createContainer 传入 getElementById(root) 执行 createFiberRoot 生成一个 FiberRoot 对象挂载到实例的 _internalRoot 1234567891011121314151617181920212223242526272829303132333435export function createFiberRoot( containerInfo: any, isConcurrent: boolean, hydrate: boolean,): FiberRoot &#123; const uninitializedFiber = createHostRootFiber(isConcurrent); return root = (&#123; current: uninitializedFiber, // Fiber 对象通过 new Fiber 创建，与 ReactElement 对应也是树状结构，这里树的顶点 containerInfo: containerInfo, // 通过 render 方法传入的 root 节点, 应用挂载的节点 pendingChildren: null, // ssr 用来复用节点的 // 任务调度的时间标记优先级 earliestPendingTime: NoWork, latestPendingTime: NoWork, earliestSuspendedTime: NoWork, latestSuspendedTime: NoWork, latestPingedTime: NoWork, // 标记渲染过程中是否有错误 didError: false, // 正在等待提交的任务 pendingCommitExpirationTime: NoWork, finishedWork: null, // 记录一次更新渲染过程完成的任务 Fiber 对象 timeoutHandle: noTimeout, context: null, pendingContext: null, hydrate, nextExpirationTimeToWorkOn: NoWork, // 标记此次更新要执行的是哪个优先级的任务 expirationTime: NoWork, // 用在调度中 firstBatch: null, nextScheduledRoot: null, // 链表属性 interactionThreadID: unstable_getThreadID(), memoizedInteractions: new Set(), pendingInteractionMap: new Map(), &#125;: FiberRoot);&#125; Fiber FiberRoot.current 就是一个 Fiber 对象 每一个 ReactElement 对应一个 Fiber 对象 记录节点的各种状态class 组件的 this.state、this.props ，在 Fiber 更新后才会更新 class 组件上的 this.state, props，也是 hooks 实现的原理，function 组件是没有 this.state this.props 的，Fiber 有能力记录这些状态之后在 function 组件更新后拿到这些状态。 串联整个应用形成的树结构 ReactElement 对应的结构 Fiber 的数据结构FiberNode 有三个属性 return、child、sibling, 分别代表此 Fiber 对象的父节点，第一个子节点，自己的兄弟节点 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748function FiberNode( tag: WorkTag, pendingProps: mixed, key: null | string, mode: TypeOfMode,) &#123; // Instance this.tag = tag; // 标记不同的组件类型，不同的更新方式 this.key = key; // key this.elementType = null; // createElement 第一个参数，组件 或者 标签 this.type = null; // 记录异步组件 resolved 后是 class 还是 function 组件 this.stateNode = null; // 节点的实例，对应 class 组件或者 dom 节点，function 没有实例就没 stateNode // Fiber this.return = null; // 父亲节点 this.child = null; // 第一个子节点 this.sibling = null; // 自己的下一个兄弟节点 this.index = 0; this.ref = null; // ref this.pendingProps = pendingProps; // 每个创建的新 props this.memoizedProps = null; // 老 props this.updateQueue = null; // 节点创建的 update 对象 queue this.memoizedState = null; // 老 state，新 state 是由 updateQueue 计算出来的然后覆盖这里 this.firstContextDependency = null; // context 相关 this.mode = mode; // 标记时创建，继承父节点 mod // Effects 副作用 this.effectTag = NoEffect; this.nextEffect = null; this.firstEffect = null; this.lastEffect = null; this.expirationTime = NoWork; // 任务的过期时间 this.childExpirationTime = NoWork; // 子节点更新的过期时间 this.alternate = null; // Fiber 用来复制复用 Fiber 的。 if (enableProfilerTimer) &#123; this.actualDuration = 0; this.actualStartTime = -1; this.selfBaseDuration = 0; this.treeBaseDuration = 0; &#125;&#125; Fiber 对象对应的结构 update 和 updateQueue 用于记录组件状态的改变记录改变的方式和内容 存放在 updateQueue存放多个 update 用来计算出最终改变的结果 多个 update 可以同时存在setState 三次会创建三个update，放到 updateQueue 里 update 结构在 legacyRenderSubtreeIntoContainer 最终调用 ReactRoot.prototype.render 时执行 scheduleRootUpdate 里执行 createUpdate 123456789101112export function createUpdate(expirationTime: ExpirationTime): Update&lt;*&gt; &#123; return &#123; expirationTime: expirationTime, // 当前更新的过期时间 tag: UpdateState, // 四个状态，更新updateState 0、替换replaceState 1、强制forceUpdate 2、throw 捕获 captureUpdate 3 payload: null, // 实际操作内容，在外面赋值上去 update.payload = &#123; element &#125; 初次渲染传入的是元素，setState 可能传入的就是对象或者方法 callback: null, next: null, // 下一个 update 单向链表 nextEffect: null, &#125;;&#125; updateQueue 结构1234567891011121314export function createUpdateQueue&lt;State&gt;(baseState: State): UpdateQueue&lt;State&gt; &#123; const queue: UpdateQueue&lt;State&gt; = &#123; baseState, // 每次操作更新之后计算出的 state，作为下一次计算的基础 firstUpdate: null, // 记录链表结构 lastUpdate: null, // 记录链表结构 firstCapturedUpdate: null, // 记录链表结构 lastCapturedUpdate: null, // 记录链表结构 firstEffect: null, lastEffect: null, firstCapturedEffect: null, lastCapturedEffect: null, &#125;; return queue;&#125; enqueueUpdated 方法enqueueUpdated 就是在 fiber 对象上创建一个 updateQueue，然后把 update 对象传入到这个 queue 里 123456export function enqueueUpdate&lt;State&gt;(fiber: Fiber, update: Update&lt;State&gt;) &#123; // ... let queue1 queue1 = fiber.updateQueue = createUpdateQueue(fiber.memoizedState); appendUpdateToQueue(queue1, update);&#125; 12345678910111213function appendUpdateToQueue&lt;State&gt;( queue: UpdateQueue&lt;State&gt;, update: Update&lt;State&gt;,) &#123; // Append the update to the end of the list. if (queue.lastUpdate === null) &#123; // Queue is empty queue.firstUpdate = queue.lastUpdate = update; &#125; else &#123; queue.lastUpdate.next = update; queue.lastUpdate = update; &#125;&#125; expirationTime初次渲染最后执行 ReactDOM.render 调用 ReactRoot.prototype.render 中调用 react-reconcile 模块的 updateContainer 会计算一个 expirationTime 然后用这个时间创建 update 对象推入 updateQueue 内 expirationTime 的计算12345678910111213141516171819export function updateContainer( element: ReactNodeList, // App container: OpaqueRoot, // 一个 fiber root parentComponent: ?React$Component&lt;any, any&gt;, // null callback: ?Function,): ExpirationTime &#123; const current = container.current; // Fiber const currentTime = requestCurrentTime(); // 创建一个时间差 // 计算出一个时间，ConcurrentMode 会用到, 计算出的是优先级时间 const expirationTime = computeExpirationForFiber(currentTime, current); // 主要执行 return updateContainerAtExpirationTime( element, container, parentComponent, expirationTime, callback, );&#125; requestCurrentTime 方法返回一个固定的常量，调用 recomputeCurrentRendererTime 返回当前渲染时间直到 js 加载初的时间差值，差值小的值会在 msToExpirationTime 被计算成同一个常数12345678910111213141516171819202122function requestCurrentTime() &#123; // ... if ( // 没有调度时间，初次渲染 nextFlushedExpirationTime === NoWork || nextFlushedExpirationTime === Never ) &#123; // If there&#x27;s no pending work, or if the pending work is offscreen, we can // read the current time without risk of tearing. recomputeCurrentRendererTime(); currentSchedulerTime = currentRendererTime; return currentSchedulerTime; &#125; // ...&#125;function recomputeCurrentRendererTime() &#123; const currentTimeMs = now() - originalStartTimeMs; // js 加载到现在渲染的固定值 currentRendererTime = msToExpirationTime(currentTimeMs);&#125;export function msToExpirationTime(ms: number): ExpirationTime &#123; // Always add an offset so that we don&#x27;t clash with the magic number for NoWork. return ((ms / UNIT_SIZE) | 0) + MAGIC_NUMBER_OFFSET;&#125; computeExpirationForFiber 方法会根据当前渲染的 currentTime 计算出一个优先级时间。12345678910111213141516function computeExpirationForFiber(currentTime: ExpirationTime, fiber: Fiber) &#123; let expirationTime; // ... if (fiber.mode &amp; ConcurrentMode) &#123; // 异步 mode 才计算 expirationTime if (isBatchingInteractiveUpdates) &#123; // This is an interactive update expirationTime = computeInteractiveExpiration(currentTime); &#125; else &#123; // This is an async update expirationTime = computeAsyncExpiration(currentTime); &#125; &#125; // ... return expirationTime;&#125; computeExpirationForFiber 的核心就是根据渲染方式的 mod 不同来创建不同优先级的 expirationTime，区别就在于传入 computeExpirationBucket 的参数不同 最终的公式 ((((currentTime - 2 + 5000 / 10) / 25) | 0) + 1) * 25, 公式用了 | 0取整，使得在 * 25 倍数之间很短的一段时间粒度里计算出的值是一样的 在很短时间内 setState 多次调用更新时，也可以保证是同一优先级的更新。12345678910111213141516export function computeAsyncExpiration( currentTime: ExpirationTime,): ExpirationTime &#123; return computeExpirationBucket( currentTime, LOW_PRIORITY_EXPIRATION, LOW_PRIORITY_BATCH_SIZE, );&#125;export function computeInteractiveExpiration(currentTime: ExpirationTime) &#123; return computeExpirationBucket( currentTime, HIGH_PRIORITY_EXPIRATION, HIGH_PRIORITY_BATCH_SIZE, );&#125; 不同的 expirationTimeSync 模式 优先级高Async 模式 会进行调度可能会被中断，会计算出 expirationTime 来分配优先级指定 context \b同步更新的 expirationTime computeExpirationForFiber 在异步 mode 的情况下才根据 currentTime 来计算 expirationTime expirationTime 等于 Sync 1， NoWork 0，还有就是计算出来的时间值 在 expirationContext 不为 NoWork 时，expirationContext 会根据更新 api 方式的不同设置为 Sync 或者 计算出 Async 方式的优先级时间123456789101112131415161718192021222324252627function computeExpirationForFiber(currentTime: ExpirationTime, fiber: Fiber) &#123; let expirationTime; if (expirationContext !== NoWork) &#123; // An explicit expiration context was set; expirationTime = expirationContext; &#125; else if (isWorking) &#123; if (isCommitting) &#123; // Updates that occur during the commit phase should have sync priority // by default. expirationTime = Sync; &#125; else &#123; // Updates during the render phase should expire at the same time as // the work that is being rendered. expirationTime = nextRenderExpirationTime; &#125; &#125; else &#123; // No explicit expiration context was set, and we&#x27;re not currently // performing work. Calculate a new expiration time. if (fiber.mode &amp; ConcurrentMode) &#123; // 异步逻辑 &#125; else &#123; // This is a sync update expirationTime = Sync; &#125; &#125; return expirationTime;&#125; setState 和 forceUpdate 给节点的 Fiber 创建更新 更新的类型不同 来源都是 Component 组件上的原型方法, 他们调用的 enqueueSetState 等方法都是由不同平台创建的 updater 对象上的，浏览器中的 updater 对象来自 ReactFiberClassComponent.js 里的 classComponentUpdater 对象上 1234567891011121314function Component(props, context, updater) &#123; this.props = props; this.context = context; this.refs = emptyObject; // 作为参数让不同的平台来控制属性更新的方式 this.updater = updater || ReactNoopUpdateQueue;&#125;Component.prototype.setState = function(partialState, callback) &#123; // 仅仅调用了 updater 上的方法 updater 是初始化的第三个参数的实例属性，跟平台相关 this.updater.enqueueSetState(this, partialState, callback, &#x27;setState&#x27;);&#125;;Component.prototype.forceUpdate = function(callback) &#123; this.updater.enqueueForceUpdate(this, callback, &#x27;forceUpdate&#x27;);&#125;; classComponentUpdater enqueueSetState, enqueueForceUpdate 几乎是相同的，在这里我们只看 enqueueSetState1 从 Map 对象中获取 Fiber 对象2 创建当前时间3 优先级时间4 创建 update5 设置payload6 执行回调7 把 update 对象推入 Fiber 对象的 updateQueue 内8 进行调度 发现 enqueueSetState 所执行的顺序跟 ReactFiberReconclier.js 的 updateContainer 几乎是一模一样的1 Fiber 对象是参数传进来的2 payload 是创建 update 对象后在外面赋值的3 最后也是创建 update 进入 Fiber 对象的 updateQueue 再进行调度1234567891011121314151617181920212223const classComponentUpdater = &#123; isMounted, enqueueSetState(inst, payload, callback) &#123; const fiber = ReactInstanceMap.get(inst); // 从 Map 对象中获取 Fiber 对象 const currentTime = requestCurrentTime(); // 创建当前时间 const expirationTime = computeExpirationForFiber(currentTime, fiber); // 优先级时间 const update = createUpdate(expirationTime); // 创建 update update.payload = payload; // 设置payload if (callback !== undefined &amp;&amp; callback !== null) &#123; update.callback = callback; // 执行回调 &#125; enqueueUpdate(fiber, update); // 把 update 对象推入 Fiber 对象的 updateQueue 内 scheduleWork(fiber, expirationTime); // 进行调度 &#125;, enqueueReplaceState(inst, payload, callback) &#123; // ... &#125;, enqueueForceUpdate(inst, callback) &#123; // ... &#125;&#125;;","categories":[],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"}]},{"title":"TCP 滑动窗口原理","slug":"TCP 滑动窗口原理","date":"2019-01-14T11:21:06.000Z","updated":"2023-09-18T15:16:43.837Z","comments":true,"path":"2019/01/14/TCP 滑动窗口原理/","link":"","permalink":"http://yoursite.com/2019/01/14/TCP%20%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E5%8E%9F%E7%90%86/","excerpt":"","text":"TCP 滑动窗口TCP 使用滑动窗口做流量控制与乱序重排 RTT 和 RTO RTT发送一个数据包到收到对应的 ACK，所花费的时间 RTO定时器，重传时间间隔没有回应 ACK 则等到 RTO 到期进行重传，根据 RTT 计算出来 TCP 使用滑动窗口做流量控制与乱序重排 保证TCP 的可靠性 保证TCP 的流量控制特性window 字段的流量控制：用于接收方通知发送方自己还有多少缓冲区可以接收数据，发送方根据接收方的处理能力来发送数据，不会导致接收方处理不过来。滑动窗口机制体现了tcp面向字节流的设计 窗口数据的计算过程左右为发送方接收方缓冲区 发送方LastByteWritten: 发送方上层应用写出的数据长度LastByteSent: 通过 TCP 最后发送到接收方的数据位置LastByteAcked: 已经收到接收方的连续最大 ACK 的位置(二次握手) 接收方MaxRcvBuffer: 最大缓冲区LastByteRead: 接收方上层应用在 TCP 缓冲区中已经读完的最后一个字节的位置NextByteExpected: 收到的连续最大 Seq 包的位置(排好序可以读的数据)LastByteRcvd: 已收到的最后一个字节的位置NextByteExpected 与 LastByteRcvd 之间会有部分空隙表示这些数据还无法读或者应用无法读到。 接收方窗口 AdvertisedWindow 接收方还能够接收的数据量AdvertisedWindow &#x3D; MaxRcvBuffer – (LastByteRcvd - LastByteRead)接收方把 AdvertisedWindow 告知发送方，发送方 LastByteSent - LastByteAcked 不能大于 AdvertisedWindow 接收方还能接收的量 发送方窗口 EffectiveWindow 发送方窗口内剩余可发送的大小EffectiveWindow &#x3D; AdvertisedWindow - (LastByteSent - LastByteAcked) 保证接收方可以处理数据LastByteSent - LastByteAcked 发送方可以发送的数据减去已经确认好可发送的数据就是发送方将要发送的数据，这个数据不能大于接收方还能够接收的数据量。 接收方还能够接收的数据量 AdvertisedWindow &#x3D; MaxRcvBuffer – (LastByteRcvd - LastByteRead)，接收方把 AdvertisedWindow 告知发送方，发送方 LastByteSent - LastByteAcked 不能大于 AdvertisedWindow 接收方还能接收的量。发送方窗口内剩余可发送的大小 EffectiveWindow &#x3D; AdvertisedWindow - (LastByteSent - LastByteAcked) 保证接收方可以处理数据 滑动窗口基本原理TCP 发送方 发送方来看数据分为四类1.得到服务器确认且已经发送的2.还没得到服务器确认但已经发送的3.未发送但服务器允许发送的4.未发送且因为达到了 window 的大小不允许发送的数据[2-3]就是发送方的滑动窗口 滑动窗口在被连续确认后才进行滑动当 ACK 连续被确认，比如32-36连续确认4为后才开始把分类2的数据发送，同时扩大分类3向右的范围 TCP 接收方 接收方缓存内三种状态1.已接收并且已经发送 ACK 回执的数据2.未接收但可以接收状态 - 接收窗口 滑动方式一致3.未接收且不能接收的状态 - 达到窗口阈值ACK 直接由 TCP 回复，默认没有应用延迟，不存在已接收未回复 ACK 的状态[2]就是接收窗口 总结TCP 最基本的传输可靠性来源于确认重传机制，TCP 的滑动窗口机制也是建立在确认重传基础上的。发送窗口收到接收端对于本段窗口内字节的 ACK 确认才会移动发送窗口的左边界。接收窗口只有在前面所有的段都确认的情况下才会移动左边界，当前面还有字节未接收但收到后面字节的情况下(乱序)窗口是不会移动的，并不对后续字节确认, 确保这段数据重传。可以根据滑动窗口的调整进行流量控制。 \b参考参考1参考2","categories":[{"name":"http","slug":"http","permalink":"http://yoursite.com/categories/http/"}],"tags":[{"name":"http","slug":"http","permalink":"http://yoursite.com/tags/http/"}]},{"title":"网络基础、TCP/IP 三次握手和四次挥手","slug":"网络基础、TCP|IP 三次握手和四次挥手 ","date":"2019-01-13T17:18:32.000Z","updated":"2023-09-18T15:16:13.228Z","comments":true,"path":"2019/01/14/网络基础、TCP|IP 三次握手和四次挥手 /","link":"","permalink":"http://yoursite.com/2019/01/14/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E3%80%81TCP|IP%20%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%20/","excerpt":"","text":"网络知识点 OSI 开放式互联参考模型七层协议1物理层 解决：机器1向机器2发送比特流，机器2接收比特流。 定义：物理设备的标准，网线类型，设备接口类型，各种传输介质的传输速率 作用：传输比特流010101数据，将比特流转化为电流强弱信号，到达后再转化为0101机器码-&gt; 数模转换和模数转换。网卡定义在这一层 2数据链路层 解决：传输比特流的过程中解决数据传输不完整的可能 定义：如何格式化数据以进行传输以及对物理介质的访问 作用：错误检测和纠正，确保数据传输的可靠性，将比特数据组成了帧，交换机工作在这层，对帧解码，根据帧中的数据发送到网络接收方 3网络层 解决：找到目标节点选择最佳路径，帧数据点对点通信经过多个节点 定义：将网络地址翻译成物理地址并决定将发送方路由到接收方，通过综合考虑选择优先权和最佳路径，TCP&#x2F;IP 路由器属于网络层，数据为数据包 作用：将数据包切割为一个一个段落进行发送。 4传输层 解决：数据丢失要不要重传，每个段落要按顺序达到么，解决了主机间的数据传输，传输质量的问题 定义：传输协议，流量控制，速率，传输顺序, TCP、UDP 5 会话层 解决：建立和管理应用程序间的通信，解决不同系统之间通信语法的问题，再表示成网络能理解的方案格式化，方案也因为网络的类型不同而不同， 定义： RPC 远程过程调用协议在此层 7 应用层发送方发送的数据接收方是不知道他的字节数组和内容格式的 解决：规定发送方接收方使用固定的消息头，规定头的组成，消息体的长度，用来正确解析发送的数据，应用从网络中接收到的数据。 定义：TCP&#x2F;IP 协议对应的 HTTP HTTPS 协议 模型参考发送方解释数据，分段，分组成帧解释成比特流，通过电缆发送到目标方在向上解析传递。 TCP&#x2F;IP 模型OSI概念七层实现：TCP&#x2F;IP 四层模型TCP&#x2F;IP 模型关注应用程序实现，OSI模型在协议开发之前设计的，具有通用性 TCP&#x2F;IP 解释 TCP 和 IP 协议单独的 TCP IP 协议 TCP&#x2F;IP通信时用到的协议群-网ji协议群TCP,UDP 都属于 TCP&#x2F;IP 协议 OSI模型注重通信协议必要的功能是什么 TCP&#x2F;IP模型更强调在计算机上实现协议应该开发哪种程序 一层层包裹在一层层解套出来 TCP 三次握手传输控制协议TCP 面向连接、可靠、基于字节流的传输层通信协议 将应用层的数据流分割成报文段并发送给目标节点的TCP层 数据包有都有序号，对方接收到则发送ACK 确认，未收到则重传 使用校验和检验数据在传输过程中是否有误 TCP 报文头 传输中使用协议端口号，ip地址+协议+端口号产生唯一标识网络进程， 也成为套接字 socket。source port 原端口，destination port 目的端口 Sequence Number 序号字段占4字节对每个字节标识，比如一段报文序号107携带100个字段，下一个报文段就是 107 + 100 &#x3D; 207 开始 Acknowledgment Number 期望收到对方下个字节的序号例如B收到A 301序号200字节大小的报文段，B接收500字节，B发送给A501 ACK Number，告诉A期望下次接收501序号的报文段 TCP Flage URG: 紧急指针标志 0忽略 ACK：确认序号标志1 PSH：push 标志 1就有push 将数据尽快交给应用程序而不是缓存区排队 RST：重置连接标志 SYN：同步序列号1，用户建立连接过程 FIN:finish标志，用于释放连接 三次握手握手是为了建立连接，TCP 三次握手的流程 第一次握手 B服务器创建传输控制块TCP 时刻准备接收客户端进程发送的请求，进入 listen 状态 A客户端创建传输控制块TCP向服务器发送连接请求报文 - sent 报文段，SYN同步序号1，seq报文段序号正整数值 A客户端进入 SYN-SENT 同步已发送状态，发送的称为 sent 报文段, 不能携带数据，但是要消耗掉一个 seq 序号，这便是第一次握手 第二次握手 B服务器接收到请求后如果同意则发送确认接收报文 接收报文包含 SYN1 ACK1 两个字段，而为自己的缓存初始化一个序列号 seq 确认报文序号为 y，ack期待报文序号为 x + 1，因为第一次握手 seq为x 进入 SYN-RCVD 同步收到状态，这时候报文要不能携带数据需要消耗一个 序号 第三次握手 TCP 客户端进程A 收到确认报文后还要给服务进程一个报文 确认报文 ACK&#x3D;1，seq&#x3D;x+1, ack&#x3D;y+1 此时TCP 连接建立，客户端进入ESTAB-LISHED 已建立连接的状态，此时ACK报文段可以携带数据(不携带则不消耗序号),之前不可携带数据 服务端进入 SETAB-LISHED 状态 双方就可以通信了。 Wireshark 抓包理解 TCP 三次握手 win 参数为滑动窗口，进行流量控制 总结三次握手在 TCP&#x2F;IP 协议中, TCP 采用三次握手建立可靠的连接。 第一次握手建立连接时客户端发送 SYN 包 syn&#x3D;1 到服务器并进入 SYN_SEND 状态 等待服务器确认 第二次握手服务器收到 SYN 包，必须给客户端发送确认包 ACK ack&#x3D;1，同时发送一个 SYN syn&#x3D;k，也就是 SYN+ACK 包，此时服务器进入 SYN_RECV 状态 第三次握手客户端收到服务器的 SYN+ACK 包后向服务器发送确认包 ACK ack&#x3D;k+1，此包发送完毕后客户端和服务端后进入 ESTABLISHED 状态，三次握手完毕 为什么要三次握手建立连接 初始化 sequence number 的初始值通信双方要通知双方 seq num，用来以后通信的序号，保证应用层接收到的数据不会因为网络传输问题导致乱序，TCP用序号拼接数据，而且还要发送确认报文 ack SYN 超时隐患首次握手出现 原因 server 收到 client 的SYN 回复 SYN-ACK的时候未收到 ACK 确认 server 不断重试直至超时，linux 默认63秒等待才断开 目前，Linux下默认会进行5次重发SYN-ACK包，重试的间隔时间从1s开始，下次的重试间隔时间是前一次的双倍，5次的重试时间间隔为1s, 2s, 4s, 8s, 16s, 总共31s, 称为指数退避，第5次发出后还要等32s才知道第5次也超时了，所以，总共需要 1s + 2s + 4s+ 8s+ 16s + 32s &#x3D; 63s, TCP才会把断开这个连接。由于，SYN超时需要63秒，那么就给攻击者一个攻击服务器的机会，攻击者在短时间内发送大量的SYN包给Server(俗称SYN flood攻击)，用于耗尽Server的SYN队列。 恶意攻击 SYN Flood发送SYN 而不回应，每次都等待63秒，让正常连接不能处理 最基本的DoS攻击就是利用合理的服务请求来占用过多的服务资源，从而使合法用户无法得到服务的响应。syn flood属于Dos攻击的一种。如果恶意的向某个服务器端口发送大量的SYN包，则可以使服务器打开大量的半开连接，分配TCB（Transmission Control Block）, 从而消耗大量的服务器资源，同时也使得正常的连接请求无法被相应。当开放了一个TCP端口后，该端口就处于Listening状态，不停地监视发到该端口的Syn报文，一 旦接收到Client发来的Syn报文，就需要为该请求分配一个TCB，通常一个TCB至少需要280个字节，在某些操作系统中TCB甚至需要1300个字节，并返回一个SYN ACK命令，立即转为SYN-RECEIVED即半开连接状态。系统会为此耗尽资源。 防护措施 Syn Cache服务端在收到SYN报文时，在一个专用HASH表中保存这种半连接信息，直到收到正确的回应ACK报文再分配TCB。这个开销远小于TCB的开销。还需要保存序列号。 Syn Cookie1.使用对方的IP、端口、己方IP、端口的固定信息，生成 Sequence Number2.SYN 队列满后，通过 tcp_syncookies 参数回发 SYN cookie3.若为正常连接则 client 会回发 SYN cookie，直接建立连接分配 TCB 。4.攻击者不会回复所以，正常的回复了SYN cookie 就可以在队列外直接建立 建立后 client 出现故障 保活机制向对方发送保活探测报文，如果未收到响应则继续发送尝试次数达到保活探测数仍未收到响应则中断 连接队列 在外部请求到达时，被服务程序最终感知到前，连接可能处于SYN_RCVD状态或是ESTABLISHED状态，但还未被应用程序接受。对应地，服务器端也会维护两种队列，处于SYN_RCVD状态的半连接队列，而处于ESTABLISHED状态但仍未被应用程序accept的为全连接队列。如果这两个队列满了之后，就会出现各种丢包的情形。 sync queue (半连接队列) sync queue 的作用三次握手中，第一次握手服务端收到客户端的 SYN 包后，把相关信息放到半连接队列中，同时进行第二次握手回复客户端 SYN + ACK 当 sync queue 满时该队列保存服务器已收到客户端的 SYN 包，并向客户发出确认，正在等待客户的确认包。这些所标识的连接在服务器处于 SYN_RECV 状态，当服务器收到客户的确认包时，删除该 SYN 包的信息，服务器进入 ESTABLISHED 状态。 accept queue (全连接队列) accept queue 作用第三次握手时服务器收到客户端的 ack，如果这时全连接队列没满，那么从半连接队列拿出相关信息放入到全连接队列中，否则按 tcp_abort_on_overflow 指示的执行。 当 accept queue 满时如果全连接队列满了并且 tcp_abort_on_overflow 是 0 直接丢弃该ACK，服务器会进行过一段时间再次进行第二次握手发送 SYN + ACK 给客户端，如果客户端超时等待比较短，就很容易异常。tcp_abort_on_overflow 1 表示发送 RST(重置连接) 通知客户端 参考1参考2 TCP 四次挥手为了终止连接， 要发送四个包 1挥手 server client 都处于 ESTAB-LISHED 状态 client 主动关闭 客户端发送连接释放报文并且停止发送数据 释放报文 FIN&#x3D;1，seq&#x3D;u u是最后一个字节的序号+1， 不携带数据也要消耗序号 客户端进入 FIN-WAIT-1 2挥手 server 接收到释放报文 发出确认报文 确认报文 ACK&#x3D;1,seq&#x3D;v,ack&#x3D;u+1 进入CLOSE-WAIT状态（重要）半关闭状态，客户端不发送数据，但server 发送的数据 client 还是可以接收 3挥手 client 接收到 server 的确认报文进入 FIN-WAIT-2 状态, 等待 server 发送释放连接报文（等待第三次挥手） 此时 client 还要接收 server 发送的最后数据 server 发送完最后数据后，发送连接释放报文，FIN&#x3D;1,ACK&#x3D;1,seq&#x3D;w,ack&#x3D;u+1 server 进入 LAST-ACK 最后确认状态 4挥手 client 收到释放报文后必须发送确认报文，ACK&#x3D;1,seq&#x3D;u+1,ack&#x3D;w+1 client 进入 TIME-WAIT 状态，这时候 client TCP 连接还没释放，必须等待 2MSL(最长报文段寿命liux30s) 才释放 server 收到 client 的确认报文后立即关闭，server 比client 稍早点关闭 四次挥手总结 第一次挥手客户端发送一个 FIN 序号 seq&#x3D;u，用来关闭 客户端到服务器的数据传送，客户端进入 FIN_WAIT_1 状态 第二次挥手服务器收到 FIN 后，发送一个 ACK 给客户端，确认序号为收到的序号 ack&#x3D;u+1 FIN 也占一个序号 seq&#x3D;v，服务器进入 CLOSE_WAITE状态, 这时服务器要把剩下的数据发送完毕 第三次挥手服务器剩余数据发送完毕，发送一个 FIN seq&#x3D;w ack&#x3D;u+1，用来关闭服务器到客户端的数据传送，服务器进入 LAST_ACK 状态 第四次挥手客户端收到 FIN 后，客户端进入 TIME_WAIT 状态，接着发送一个 ACK 给服务器，确认序号为收到序号 ack&#x3D;w+1和 seq&#x3D;u+1，服务器进入 CLOSED 状态，客户端等待 2MSL 时间进入 CLOSED 结束。 client TIME_WAIT 状态等待 2MSL 时间 保证让被动关闭方有足够的时间收到ACK包(确认报文) 如果被动关闭方没有收到则重新发送 FIN 包，一来一回刚好 2MSL 避免新旧连接混淆， 有的路由器缓存的连接跟新连接混淆 为什么要四次挥手才断开连接双工是允许双向发送，发送方和接收方都需要 FIN 报文和 ACK 报文各自需要2次挥手，但是一方是被动的，才看上去是4次挥手 服务端出现大量 CLOSE_WAIT客户端一直请求，但是返回时异常的当对方发送 FIN 报文后，应用没有返回 ACK对方关闭 socket 连接，我方忙于读写，没有及时关闭检查代码，释放资源代码检查配置，处理请求的线程配置","categories":[{"name":"http","slug":"http","permalink":"http://yoursite.com/categories/http/"}],"tags":[{"name":"http","slug":"http","permalink":"http://yoursite.com/tags/http/"}]},{"title":"周常3 算法题5道、react ssr 补充","slug":"周常3 算法题5道、react ssr 补充 ","date":"2019-01-02T13:17:00.000Z","updated":"2023-09-16T12:12:52.177Z","comments":true,"path":"2019/01/02/周常3 算法题5道、react ssr 补充 /","link":"","permalink":"http://yoursite.com/2019/01/02/%E5%91%A8%E5%B8%B83%20%E7%AE%97%E6%B3%95%E9%A2%985%E9%81%93%E3%80%81react%20ssr%20%E8%A1%A5%E5%85%85%20/","excerpt":"","text":"周常 算法题 java 实现1.调整数组顺序使奇数位于偶数前面2.链表中倒数第k个结点3.翻转链表4.合并两个排序的链表5.树的子结构 react ssr 补充 算法题调整数组顺序使奇数位于偶数前面输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变 解题思路1.前后两个指针从头尾出发2.判断两个指针序号的奇偶数3.左右指针不接触时进行运算4.左指针序号自增直到找到偶数，右指针序号自减直到找到奇数。5.左指针序号小于右指针序号则两者未接触，交换位置。 代码实现12345678910111213141516171819202122232425262728public class ReorderArray &#123; public void reorderArray(int[] arr) &#123; int left = 0; int right = arr.length - 1; while (left &lt; right) &#123; while (left &lt; right &amp;&amp; (arr[left] % 2 != 0)) left++; while (left &lt; right &amp;&amp; (arr[right] % 2 == 0)) right--; if (left &lt; right) swap(left, right, arr); &#125; &#125; private void swap(int n, int m, int[] arr) &#123; int temp = arr[n]; arr[n] = arr[m]; arr[m] = temp; &#125; public static void main(String[] args) &#123; int[] arr = &#123;1, 3, 54, 1, 4, 65, 546, 2, 3, 5, 6&#125;; new ReorderArray().reorderArray(arr); for (int anArr : arr) System.out.print(anArr + &quot; &quot;); &#125;&#125; 链表中倒数第k个结点链表中倒数第k个节点 解题思路用两个链表使用双指针解法1.第一个指针先走 k 步2.第二个指针和第一个指针同时走，当第一个指针走到最后一位时一起停止3.这时候第二个指针还有 k 步没走，第二个指针当前的位置就是倒数的 k 的位置 代码实现12345678910111213141516171819202122232425262728293031public class FindKthToTail &#123; private class ListNode &#123; int val; ListNode next; ListNode(int x) &#123; val = x; &#125; &#125; public ListNode findKthToTail(ListNode head, int k) &#123; if (head == null || k &lt;= 0) return null; ListNode nodeP = head; ListNode nodeQ = head; // k - 1 是因为 遍历到 k - 2 下个节点 next 并不为 null 赋值后刚好是 k - 1位置 for (int i = 0; i &lt; k - 1; i++) &#123; if (nodeP.next != null) nodeP = nodeP.next; else return null; &#125; while (nodeP.next != null) &#123; nodeP = nodeP.next; nodeQ = nodeQ.next; &#125; return nodeQ; &#125;&#125; 翻转链表输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL 解题思路1.创建一个 null 链表 pre2.每次把原链表 cur 的第一位放在\bpre 的第一位3.直到原链表 cur 为 null 时 12345678910111213141516// 第一次cur: 2-&gt;3-&gt;4-&gt;5-&gt;NULLpre: 1-&gt;NULL// 第二次cur: 3-&gt;4-&gt;5-&gt;NULLpre: 2-&gt;1-&gt;NULL// 第三次cur: 4-&gt;5-&gt;NULLpre: 3-&gt;2-&gt;1-&gt;NULL// 第四次cur: 5-&gt;NULLpre: 4-&gt;3-&gt;2-&gt;1-&gt;NULL// 第五次cur: NULLpre: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL// 返回 pre 代码实现12345678910111213141516171819202122public class ReverseList &#123; public class ListNode &#123; int val; ListNode next; ListNode(int x) &#123; val = x; &#125; &#125; public ListNode reverseList(ListNode head) &#123; ListNode pre = null; ListNode cur = head; while (cur != null) &#123; ListNode temp = cur.next; // 保留除 cur 第1位的链表 2 -&gt; 3 -&gt; 4 ，cur 还没变 cur.next = pre; // cur.next 指向 pre 截断 cur 当前第1位 1 -&gt; null, 此处截断原链表生成新链表 pre = cur; // pre 变成 1 -&gt; null cur = temp; // 去除 cur 第1位, cur 变成 2 -&gt; 3 -&gt; 4 &#125; return pre; &#125;&#125; 合并两个排序的链表解题思路 解法1 使用循环1.创建虚拟头 dummy2.dummy 引用赋值给 cur3.当 l1 l2 都不为 null 时循环4.比较 l1.val 和 l2.val 谁小谁接入到 cur.next 上，ln &#x3D; ln.next 继续比较下一个 cur &#x3D; cur.next 同时向下准备介接入 当l1 或 l2 其中一个为空时 cur.next 为剩下不为空的链表7.最后返回 dummy 引用的 dummy.next 解法2 使用递归1.基础问题：当其中一个链表为空时，剩下的节点肯定来自另一个链表2.基本问题：比较 l1.val 和 l2.val，谁小谁的 next 就递归比较其 next 节点与另一个链表的合并. 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041public class MergeTwoSortedLists &#123; public class ListNode &#123; int val; ListNode next; ListNode(int x) &#123; val = x; &#125; &#125; public ListNode mergeTwoLists1(ListNode l1, ListNode l2) &#123; ListNode dummy = new ListNode(-1); ListNode cur = dummy; while (l1 != null &amp;&amp; l2 != null) &#123; if (l1.val &lt; l2.val) &#123; cur.next = l1; l1 = l1.next; &#125; else &#123; cur.next = l2; l2 = l2.next; &#125; cur = cur.next; &#125; cur.next = (l1 != null) ? l1 : l2; return dummy.next; &#125; public ListNode mergeTwoLists2(ListNode l1, ListNode l2) &#123; // 当其中一个链表为空时，剩下的节点肯定来自另一个链表 if (l1 == null) return l2; if (l2 == null) return l1; // 开始递归 if (l1.val &lt; l2.val) &#123; // l1 后面应该接节点 l1.next = mergeTwoLists2(l1.next, l2); // 传入 l1.next l2, 决定 l1.next l2 如果合并 return l1; &#125; else &#123; // l1.val &gt;= l2.val l2.next = mergeTwoLists2(l1, l2.next); return l2; &#125; &#125;&#125; 树的子结构给定两个非空二叉树 s 和 t，检验 s 中是否包含和 t 具有相同结构和节点值的子树。s 的一个子树包括 s 的一个节点和这个节点的所有子孙。s 也可以看做它自身的一棵子树。 解题思路1.创建 equals 函数，比较两个 TreeNode， 比较两个 TreeNode 的 val，如果相等递归比较 left 和 right 节点2.创建 traverse 函数，这个函数用来在 s 的每个节点中比较 t ，同时进行比较当前节点， 递归的在 s 的 left 和 right 里比较 t 代码实现1234567891011121314151617181920212223242526272829303132333435public class SubtreeOfAnotherTree &#123; public class TreeNode &#123; int val; TreeNode left; TreeNode right; TreeNode(int x) &#123; val = x; &#125; &#125; public boolean isSubtree(TreeNode s, TreeNode t) &#123; return traverse(s, t); // 此函数用来递归遍历树 &#125; // 这个函数用来在 s 的每个节点中比较 t ，同时进行比较当前节点 private boolean traverse(TreeNode s, TreeNode t) &#123; return s != null // 主树不为空 &amp;&amp; ( equals(s, t) // 两个树一样 || traverse(s.left, t) // 从左子节点开始比较 || traverse(s.right, t) // 从右子节点开始比较 ); &#125; private boolean equals(TreeNode x, TreeNode y) &#123; if (x == null &amp;&amp; y == null) // base 基础条件，比较到最后都没子节点了 true return true; if (x == null || y == null) // base 基础条件，还有子节点 false return false; // 递归实际比较 return x.val == y.val &amp;&amp; equals(x.left, y.left) &amp;&amp; equals(x.right, y.right); &#125;&#125; react ssr 补充node server 中间层之前的代码在渲染时 node server 请求了一次 api 返回了数据插入到页面上，client 的代码在 componentDidMount 里也是请求了 api ，这次改造成 client 请求 node server，node server 再去请求 api，让 node server 只做代理而不是客户端还去请求外部服务。 使用 express-http-proxy设置代理 client 请求本地服务 &#x2F;api&#x2F;news.json?secret&#x3D;abcd 时代理到 http://47.95.113.63/ssr/api/news.json?secret=abcd 下 1234567import proxy from &#x27;express-http-proxy&#x27;;app.use(&#x27;/api&#x27;, proxy(&#x27;http://47.95.113.63&#x27;, &#123; proxyReqPathResolver: function (req) &#123; return &#x27;/ssr/api&#x27; + req.url; &#125;&#125;)); 区分 server client axios 请求的 baseURL server client axios 配置 12345678// clientimport axios from &#x27;axios&#x27;;const instance = axios.create(&#123; baseURL: &#x27;/&#x27;&#125;);export default instance; 1234567891011// serverimport axios from &#x27;axios&#x27;;const createInstance = (req) =&gt; axios.create(&#123; baseURL: &#x27;http://47.95.113.63/ssr&#x27;, headers: &#123; cookie: req.get(&#x27;cookie&#x27;) || &#x27;&#x27; &#125;&#125;);export default createInstance; 使用 thunk.withExtraArgument 12345678910export const getStore = (req) =&gt; &#123; // 改变服务器端store的内容，那么就一定要使用serverAxios return createStore(reducer, applyMiddleware(thunk.withExtraArgument(serverAxios(req))));&#125;export const getClientStore = () =&gt; &#123; const defaultState = window.context.state; // 改变客户端store的内容，一定要使用clientAxios return createStore(reducer, defaultState, applyMiddleware(thunk.withExtraArgument(clientAxios)));&#125; action 上就会增加额外的参数 12345678910// actionexport const getHomeList = () =&gt; &#123; return (dispatch, getState, axiosInstance) =&gt; &#123; return axiosInstance.get(&#x27;/api/news.json?secret=abcd&#x27;) .then((res) =&gt; &#123; const list = res.data.data; dispatch(changeList(list)) &#125;); &#125;&#125; 或者使用 webpack.DefinePlugin 插件，给server 端代码增加环境变量 12// 通过插件传递的环境变量只在 server 打包的代码里使用const baseUrl = process.env.API_BASE || &#x27;&#x27; 123456// webpack.server.js plugins: [ new webpack.DefinePlugin(&#123; &#x27;process.env.API_BASE&#x27;: &#x27;&quot;http://127.0.0.1:3333&quot;&#x27; &#125;) ] 多层路由展示123456789101112131415161718192021// Routes.jsexport default [&#123; path: &#x27;/&#x27;, component: App, loadData: App.loadData, routes: [ &#123; path: &#x27;/&#x27;, component: Home, exact: true, loadData: Home.loadData, key: &#x27;home&#x27; &#125;, &#123; path: &#x27;/translation&#x27;, component: Translation, loadData: Translation.loadData, exact: true, key: &#x27;translation&#x27; &#125; ]&#125;]; 1234567891011121314151617181920212223242526272829import &#123; renderRoutes &#125; from &#x27;react-router-config&#x27;;// clientconst App = () =&gt; &#123; return ( &lt;Provider store=&#123;store&#125;&gt; &lt;BrowserRouter&gt; &lt;div&gt; &#123;renderRoutes(routes)&#125; &lt;/div&gt; &lt;/BrowserRouter&gt; &lt;/Provider&gt; )&#125;// serverexport const render = (store, routes, req) =&gt; &#123; const content = renderToString(( &lt;Provider store=&#123;store&#125;&gt; &lt;StaticRouter location=&#123;req.path&#125; context=&#123;&#123;&#125;&#125;&gt; &lt;div&gt; &#123;renderRoutes(routes)&#125; &lt;/div&gt; &lt;/StaticRouter&gt; &lt;/Provider&gt; )); // return ...&#125; 一级路由组件要渲染二级路由 routes 子路由数组 123456789101112131415routes: [ &#123; path: &#x27;/&#x27;, component: Home, exact: true, loadData: Home.loadData, key: &#x27;home&#x27; &#125;, &#123; path: &#x27;/translation&#x27;, component: Translation, loadData: Translation.loadData, exact: true, key: &#x27;translation&#x27; &#125; ] 一级路由组件渲染后 route 属性可以在 props 里获取到，在一级路由组件里使用 renderRoutes 渲染一级路由的 props.route.routes 1234567891011121314// 一级路由的组件// client server 端共用const App = (props) =&gt; &#123; return ( &lt;div&gt; &lt;Header /&gt; &#123;renderRoutes(props.route.routes)&#125; &lt;/div&gt; )&#125;App.loadData = (store) =&gt; &#123; return store.dispatch(actions.getHeaderInfo());&#125; 解决 cookie 携带问题当浏览器请求本地 node 服务时(携带 cookie)node server 进行服务端渲染转发浏览器的请求node server 请求 api server 获取数据(cookie 需要手动携带)express-http-proxy 中间件 只转发了请求路径，请求内容最终还是 axios 请求的。 12345app.use(&#x27;/api&#x27;, proxy(&#x27;http://47.95.113.63&#x27;, &#123; proxyReqPathResolver: function (req) &#123; return &#x27;/ssr/api&#x27; + req.url; &#125;&#125;)); 通过把 express req 对象传递给 getStore 最后改造 createInstance 为高阶函数，这样cookie 就可以给 axios 获取cookie了 1234567891011121314151617181920app.get(&#x27;*&#x27;, function (req, res) &#123; const store = getStore(req); // ..&#125;export const getStore = (req) =&gt; &#123; // 改变服务器端store的内容，那么就一定要使用serverAxios return createStore(reducer, applyMiddleware(thunk.withExtraArgument(serverAxios(req))));&#125;// axios 实例import axios from &#x27;axios&#x27;;const createInstance = (req) =&gt; axios.create(&#123; baseURL: &#x27;http://47.95.113.63/ssr&#x27;, headers: &#123; cookie: req.get(&#x27;cookie&#x27;) || &#x27;&#x27; &#125;&#125;);export default createInstance; 生成404页面路由配置 1234567891011121314151617181920212223export default [&#123; path: &#x27;/&#x27;, component: App, loadData: App.loadData, routes: [ &#123; path: &#x27;/&#x27;, component: Home, exact: true, loadData: Home.loadData, key: &#x27;home&#x27; &#125;, &#123; path: &#x27;/translation&#x27;, component: Translation, loadData: Translation.loadData, exact: true, key: &#x27;translation&#x27; &#125;, &#123; component: NotFound &#125; ]&#125;]; 解决请求返回的页面 status 404 返回在 server 使用 StaticRouter 传递 context, context 可以从 props.staticContext 中获取 修改 server ssr 路由配置，给 render 函数传递 context 1234567app.get(&#x27;*&#x27;, function (req, res) &#123; Promise.all(promises).then(() =&gt; &#123; const context = &#123;&#125;; const html = render(store, routes, req, context); res.send(html) &#125;)&#125; 给 render 函数增加 context 参数传递到 StaticRouter 组件中，等到 props.staticContext 使用 1234567891011121314export const render = (store, routes, req, context) =&gt; &#123; const content = renderToString(( &lt;Provider store=&#123;store&#125;&gt; &lt;StaticRouter location=&#123;req.path&#125; context=&#123;context&#125;&gt; &lt;div&gt; &#123;renderRoutes(routes)&#125; &lt;/div&gt; &lt;/StaticRouter&gt; &lt;/Provider&gt; )); return `...`&#125; 修改 NotFound 页面, 当没有匹配路由访问到 NotFound 页面时，staticContext 增加 NOT_FOUND因为 server client 都会执行，client 不存在 staticContext 记得判断一下防止报错 12345678910111213141516import React, &#123; Component &#125; from &#x27;react&#x27;;class NotFound extends Component &#123; componentWillMount() &#123; const &#123; staticContext &#125; = this.props; staticContext &amp;&amp; (staticContext.NOT_FOUND = true); &#125; render() &#123; return &lt;div&gt;404, sorry, page not found&lt;/div&gt; &#125;&#125;export default NotFound; 这样我们可以通过判断 context.NOT_FOUND 来判断设置 status 404再返回页面 123456789101112app.get(&#x27;*&#x27;, function (req, res) &#123; Promise.all(promises).then(() =&gt; &#123; const context = &#123;&#125;; const html = render(store, routes, req, context); if (context.NOT_FOUND) &#123; res.status(404); res.send(html); &#125;else &#123; res.send(html); &#125; &#125;)&#125; 实现 301 重定向没登录的情况下访问需要授权的页面 虽然 client 的逻辑重定向了，但是server 端代码没有重定向。 12345678// client 页面执行的 Redirect render() &#123; return this.props.login ? ( &lt;div&gt; &#123;this.getList()&#125; &lt;/div&gt; ) : &lt;Redirect to=&#x27;/&#x27;/&gt;; &#125; 不过 renderRoutes 方法在发现 Redirect 组件执行时，就是在 server 上发现时会帮我们的 context 上塞一段数据用来判断 123456789101112131415// context: &#123; url: &#x27;&#x27;, action: &#x27;&#x27;, location: &#123; pathname: &#x27;&#x27;, search: &#x27;&#x27;, hash: &#x27;&#x27;, state: undefined &#125; &#125;app.get(&#x27;*&#x27;, function (req, res) &#123; Promise.all(promises).then(() =&gt; &#123; const context = &#123;&#125;; const html = render(store, routes, req, context); if (context.action === &#x27;REPLACE&#x27;) &#123; res.redirect(301, context.url) &#125;else if (context.NOT_FOUND) &#123; res.status(404); res.send(html); &#125;else &#123; res.send(html); &#125; &#125;)&#125; 这样就可以实现301了 错误获取当 node server 代理的请求报错时页面就崩溃了，我们喜欢 node server 代理的请求有错时还是能返回没报错的数据同时把页面渲染出来 1234567891011121314151617181920212223242526app.get(&#x27;*&#x27;, function (req, res) &#123; const store = getStore(req); const matchedRoutes = matchRoutes(routes, req.path); const promises = []; matchedRoutes.forEach(item =&gt; &#123; if (item.route.loadData) &#123; // 封装一个 promise，当 loadData catch 时也能让外层的 promise 返回 resolve 能继续执行，保证返回页面的 promise.all 能继续执行 const promise = new Promise((resolve, reject) =&gt; &#123; item.route.loadData(store).then(resolve).catch(resolve); &#125;) promises.push(promise); &#125; &#125;) Promise.all(promises).then(() =&gt; &#123; const context = &#123;&#125;; const html = render(store, routes, req, context); if (context.action === &#x27;REPLACE&#x27;) &#123; res.redirect(301, context.url) &#125;else if (context.NOT_FOUND) &#123; res.status(404); res.send(html); &#125;else &#123; res.send(html); &#125; &#125;)&#125; 处理 CSSserver 打包 处理 css使用isomorphic-style-loader, 处理样式的 loader 需要 window 对象，server 端是没有 window 的，使用同构样式的 loader, 这里使用 modules 模式需要执行 JS 才有样式，会有白屏问题 1234567891011rules: [&#123; test: /\\.css?$/, use: [&#x27;isomorphic-style-loader&#x27;, &#123; loader: &#x27;css-loader&#x27;, options: &#123; importLoaders: 1, modules: true, localIdentName: &#x27;[name]_[local]_[hash:base64:5]&#x27; &#125; &#125;]&#125; 实现 ssr 样式 创建传递 styles.getCss() 对象到 staticContext.css 里的高阶组件123456789101112131415161718import React, &#123; Component &#125; from &#x27;react&#x27;;export default (DecoratedComponent, styles) =&gt; &#123; return class NewComponent extends Component &#123; componentWillMount() &#123; if (this.props.staticContext) &#123; this.props.staticContext.css.push(styles._getCss()); &#125; &#125; render() &#123; return &lt;DecoratedComponent &#123;...this.props&#125; /&gt; &#125; &#125;&#125; ssr 样式的页面使用高阶组件这里同时把 loadData 挂载到到处的页面对象上。1234567const ExportHome = connect(mapStateToProps, mapDispatchToProps)(withStyle(Home, styles)); // 使用 withStyleExportHome.loadData = (store) =&gt; &#123; return store.dispatch(getHomeList())&#125;export default ExportHome; 最后在 server 里修改返回的模板通过传入的 staticContext 对象里找到 css 对象数组，转换成字符串后，插入到 head 里123456789101112131415161718192021222324252627282930313233export const render = (store, routes, req, context) =&gt; &#123; const content = renderToString(( &lt;Provider store=&#123;store&#125;&gt; &lt;StaticRouter location=&#123;req.path&#125; context=&#123;context&#125;&gt; &lt;div&gt; &#123;renderRoutes(routes)&#125; &lt;/div&gt; &lt;/StaticRouter&gt; &lt;/Provider&gt; )); const cssStr = context.css.length ? context.css.join(&#x27;\\n&#x27;) : &#x27;&#x27;; return ` &lt;html&gt; &lt;head&gt; &lt;title&gt;ssr&lt;/title&gt; &lt;style&gt;$&#123;cssStr&#125;&lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;root&quot;&gt;$&#123;content&#125;&lt;/div&gt; &lt;script&gt; window.context = &#123; state: $&#123;JSON.stringify(store.getState())&#125; &#125; &lt;/script&gt; &lt;script src=&#x27;/index.js&#x27;&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; `; &#125; SEOTitle 和 Description12&lt;title&gt; 标题&lt;meta name=&quot;Description&quot; content=&quot;搜索踹的简介&quot;&gt; React-Helment page 上使用12345678910111213141516171819// pages/home.jsimport &#123; Helmet &#125; from &quot;react-helmet&quot;;class Home extends Component &#123; render() &#123; return ( &lt;Fragment&gt; &lt;Helmet&gt; &lt;title&gt;新闻页面 - 丰富多彩的资讯&lt;/title&gt; &lt;meta name=&quot;description&quot; content=&quot;新闻页面 - 丰富多彩的资讯&quot; /&gt; &lt;/Helmet&gt; &lt;div className=&#123;styles.container&#125;&gt; &#123;list&#125; &lt;/div&gt; &lt;/Fragment&gt; ) &#125; &#125; node server 上使用注意要在 react.renderToString() 后使用 const helmet &#x3D; Helmet.renderStatic(); 来获取每个 page 中 react 组件设置的 Helmet 对象12345678910111213141516171819202122232425262728293031323334353637import &#123; Helmet &#125; from &quot;react-helmet&quot;;export const render = (store, routes, req, context) =&gt; &#123; const content = renderToString(( &lt;Provider store=&#123;store&#125;&gt; &lt;StaticRouter location=&#123;req.path&#125; context=&#123;context&#125;&gt; &lt;div&gt; &#123;renderRoutes(routes)&#125; &lt;/div&gt; &lt;/StaticRouter&gt; &lt;/Provider&gt; )); const helmet = Helmet.renderStatic(); const cssStr = context.css.length ? context.css.join(&#x27;\\n&#x27;) : &#x27;&#x27;; return ` &lt;html&gt; &lt;head&gt; $&#123;helmet.title.toString()&#125; $&#123;helmet.meta.toString()&#125; &lt;style&gt;$&#123;cssStr&#125;&lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;root&quot;&gt;$&#123;content&#125;&lt;/div&gt; &lt;script&gt; window.context = &#123; state: $&#123;JSON.stringify(store.getState())&#125; &#125; &lt;/script&gt; &lt;script src=&#x27;/index.js&#x27;&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; `; &#125; 预渲染解决 SEO访问一个普通 react 项目链接，爬虫蜘蛛也访问项目链接可以通过识别爬虫蜘蛛访问的时候预渲染 dom 返回给爬虫。 prerender 模块 创建 prerender 服务器访问时加上查询参数 ?url&#x3D;${url} 预渲染服务就会先去访问 url 再返回给爬虫 12345const prerender = require(&#x27;prerender&#x27;);const server = prerender(&#123; port: 8000&#125;);server.start(); 使用 nginx 识别用户和爬虫nginx 识别爬虫就访问 prerender，识别是人就访问 react 项目 prerender 官网参考 引用 https://prerender.io/","categories":[],"tags":[]},{"title":"周常2 算法题4道、react ssr 原理实践、koa-router 源码阅读","slug":"周常2 算法题4道、react ssr 原理实践、koa-router 源码阅读","date":"2018-12-23T15:39:00.000Z","updated":"2023-09-16T12:09:51.621Z","comments":true,"path":"2018/12/23/周常2 算法题4道、react ssr 原理实践、koa-router 源码阅读/","link":"","permalink":"http://yoursite.com/2018/12/23/%E5%91%A8%E5%B8%B82%20%E7%AE%97%E6%B3%95%E9%A2%984%E9%81%93%E3%80%81react%20ssr%20%E5%8E%9F%E7%90%86%E5%AE%9E%E8%B7%B5%E3%80%81koa-router%20%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/","excerpt":"","text":"周常 算法题 java 实现1.爬楼梯(斐波那契数列)2.位1的个数3.实现 Pow(x, n) x 的 n 次幂函数4.第N个数字 react ssr 原理 koa-router 源码阅读 算法题爬楼梯(斐波那契数列) 假设你正在爬楼梯。需要 n 阶你才能到达楼顶。每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？注意：给定 n 是一个正整数。 解题思路 0层到1 层台阶，只有一种方法。 0层到2 层台阶，有先跨1 层和跨2 层，两种方法。 0层到3 层台阶，可以理解为下面两种情况相加:(1) 先从0层跨到2层，相当于(3-1) &#x3D; 2 层到3 层台阶, 只有一种方法(2) 先从0层跨到1层，相当于(3-2) &#x3D; 1 层到3 层台阶, 先跨1 层和跨2 层，两种方法 上面这种情况下，可以从 0 层选择跨 1 或 2层对应 n-2或 n-1 宏观考虑 0层到n 层台阶 f(n)，可以理解为 f(n-1) + f(n-2) 相加 考虑到使用递归计算性能较差，采用循环的方法 代码实现12345678910111213141516public class ClimbStairs &#123; public int climbStairs(int n) &#123; if (n == 1) // 一阶 1种 return 1; int[] arr = new int[n + 1]; arr[1] = 1; arr[2] = 2; // n 最小为3 for (int i = 3; i &lt;= n; i++) arr[i] = arr[i - 1] + arr[i - 2]; return arr[n]; &#125;&#125; 爬楼梯 位1的个数解题思路 解法1从 32 位 二进制码的第一位开始 …000001 ,…000010, …000100, 比与 n 比较。 解法21.根据二进制的特性，…110100 减1 为 …110011, 两者使用 &amp; 操作符结果为 …110000。 …110000 这个结果把 ..110100 最后一位 1给删除掉了。 通过每次减 1 再比较的这个方式，一直减到 n 为 …000000 也就是 0 后结束。 代码实现12345678910111213141516171819202122232425public class HammingWeight1 &#123; // 解法1 逐个比较 public int s1(int n) &#123; int sum = 0; int mark = 1; for (int i = 0; i &lt; 32; i++) &#123; if ((n &amp; mark) != 0) sum++; mark &lt;&lt;= 1; &#125; return sum; &#125; // 解法2 二进制数 减1来比较 public int s2(int n) &#123; int sum = 0; while (n != 0) &#123; sum++; n &amp;= (n - 1); &#125; return sum; &#125;&#125; 位1的个数 Pow(x, n)实现 pow(x, n) ，即计算 x 的 n 次幂函数。 解题思路 2 ^ 32 等于 2 ^ 16 再平方，也就是 (2 ^ 2) ^ 16 通过这个定律可知 2 ^ 32 &#x3D;&#x3D; (2 ^ 2) ^ 16 &#x3D;&#x3D; (2 ^ 2 ^ 2) ^ 8 &#x3D;&#x3D; (2 ^ 2 ^ 2 ^ 2) ^ 4 &#x3D;&#x3D; (2 ^ 2 ^ 2 ^ 2 ^ 2) ^ 2 &#x3D;&#x3D; (2 ^ 2 ^ 2 ^ 2 ^ 2 ^ 2) ^ 1 通过这个方法可以根据 N 来不停循环, 每次循环 N &#x2F; 2, 同时 x * x 自己跟自己相乘进行平方计算，N 为 1 时 计算并返回 x 的结果。 如果 N 为奇数，\b循环的最终结果 2 ^ 33 &#x3D;&#x3D; (2 ^ 2 ^ 2 ^ 2 ^ 2 ^ 2) ^ 1 * 2， 需要乘一下最初的 x。 当 N &lt; 0, 时 1 &#x3D; 1&#x2F;x, N &#x3D; -N 不用递归的原因是因为当数很大时耗时很长. 代码实现1234567891011121314151617181920public double pow(double x, int n) &#123; long N = n; // 防止很大的数 if (N == 0) return 1; if (N &lt; 0) &#123; x = 1 / x; N = -N; &#125; double result = 1; // 会有小数的情况 while (N &gt; 0) &#123; if (N % 2 == 1) result = result * x; N = N / 2; // 每次 / 2 x = x * x; // x 都平方一次 &#125; return result;&#125; Pow(x, n) 第N个数字在无限的整数序列 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, …中找到第 n 个数字。n 是正数且在32为整形范围内 ( n &lt; 231)。 输入:3输出:3 输入:11输出:0说明:第11个数字在序列 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, … 里是0，它是10的一部分。 解题思路 假设：1 n 是10002 一位数区间 [1, 9] 有 19&#x3D;9个数字的字符串，二位数区间 [10, 99] 有290&#x3D;180个数字的字符串, 三位数区间 [100, 999] 有 3*900&#x3D;2700个数字的字符串。3 n 1000, 肯定是落在了 三位数区间 [100, 999] 中的某个位置。4 1000 - 9 - 180 &#x3D; 811，题目给的序号是从 1开始计算的，实际应该从序号 0开始，811 需要减去1 ， 所以 810 是数字100 第一位 1 到 n 之间所有的字符数 。5 我们来找到 n 1000 所在的数字 k，数100 到数 k 之间有 810，个字符，同时是在三位数区间内。6 100 到 k 之间有 810 &#x2F; 3 &#x3D; 270 个数字7 270 个数字加上之前跳过的一位数和二位数区间 [1-100] 的个数 100， 可以确定 n 1000 落在370 这个数字上。8 最后我们需要确定 n 1000 是在 370 的哪个位置上。9 之前我们在三位数区间 [100, 999] 上获得了100 的第一位 1 到 n 1000 落在数字 370 上的某个位置之间的所有字符一共有 810 个10 通过取模 % 的特性，对三位数 3 取模结果只会 0 1 2 是三个数中的一个，现在用 810 % 3 &#x3D;&#x3D;&#x3D; 0, 可知 810 的位置是某三位数的第一位，我们已经知道这个数是 370，最后确定第一位的结果是 3 总结：1 确定 n 在几位数的区间中2 找到 n 落在哪个数字上3 找到 n 在这个数字上的某个位置 代码实现123456789101112131415161718192021222324public int findNthDigit(int n) &#123; int len = 1; // 位数计数 1-9:1, 10-99:2, 100-999:3 long count = 9; // 9, 90, 900 int start = 1; while (n &gt; len * count) &#123; // len * count = 9, 180... 1-9有(1*9)字符, 10-99有(2*90)字符 n -= len * count; len += 1; count *= 10; start *= 10; &#125; // len = 1, n 在 1-9=9个字符内，len = 2, n 在 10-99=180个字符内， len = 3，n 在 100-999=2700个字符内 // start 从1，10，100 开始 /** * 1000 - 9 - 180 = 811 * (811 - 1) / 3 = 270 * 100(start) + 270 = 370 */ // n - 1是因为从 1 位置开始计算而不是0 start += (n - 1) / len; // start为100在n 811 内 String s = Integer.toString(start); return Character.getNumericValue(s.charAt((n - 1) % len)); // n - 1 是因为从 1 开始而不是 0&#125; 第N个数字 react ssr 原理react ssr 问题主要解决三个问题 server 端编译 react 组件转成 html 返回给浏览器 客户端代码接管 react 让页面逻辑执行 - 同构 client 代码接管 server 端返回的页面后需要配置路由 redux 状态管理数据在 server 和 client 两端统一 - 数据注水脱水 第一问题，解决 server 端返回 react 编译后的 html 重点词：webpack.server.js 文件 - 编译打包 server 端的 js 代码renderToString - react-dom&#x2F;server 模块下的方法 实现方式:使用 webpack 配置打包 server 端 react 代码的 webpack.server.js 文件，打包编译成 html 字符串返回给前端 代码 123456789101112131415server 端返回的 react 组件把 jsx 编译成字符串插入import Home from &#x27;./containers/Home&#x27;;import &#123; renderToString &#125; from &#x27;react-dom/server&#x27;;const content = renderToString(&lt;Home /&gt;); res.send(` &lt;html&gt; &lt;head&gt; &lt;title&gt;ssr&lt;/title&gt; &lt;/head&gt; &lt;body&gt; $&#123;content&#125; &lt;/body&gt; &lt;/html&gt; `); 12345678910111213141516171819202122232425262728// webpack.sever.jsconst path = require(&#x27;path&#x27;);const nodeExternals = require(&#x27;webpack-node-externals&#x27;);module.exports = &#123; target: &#x27;node&#x27;, // 防止打包 node 原生模块的代码，比如 path mode: &#x27;development&#x27;, entry: &#x27;./src/index.js&#x27;, output: &#123; filename: &#x27;bundle.js&#x27;, path: path.resolve(__dirname, &#x27;build&#x27;) &#125;, externals: [nodeExternals()], // 此选项配置排除的模块，nodeExternals 排除 node_modules 里面的模块 module: &#123; rules: [&#123; test: /\\.js?$/, loader: &#x27;babel-loader&#x27;, exclude: /node_modules/, options: &#123; presets: [&#x27;react&#x27;, &#x27;stage-0&#x27;, [&#x27;env&#x27;, &#123; targets: &#123; browsers: [&#x27;last 2 versions&#x27;] &#125; &#125;]] &#125; &#125;] &#125;&#125; 第二个问题让客户端代码接管 react 让页面逻辑执行 - 同构server 端返回 html 还不够，前端代码还不能在这个 html 里执行 renderToString 只能把 react 组件编译成字符串然后通过 server 返回到浏览器。而组件上绑定的实践是无法编译的。 1234567&lt;div&gt; &lt;div&gt;This is Dell Lee!&lt;/div&gt; &lt;button onClick=&#123;()=&gt;&#123;alert(&#x27;click1&#x27;)&#125;&#125;&gt; click &lt;/button&gt;&lt;/div&gt;// onClick 事件是不会出现在浏览器上的 使用通过，让 react 代码在服务端上执行同时又在客户端上执行。 如何让客户端再执行一遍 服务端返回的页面加载一个 js 文件让浏览器加载后自己执行 1234567891011res.send(`&lt;html&gt; &lt;head&gt; &lt;title&gt;ssr&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;root&quot;&gt;$&#123;content&#125;&lt;/div&gt; &lt;script src=&#x27;/index.js&#x27;&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt;`); index.js文件如何来app.use(express.static(‘public’)); 定义静态文件&#x2F;public&#x2F;index.js 此目录下放 webpack 打包后的 index.js&#x2F;src&#x2F;client&#x2F;index.js 此目录下放客户端执行的代码 123456import React from &#x27;react&#x27;;import ReactDom from &#x27;react-dom&#x27;;import Home from &#x27;../containers/Home&#x27;;// ssr 使用 hydrate 而不是 renderReactDom.hydrate(&lt;Home /&gt;, document.getElementById(&#x27;root&#x27;)) webpack.client.js 放打包客户端代码的配置 1234567891011module.exports = &#123; mode: &#x27;development&#x27;, entry: &#x27;./src/client/index.js&#x27;, output: &#123; filename: &#x27;index.js&#x27;, path: path.resolve(__dirname, &#x27;public&#x27;) &#125;, module: &#123; // ... &#125;&#125; 总结服务端运行 React 代码渲染出 HTML 结构发送 HTML 给浏览器浏览器接受内容展示 （只有 html）浏览器加载 js 文件js 中的运行一样的 React 代码，在浏览器端重新执行 (会执行挂载，绑定事件等)JS 中的 React 代码就接管了服务端发送来的HTML 页面和操作。(正常执行) 第三个问题配置前后端一致的路由同构的目的就是让 JS 中的 react 代码在浏览器上再执行一次接管 html 页面。原来我们的 JS 文件用 react-router来识别浏览器的目录来渲染不同的页面现在浏览器的 url 需要识别到底是后端请求还是前端页面都清楚浏览器执行的代码跟服务端执行的代码是有区别的区别就是在 server 的 React 代码中使用 StaticRouter， 而 client 的 React 代码中使用 BrowserRouter 方法使用 react-router创建 Routes.js 文件 1234567891011import React from &#x27;react&#x27;;import &#123; Route &#125; from &#x27;react-router-dom&#x27;;import Home from &#x27;./containers/Home&#x27;;import Login from &#x27;./containers/Login&#x27;;export default ( &lt;div&gt; &lt;Route path=&#x27;/&#x27; exact component=&#123;Home&#125;&gt;&lt;/Route&gt; &lt;Route path=&#x27;/login&#x27; exact component=&#123;Login&#125;&gt;&lt;/Route&gt; &lt;/div&gt;) 在client&#x2F;index.js 中挂载路由 1234567891011121314import React from &#x27;react&#x27;;import ReactDom from &#x27;react-dom&#x27;;import &#123; BrowserRouter &#125; from &#x27;react-router-dom&#x27;;import Routes from &#x27;../Routes&#x27;;const App = () =&gt; &#123; return ( &lt;BrowserRouter&gt; &#123;Routes&#125; &lt;/BrowserRouter&gt; )&#125;ReactDom.hydrate(&lt;App /&gt;, document.getElementById(&#x27;root&#x27;)) 改造 server&#x2F;index.js 中路由 123456789101112131415161718192021222324import React from &#x27;react&#x27;;import &#123; renderToString &#125; from &#x27;react-dom/server&#x27;;import &#123; StaticRouter &#125; from &#x27;react-router-dom&#x27;;import Routes from &#x27;../Routes&#x27;;export const render = (req) =&gt; &#123; const content = renderToString(( &lt;StaticRouter location=&#123;req.path&#125; context=&#123;&#123;&#125;&#125;&gt; &#123;Routes&#125; &lt;/StaticRouter&gt; )); return ` &lt;html&gt; &lt;head&gt; &lt;title&gt;ssr&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;root&quot;&gt;$&#123;content&#125;&lt;/div&gt; &lt;script src=&#x27;/index.js&#x27;&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; `;&#125; StaticRouterStaticRouter 不像 BrowserRouter 可以直接感知浏览器路径 123&lt;StaticRouter location=&#123;req.path&#125; context=&#123;&#123;&#125;&#125;&gt; &#123;Routes&#125;&lt;/StaticRouter&gt; context 属性用于数据通信location 用于感知浏览器请求的路径，需要把 req.path 传递给 StaticRouter, 当浏览器请求的路径匹配到 Routes 时，server 执行的 StaticRouter 就会把相应的 React 组件返回给浏览器这时候又是服务端 通过 StaticRouter 执行一次，浏览器通过 BrowserRouter 执行一次。 服务端改造改造 get 服务端路由，* 用来匹配所有请求 123app.get(&#x27;*&#x27;, function (req, res) &#123; res.send(render(req));&#125;); 使用 Link 标签123456789const Header = () =&gt; &#123; return ( &lt;div&gt; &lt;Link to=&#x27;/&#x27;&gt;home&lt;/Link&gt; &lt;br /&gt; &lt;Link to=&#x27;/login&#x27;&gt;login&lt;/Link&gt; &lt;/div&gt; )&#125; 回顾和总结仅仅在首次请求会同构跳转路由时候并不会再次请求StaticRouter 只是对应了 BrowersRouter 同步切换 第四个问题 redux 异步数据在前后端上的统一浏览器的 client 代码仍然使用 createStore 使用 Provider 组件进行传递 服务端的 server 代码需要把 store 再做一次传递到 服务端的 react 代码，可以跟 clinet 代码共用 createStore 步骤共用 store 代码&#x2F;store&#x2F;index.js 12345678910111213141516import &#123; createStore, applyMiddleware, combineReducers &#125; from &#x27;redux&#x27;;import thunk from &#x27;redux-thunk&#x27;;import &#123; reducer as homeReducer &#125; from &#x27;../containers/Home/store&#x27;;const reducer = combineReducers(&#123; home: homeReducer&#125;);export const getStore = () =&gt; &#123; return createStore(reducer, applyMiddleware(thunk));&#125;export const getClientStore = () =&gt; &#123; const defaultState = window.context.state; return createStore(reducer, defaultState, applyMiddleware(thunk));&#125; 防止 server 代码使用 单例 store 导致每个用户都用一套 store要使用一个 getStore 方法，让每个用户请求都重新创建一个 store 1234567const content = renderToString(( &lt;Provider store=&#123;getStore()&#125;&gt; &lt;StaticRouter location=&#123;req.path&#125; context=&#123;&#123;&#125;&#125;&gt; ... &lt;/StaticRouter&gt; &lt;/Provider&gt;)); 123export const getStore = () =&gt; &#123; return createStore(reducer, applyMiddleware(thunk));&#125; 服务端客户端共用 redux storecomponentDidMount 只在客户端执行 生命周期只在客户端代码中执行，并没在服务端代码中执行，虽然服务端和客户端同时执行了相关代码实现，但是实际渲染出来的代码是不包含 redux store 里的数据的。 12345componentDidMount() &#123; if (!this.props.list.length) &#123; this.props.getHomeList(); &#125;&#125; 流程整理1.请求项目 -&gt; server2.server 执行 render 来渲染 react 代码 1234567891011121314151617181920212223242526272829303132export const render = (store, routes, req) =&gt; &#123; const content = renderToString(( &lt;Provider store=&#123;store&#125;&gt; &lt;StaticRouter location=&#123;req.path&#125; context=&#123;&#123;&#125;&#125;&gt; &lt;div&gt; &#123;routes.map(route =&gt; ( &lt;Route &#123;...route&#125;/&gt; ))&#125; &lt;/div&gt; &lt;/StaticRouter&gt; &lt;/Provider&gt; )); return ` &lt;html&gt; &lt;head&gt; &lt;title&gt;ssr&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;root&quot;&gt;$&#123;content&#125;&lt;/div&gt; &lt;script&gt; window.context = &#123; state: $&#123;JSON.stringify(store.getState())&#125; &#125; &lt;/script&gt; &lt;script src=&#x27;/index.js&#x27;&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; `; &#125; 这里面的 store 是由 getStore 创建123export const getStore = () =&gt; &#123; return createStore(reducer, applyMiddleware(thunk));&#125; 这时候 store 还是个空的初始数据，而客户端可以执行 生命周期获取数据12345componentDidMount() &#123; if (!this.props.list.length) &#123; this.props.getHomeList(); &#125;&#125; 5.虽然客户端代码执行了 redux 中的请求获取数据渲染，但现在服务端返回的 react 代码还是空数据并没有什么改变，也不会展示在 HTML 上。 让服务端解决异步请求数据让页面上也展示请求数据构建 loadData 代替 componentDidMount解决思路：服务端和客户端有两个 store服务端的是用户每次请求组件通过 getStore() 执行生成的 1234app.get(&#x27;*&#x27;, function (req, res) &#123; const store = getStore(); ...&#125; 客户端的是又客户端 js 代码生成的 使用 loadData:在页面组件里创建 loadData 1234Home.loadData = (store) =&gt; &#123; // 这个函数，负责在服务器端渲染之前，把这个路由需要的数据提前加载好 return store.dispatch(getHomeList())&#125; 路由重构目的：访问 &#x2F; 获取 home 的异步数据访问 &#x2F;login 获取 login 的异步数据 使用 react-router 中 matchPath matchRouter 方法:改造路由对象 123456789101112131415const routes = [ &#123; path: &#x27;/&#x27;, component: Home, exact: true, loadData: Home.loadData, // 告诉路由匹配渲染时执行组件的 loadData 方法，用来让 server 端获取异步数据返回到 html 页面上 key: &#x27;home&#x27; &#125;, &#123; path: &#x27;/login&#x27;, component: Login, exact: true, key: &#x27;login&#x27; &#125;]; 123456789101112131415161718192021222324服务端 &lt;Provider store=&#123;store&#125;&gt; &lt;StaticRouter location=&#123;req.path&#125; context=&#123;&#123;&#125;&#125;&gt; &lt;div&gt; &#123;routes.map(route =&gt; ( &lt;Route &#123;...route&#125;/&gt; ))&#125; &lt;/div&gt; &lt;/StaticRouter&gt; &lt;/Provider&gt;客户端 const App = () =&gt; &#123; return ( &lt;Provider store=&#123;store&#125;&gt; &lt;BrowserRouter&gt; &lt;div&gt; &#123;routes.map(route =&gt; ( &lt;Route &#123;...route&#125;/&gt; ))&#125; &lt;/div&gt; &lt;/BrowserRouter&gt; &lt;/Provider&gt; )&#125; 现在我们已经匹配好了路由的重构让服务端代码匹配到路由时可以请求页面异步数据，但是还不够还需要在服务端被 app.get() 请求时返回页面前把请求完毕的 store 里的数据传递到 server 的 Provider 里再返回到浏览器上. 使用 matchRoutes 匹配多层路由1234567891011121314151617181920export default [ &#123; path: &#x27;/&#x27;, component: Home, // exact: true, loadData: Home.loadData, key: &#x27;home&#x27;, routers: [&#123; path: &#x27;/ttt&#x27;, component: Login, exact: true, key: &#x27;ttt&#x27; &#125;] &#125;, &#123; path: &#x27;/login&#x27;, component: Login, exact: true, key: &#x27;login&#x27; &#125;]; server 根据路由的路径，来往 store 里加数据12345678910111213141516171819import &#123; matchRoutes &#125; from &#x27;react-router-config&#x27;app.get(&#x27;*&#x27;, function (req, res) &#123; const store = getStore(); // 根据路由的路径，来往store里面加数据, matchedRoutes 存放所有匹配到的路由信息 const matchedRoutes = matchRoutes(routes, req.path); // 让matchRoutes里面所有的组件，对应的loadData方法执行一次 const promises = []; matchedRoutes.forEach(item =&gt; &#123; if (item.route.loadData) &#123; // 判断匹配的路由有 loadData 就执行 // 执行 loadData, 让 loadData 具有 store 来 dispatch 把所有 loadData 异步请求回来的结果给 push 到 promises 里。解决 axios 是异步数据的问题 promises.push(item.route.loadData(store)) &#125; &#125;) // 让所有异步数据都执行成功后才返回 HTML，保证 loadData 的数据获取完后才执行 render 返回. Promise.all(promises).then(() =&gt; &#123; res.send(render(store, routes, req)); &#125;)&#125;); 服务端客户端 store 数据统一做到现在当 开启 js 执行时，访问页面还是会出现白屏，虽然 server 的异步数据返回了，但是浏览器还是渲染了 client 的异步数据再渲染 原因客户端代码接管时刚开始加载时客户端的 store 是空的，客户端代码仍然是要等到生命周期请求后才能获取到渲染数据。而服务端 store 是有数据的，和客户端不同, 没有做到统一 解决 脱水注水改写服务端代码的数据 123456789101112131415161718return ` &lt;html&gt; &lt;head&gt; &lt;title&gt;ssr&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;root&quot;&gt;$&#123;content&#125;&lt;/div&gt; &lt;script&gt; // 把 server store 数据放到全局变量下 window.context = &#123; state: $&#123;JSON.stringify(store.getState())&#125; &#125; &lt;/script&gt; &lt;script src=&#x27;/index.js&#x27;&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; `; 改写 client 客户端代码中的 store 123456export const getClientStore = () =&gt; &#123; // 获取 server store 放在全局变量里的数据 const defaultState = window.context.state; // 把这些数据作为 client store 的默认数据, 解决统一问题 return createStore(reducer, defaultState, applyMiddleware(thunk));&#125; 流程服务端通过 loadData 来获取 store 后，返回 html 时把 server 的 store 数据写在全局变量下。客户端执行代码时，让 client 的 store 获取全局变量的数据作为 client 的 store 的默认值，这样客户端的 store 就不是一个初始数据，解决了 server client store 的统一 注意注水脱水虽然解决了问题，但是不能省略 componentDidMount ，不然非首屏时是无法获取数据的，脱水注水只解决的首屏数据统一的问题, 但是生命周期的请求和数据注水又重复消耗性能。折中方案在 componentDidMount 中判断是否重复请求 12345componentDidMount() &#123; if (!this.props.list.length) &#123; this.props.getHomeList(); &#125;&#125; koa-router 源码阅读koa-router 使用1234567891011var Koa = require(&#x27;koa&#x27;);var Router = require(&#x27;koa-router&#x27;);var app = new Koa();var router = new Router();router.get(&#x27;/&#x27;, (ctx, next) =&gt; &#123; // ctx.router available&#125;);app.use(router.routes()) 从 koa-router 的调用 api 来看，是 koa-router 的实例 router 调用了 routes() 方法开启了 http 路由模式 查看调用的 router.js1234567891011121314151617181920212223Router.prototype.routes = Router.prototype.middleware = function () &#123; var router = this; var dispatch = function dispatch(ctx, next) &#123; // ... layerChain = matchedLayers.reduce(function(memo, layer) &#123; memo.push(function(ctx, next) &#123; ctx.captures = layer.captures(path, ctx.captures); ctx.params = layer.params(path, ctx.captures, ctx.params); ctx.routerName = layer.name; return next(); &#125;); return memo.concat(layer.stack); &#125;, []); return compose(layerChain)(ctx, next); &#125;; dispatch.router = this; return dispatch;&#125; 从 router.js 里的 routes 中可以看到，这个实例方法创建了一个 layerChain 的数组，\b通过 compose 方法给每个数组里的元素传递 ctx next 参数。而我们的 koa.use(router.routes()) 可以看做 koa.use(compose(layerChain)(ctx, next))koa.use 方法主要执行的就是 this.middleware.push(middleware) 这个方法，这样可以知道 routes 方法就是通过 layerChain 生成了多个中间件挂载到 koa 的中间件模型中。 寻找 router 是如何使用 layer 的12345678910111213141516171819methods.forEach(function (method) &#123; Router.prototype[method] = function (name, path, middleware) &#123; var middleware; if (typeof path === &#x27;string&#x27; || path instanceof RegExp) &#123; middleware = Array.prototype.slice.call(arguments, 2); &#125; else &#123; middleware = Array.prototype.slice.call(arguments, 1); path = name; name = null; &#125; this.register(path, [method], middleware, &#123; name: name &#125;); return this; &#125;;&#125;); 在 router.js 中有这么一端代码，用处很简单就是给 Router 构造函数创建 HTTP 请求 router.get, router.post 等方法函数供使用者调用，每个 HTTP 请求的方法都执行了 this.register 1234567891011121314151617181920212223242526272829303132333435363738Router.prototype.register = function (path, methods, middleware, opts) &#123; opts = opts || &#123;&#125;; var router = this; var stack = this.stack; // support array of paths if (Array.isArray(path)) &#123; path.forEach(function (p) &#123; router.register.call(router, p, methods, middleware, opts); &#125;); return this; &#125; // create route var route = new Layer(path, methods, middleware, &#123; end: opts.end === false ? opts.end : true, name: opts.name, sensitive: opts.sensitive || this.opts.sensitive || false, strict: opts.strict || this.opts.strict || false, prefix: opts.prefix || this.opts.prefix || &quot;&quot;, ignoreCaptures: opts.ignoreCaptures &#125;); if (this.opts.prefix) &#123; route.setPrefix(this.opts.prefix); &#125; // add parameter middleware Object.keys(this.params).forEach(function (param) &#123; route.param(param, this.params[param]); &#125;, this); stack.push(route); return route;&#125;; this.register 方法的主要作用就在创建和注册一个路由。它创建路由的方法就是把router.get() 等方法传递的参数来创建一个 Layer 实例。最后把每个 layer 实例都存到了 router 实例的 stack 中 查看 layer.js 了解 Layer 的作用1234567891011121314function Layer(path, methods, middleware, opts) &#123; this.opts = opts || &#123;&#125;; this.name = this.opts.name || null; this.methods = []; this.paramNames = []; this.stack = Array.isArray(middleware) ? middleware : [middleware]; // ... this.path = path; this.regexp = pathToRegExp(path, this.paramNames, this.opts); debug(&#x27;defined route %s %s&#x27;, this.methods, this.opts.prefix + this.path);&#125;; 这里可以看出 Layer 实例生成把，router.get() 方法中传递的中间件 middleware 存到了 layer 实例的 stack 中 koa-router 如何匹配路径1234567891011121314151617181920212223242526Router.prototype.match = function (path, method) &#123; var layers = this.stack; var layer; var matched = &#123; path: [], pathAndMethod: [], route: false &#125;; for (var len = layers.length, i = 0; i &lt; len; i++) &#123; layer = layers[i]; debug(&#x27;test %s %s&#x27;, layer.path, layer.regexp); if (layer.match(path)) &#123; matched.path.push(layer); if (layer.methods.length === 0 || ~layer.methods.indexOf(method)) &#123; matched.pathAndMethod.push(layer); if (layer.methods.length) matched.route = true; &#125; &#125; &#125; return matched;&#125;; 我们知道在 Router 会执行 register 把每个 route - layer 实例都 存入 router 实例的 stack 中。在 match 中，把 http 请求来的路径和所有 router 实例存在 stack 的 layer 比较，再返回出去。 回顾下 koa-router 生成 koa-router 实例 router 写 router.get(), router.post() 方法, 执行 Router.prototype[method] 方法，执行Router.prototype.register ，生成 layer 实例存到 router 实例的 stack 中。 layer 实例把每个 http 方法的中间件也 concat 合并到一起，并存到自己的 stack 中。 app.use(router. routes()) 执行 koa-router 实例方法 Router.prototype.routes 在 Router.prototype.routes 方法中返回一个 dispatch 函数 这个 dispatch 函数执行时会执行 Router.prototype.match 把 router 实例存放的所有 layer 实例拿出来进行匹配，匹配上的所有 layer 实例组成 layerChain。 最后 layerChain 通过 compose 生成多个标准的 koa 中间件供 app.use()。 查看 Router.prototype.use 方法12345678// Router.prototype.use 用法 router .use(session()) .use(authorize()); router.use(&#x27;/users&#x27;, userAuth()); router.use([&#x27;/users&#x27;, &#x27;/admin&#x27;], userAuth()); 123456789101112131415161718192021222324252627282930313233343536373839Router.prototype.use = function () &#123; var router = this; var middleware = Array.prototype.slice.call(arguments); var path; // support array of paths if (Array.isArray(middleware[0]) &amp;&amp; typeof middleware[0][0] === &#x27;string&#x27;) &#123; middleware[0].forEach(function (p) &#123; router.use.apply(router, [p].concat(middleware.slice(1))); &#125;); return this; &#125; var hasPath = typeof middleware[0] === &#x27;string&#x27;; if (hasPath) &#123; path = middleware.shift(); &#125; middleware.forEach(function (m) &#123; if (m.router) &#123; m.router.stack.forEach(function (nestedLayer) &#123; if (path) nestedLayer.setPrefix(path); if (router.opts.prefix) nestedLayer.setPrefix(router.opts.prefix); router.stack.push(nestedLayer); &#125;); if (router.params) &#123; Object.keys(router.params).forEach(function (key) &#123; m.router.param(key, router.params[key]); &#125;); &#125; &#125; else &#123; router.register(path || &#x27;(.*)&#x27;, [], m, &#123; end: false, ignoreCaptures: !hasPath &#125;); &#125; &#125;); return this;&#125;; Router.prototype.use 方法的作用就是给 router 实例里可以匹配的路径里添加中间件，对 layer 进行重新注册。通过 use 的方法添加的中间件都是在原匹配路径的其他中间件和路由前执行。 查看 Router.prototype.allowedMethodRouter.prototype.allowedMethod 是用来处理路由执行的错误的，通过传入的配置来自定义错误处理 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960/* * @param &#123;Object=&#125; options * @param &#123;Boolean=&#125; options.throw 开启自定义处理错误 * @param &#123;Function=&#125; options.notImplemented 处理 router 实例中 this.methods 不存在的方法 * @param &#123;Function=&#125; options.methodNotAllowed 处理路由未定义方法的错误函数(只定义了get 没定义 post ，处理post 请求报错) */Router.prototype.allowedMethods = function (options) &#123; options = options || &#123;&#125;; var implemented = this.methods; // array return function allowedMethods(ctx, next) &#123; return next().then(function() &#123; var allowed = &#123;&#125;; if (!ctx.status || ctx.status === 404) &#123; ctx.matched.forEach(function (route) &#123; route.methods.forEach(function (method) &#123; allowed[method] = method; &#125;); &#125;); var allowedArr = Object.keys(allowed); if (!~implemented.indexOf(ctx.method)) &#123; if (options.throw) &#123; var notImplementedThrowable; if (typeof options.notImplemented === &#x27;function&#x27;) &#123; notImplementedThrowable = options.notImplemented(); // set whatever the user returns from their function &#125; else &#123; notImplementedThrowable = new HttpError.NotImplemented(); &#125; throw notImplementedThrowable; &#125; else &#123; ctx.status = 501; ctx.set(&#x27;Allow&#x27;, allowedArr.join(&#x27;, &#x27;)); &#125; &#125; else if (allowedArr.length) &#123; if (ctx.method === &#x27;OPTIONS&#x27;) &#123; ctx.status = 200; ctx.body = &#x27;&#x27;; ctx.set(&#x27;Allow&#x27;, allowedArr.join(&#x27;, &#x27;)); &#125; else if (!allowed[ctx.method]) &#123; if (options.throw) &#123; var notAllowedThrowable; if (typeof options.methodNotAllowed === &#x27;function&#x27;) &#123; notAllowedThrowable = options.methodNotAllowed(); // set whatever the user returns from their function &#125; else &#123; notAllowedThrowable = new HttpError.MethodNotAllowed(); &#125; throw notAllowedThrowable; &#125; else &#123; ctx.status = 405; ctx.set(&#x27;Allow&#x27;, allowedArr.join(&#x27;, &#x27;)); &#125; &#125; &#125; &#125; &#125;); &#125;;&#125;; allowedMethod 返回一个可以生成中间件函数，当返回的 http 响应是 404 或 status 不存在时， 遍历每个 matched 到的 layer，来执行相应的错误逻辑。 参考","categories":[],"tags":[]},{"title":"周常1 算法题5道、koa-bodyparser 源码阅读、async / await 原理回顾","slug":"周常1 算法题5道、koa-bodyparser 源码阅读、async await 原理回顾","date":"2018-12-15T14:42:00.000Z","updated":"2023-09-16T12:09:57.247Z","comments":true,"path":"2018/12/15/周常1 算法题5道、koa-bodyparser 源码阅读、async await 原理回顾/","link":"","permalink":"http://yoursite.com/2018/12/15/%E5%91%A8%E5%B8%B81%20%E7%AE%97%E6%B3%95%E9%A2%985%E9%81%93%E3%80%81koa-bodyparser%20%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E3%80%81async%20await%20%E5%8E%9F%E7%90%86%E5%9B%9E%E9%A1%BE/","excerpt":"","text":"周常 五道算法题 java 实现1.二维数组搜索2.二分查找最小值3.从尾到头打印链表4.用栈表示队列5.重建二叉树 koa-bodyparser 源码解析 async &#x2F; await 原理解析 算法题二维数组中查找1234567891011121314151617输入:matrix = [ [1, 3, 5, 7], [10, 11, 16, 20], [23, 30, 34, 50]]target = 3输出: true---输入:matrix = [ [1, 3, 5, 7], [10, 11, 16, 20], [23, 30, 34, 50]]target = 13输出: false 解题思路 此二维数组是按顺序排列 每一行数组的最后一位都是此行数组的最大值 target 如果比当前数组最后一位大，那 target 肯定在下面的几行数组内 target 如果比当前数组最后一位小，那 target 可能在当前数组内 用 target 与二维数组内的每个数组最后一位比较，在最后一位比 target 大的那一行数组内进行 target 查找 代码实现12345678910111213141516171819public class SearchMatrix &#123; public boolean searchMatrix(int[][] matrix, int target) &#123; if (matrix.length == 0) return false; int i = 0; // 第一行 int j = matrix[0].length - 1; // 最后一个点 while (i &lt; matrix.length &amp;&amp; j &gt;= 0) &#123; if (matrix[i][j] == target) // 第一排最后一个 return true; else if (matrix[i][j] &lt; target) // 如果小，就移动到下一排最后一个 i++; else // matrix[i][j] &gt; target // 如果大，i 就是当前排，在当前排搜索 j--; &#125; return false; &#125;&#125; 搜索二维矩阵 寻找旋转排序数组中的最小值假设按照升序排序的数组在预先未知的某个点上进行了旋转。( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。请找出其中最小的元素。你可以假设数组中不存在重复元素。 解题思路 查找某个值比较合适的解法是二分搜索 此题数组已经是排序数组，变化后有以下几个结果,1234567[1,2,3,4,5] // 顺序不变，直接取数组 arr[0]// 中值 arr[mid] 是数组最大值或最小值[3,4,5,1,2] // arr[mid] 是 5 arr[mid] &gt; arr[mid+1] 最小值是 arr[mid+1][4,5,1,2,3] // arr[mid] 是 1 arr[mid-1] &gt; arr[mid] 最小值是 arr[mid]// 中值 arr[mid] 是数组最大值或最小值以外的值[2,3,4,5,1] // arr[mid] 是 4 最小值在数组右侧，left = mid + 1 继续查找[5,1,2,3,4] // arr[mid] 是 2 最小值在数组左侧，right = mid - 1 继续查找 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142public class BinarySearch &#123; /** * 找到最小数 * nums [3,4,5,1,2], 一定是按顺序排列的数组，只是进行了旋转 * 旋转后=[3,4,5,1,2]， 原数组=[1,2,3,4,5] */ public int findMin(int[] nums) &#123; // 一个数 if (nums.length == 1) return nums[0]; int left = 0, right = nums.length - 1; // [1,2,3,4,5] 为没旋转的原数组 if (nums[right] &gt; nums[0]) return nums[0]; // 进行二分搜索 while (right &gt;= left) &#123; // 找到中点防止溢出 int mid = left + ((right - left) &gt;&gt; 1); // [3,4,5,1,2] midVal = 5 if (nums[mid] &gt; nums[mid + 1]) return nums[mid + 1]; // [4,5,1,2,3] midVal = 1 if (nums[mid - 1] &gt; nums[mid]) return nums[mid]; // [2,3,4,5,1] if (nums[mid] &gt; nums[0]) left = mid + 1; // [5,1,2,3,4] else // nums[mid] &lt; nums[0] right = mid - 1; &#125; return -1; &#125;&#125; 寻找旋转排序数组中的最小值 使用栈实现队列解题思路 队列有 push 添加元素， pop 删除并返回队列头元素，peek 查看队列头的元素, empty 是否为空 实现 Queue 的 push 可以直接使用 Stack 的 push，而队列的头部元素可以用 Front 变量来保存。 实现 Queue 的 pop 需要删除掉 队列的头元素并返回，而 Stack 的 pop 只能返回最后进入的元素，这时候需要 Stack2 协助完成 Stack1 的元素 pop() 出来 push() 到 Stack2 中，这时 Stack2.pop() 出的就是 队列的头部元素 实现队列 peek 方法要考虑两种情况 Stack2 是空的，此时 Queue 队列还没进行 pop() 操作或者 Stack2 已经排空，\b只有 Stack1 有元素, 此时 front 变量就是 peek() 出的元素 Stack2 有元素，此时 Queue 队列已经进行 pop() 操作，Stack2 的栈顶就是队列头，只需要进行 Stack2.peek() 就行了。 代码实现12345678910111213141516171819202122232425262728293031323334353637public class ImplementQueueUsingStacks &#123; private int front; private Stack&lt;Integer&gt; s1 = new Stack&lt;&gt;(); private Stack&lt;Integer&gt; s2 = new Stack&lt;&gt;(); /** Initialize your data structure here. */ public MyQueue() &#123;&#125; /** Push element x to the back of queue. */ public void push(int x) &#123; if (s1.isEmpty()) front = x; s1.push(x); &#125; /** Removes the element from in front of queue and returns that element. */ public int pop() &#123; while (s2.isEmpty()) &#123; if (!s1.isEmpty()) s2.push(s1.pop()); &#125; return s2.pop(); &#125; /** Get the front element. */ public int peek() &#123; if (!s2.isEmpty()) return s2.peek(); return front; &#125; /** Returns whether the queue is empty. */ public boolean empty() &#123; return s1.isEmpty() &amp;&amp; s2.isEmpty(); &#125;&#125; 使用栈实现队列 从尾到头打印链表的值12345// 链表节点结构 private class ListNode &#123; int val; ListNode next; &#125; 实现思路 使用 Stack 保存所有链表的值 再使用 List 保存 Stack.pop() 出来的值 代码实现1234567891011121314151617public class PrintListFromTailToHead &#123; public List&lt;Integer&gt; printListFromTailToHead(ListNode listNode) &#123; Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); while (listNode != null) &#123; stack.push(listNode.val); listNode = listNode.next; &#125; ArrayList&lt;Integer&gt; arrayList = new ArrayList&lt;&gt;(); while (!stack.isEmpty()) &#123; arrayList.add(stack.pop()); &#125; return arrayList; &#125;&#125; 根据中序排列、前序排列重建二叉树实现思路 前序遍历顺序为 [ 根 左 右 ] 12345678910// 前序遍历的序号顺序 0 / \\ 1 9 / \\ / \\ 2 6 10 13 / \\ / \\ / \\ / \\ 3 5 7 8 11 12 14 15 / 4 中序遍历顺序为 [ 左 根 右 ] 12345678910// 中序遍历的序号顺序 8 / \\ 4 12 / \\ / \\ 2 6 10 14 / \\ / \\ / \\ / \\ 1 3 5 7 9 11 13 15 / 0 使用一个函数递归重建二叉树 函数中先确定重建的当前节点树的根节点，前序遍历的第一位 preStart 就是当前树结构的根节点 root &#x3D; preorder[preStart] 确定 root.left 的位置，root.left 为 root 节点的 在前序遍历的位置 preStart + 1 的位置 确定 root.right 的位置, root.right 为 root 节点在前序遍历中 preStart + (所有左子树元素个数) + 1 的位置。 确定 root.right 的位置需要知道 root 所有左子树元素个数，这时只依靠前序遍历的结果是无法得到的，而中序遍历的结果顺序为 [ 左 根 右 ], 我们已经根据前序遍历 preorder[preStart] 确定了 根 root 的值，找到 root 在中序遍历结果中的位置后，此位置在中序遍历中的所有左侧元素就是我们要的结果。 查找当前 root 节点在 inorder 中的位置，已知 root，需要提供此段节点 inStart, inEnd 的位置。这时我们的函数 可写为 public TreeNode helper(int preStart, int inStart, int inEnd, int[] preorder, int[] inorder) &#123;&#125; 找到 root 在 inorder 中的位置 inIndex，inIndex - inStart 为 root 节点所有左子树元素个数， root.right 的 preStart 就为 preStart + inIndex - inStart + 1 在递归函数参数中，通过 inIndex 再来确定 root.left、root.right 的 inStart 和 inEnd 代码实现12345678910111213141516171819202122232425262728293031public class ReConstructBinaryTreeBak2 &#123; // Definition for a binary tree node. public class TreeNode &#123; int val; TreeNode left; TreeNode right; TreeNode(int x) &#123; val = x; &#125; &#125; public TreeNode buildTree(int [] preorder, int [] inorder) &#123; return helper(0, 0, inorder.length - 1, preorder, inorder); &#125; public TreeNode helper(int preStart, int inStart, int inEnd, int[] preorder, int[] inorder) &#123; if (preStart &gt; preorder.length - 1 || inStart &gt; inEnd) return null; TreeNode root = new TreeNode(preorder[preStart]); int inIndex = 0; for (int i = inStart; i &lt;= inEnd; i++) &#123; if (root.val == inorder[i]) inIndex = i; &#125; root.left = helper(preStart + 1, inStart, inIndex - 1, preorder, inorder); root.right = helper(preStart + (inIndex - inStart + 1), inIndex + 1, inEnd, preorder, inorder); return root; &#125;&#125; koa-bodyparser 源码解析作用将 http POST 请求的数据解析成对象挂载到 ctx.request.body 对象上进行使用。koa-bodyparser 中间件默认支持表单格式 application/x-www-form-urlencoded 和 JSON 格式 application/json 源码bodyParser 中间件把请求的使用 parseBody(ctx) 解析成对象进行挂载 12345678910111213141516return async function bodyParser(ctx, next) &#123; if (ctx.request.body !== undefined) return await next(); if (ctx.disableBodyParser) return await next(); try &#123; const res = await parseBody(ctx); // 解析 ctx 数据，默认 from json 两种格式 ctx.request.body = &#x27;parsed&#x27; in res ? res.parsed : &#123;&#125;; // 解析成功把结果挂载到 ctx.request.body 上 if (ctx.request.rawBody === undefined) ctx.request.rawBody = res.raw; &#125; catch (err) &#123; if (onerror) &#123; onerror(err, ctx); &#125; else &#123; throw err; &#125; &#125; await next();&#125;; parseBody 函数使用 co-body 模块进行解析。 123456789101112131415var parse = require(&#x27;co-body&#x27;);// ... async function parseBody(ctx) &#123; if (enableJson &amp;&amp; ((detectJSON &amp;&amp; detectJSON(ctx)) || ctx.request.is(jsonTypes))) &#123; return await parse.json(ctx, jsonOpts); // 解析 json 类型 &#125; if (enableForm &amp;&amp; ctx.request.is(formTypes)) &#123; return await parse.form(ctx, formOpts); // 解析表单类型 &#125; if (enableText &amp;&amp; ctx.request.is(textTypes)) &#123; return await parse.text(ctx, textOpts) || &#x27;&#x27;; // 解析文本类型 &#125; return &#123;&#125;; &#125;&#125;; co-body 模块解析 json, 把请求解析成字符串后进行 JSON.parse(str) 然后返回 1234567891011121314151617const raw = require(&#x27;raw-body&#x27;);const inflate = require(&#x27;inflation&#x27;);module.exports = async function(req, opts) &#123; req = req.req || req; opts = utils.clone(opts); // ... const str = await raw(inflate(req), opts); try &#123; const parsed = parse(str); // JSON.parse return opts.returnRawBody ? &#123; parsed, raw: str &#125; : parsed; &#125; catch (err) &#123; err.status = 400; err.body = str; throw err; &#125; co-body 模块解析 from, 把表单请求解析成字符串后使用 qs.parse 解析后返回 12345678910111213141516171819const raw = require(&#x27;raw-body&#x27;);const inflate = require(&#x27;inflation&#x27;);module.exports = async function(req, opts) &#123; req = req.req || req; opts = utils.clone(opts); const queryString = opts.queryString || &#123;&#125;; // ... const str = await raw(inflate(req), opts); try &#123; const parsed = opts.qs.parse(str, queryString); // 使用 qs.parse 解析 return opts.returnRawBody ? &#123; parsed, raw: str &#125; : parsed; &#125; catch (err) &#123; err.status = 400; err.body = str; throw err; &#125;&#125;; nodejs 的 http 模块接收的 post 请求为可读流内容，co-body 通过使用 raw-body 来解析成 str 供 co-body 来生成返回对象。 1234var inflate = require(&#x27;inflation&#x27;)var raw = require(&#x27;raw-body&#x27;)const str = await raw(inflate(req), opts); 这里使用了 inflate 库，库里返回 http 可读流的解压后 Stream， stream.pip(zip.Unzip(opts)) ，作为参数传给 raw-body 来解析 1234567891011121314151617181920var zlib = require(&#x27;zlib&#x27;)function inflate(stream, options) &#123; // ... switch (encoding) &#123; case &#x27;gzip&#x27;: case &#x27;deflate&#x27;: break case &#x27;identity&#x27;: return stream default: var err = new Error(&#x27;Unsupported Content-Encoding: &#x27; + encoding) err.status = 415 throw err &#125; // no not pass-through encoding delete options.encoding return stream.pipe(zlib.Unzip(options))&#125; raw-body 模块通过 readStream 方法返回解析出来的 buf 字符串数据 123456789function getRawBody (stream, options, callback) &#123; // ... return new Promise(function executor (resolve, reject) &#123; readStream(stream, encoding, length, limit, function onRead (err, buf) &#123; if (err) return reject(err) resolve(buf) &#125;) &#125;)&#125; readStream 方法注册 http stream 的事件进行处理，onData 来处理 POST 请求的 Stream 数据， onEnd 用 done 函数处理事件结束。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950function readStream (stream, encoding, length, limit, callback) &#123; // ... var buffer = decoder ? &#x27;&#x27; : [] stream.on(&#x27;aborted&#x27;, onAborted) stream.on(&#x27;close&#x27;, cleanup) stream.on(&#x27;data&#x27;, onData) stream.on(&#x27;end&#x27;, onEnd) stream.on(&#x27;error&#x27;, onEnd) // ... function onData (chunk) &#123; if (complete) return received += chunk.length if (limit !== null &amp;&amp; received &gt; limit) &#123; done(createError(413, &#x27;request entity too large&#x27;, &#123; limit: limit, received: received, type: &#x27;entity.too.large&#x27; &#125;)) &#125; else if (decoder) &#123; buffer += decoder.write(chunk) &#125; else &#123; buffer.push(chunk) &#125; &#125; function onEnd (err) &#123; if (complete) return if (err) return done(err) if (length !== null &amp;&amp; received !== length) &#123; done(createError(400, &#x27;request size did not match content length&#x27;, &#123; expected: length, length: length, received: received, type: &#x27;request.size.invalid&#x27; &#125;)) &#125; else &#123; var string = decoder ? buffer + (decoder.end() || &#x27;&#x27;) : Buffer.concat(buffer) done(null, string) &#125; &#125;&#125; body-parser 总结koa-bodyparser 通过使用 raw-body 模块解析 http 请求的 stream buffer 数据成字符串格式，再根据请求头中的 MIME 来解析字符串成对应的对象，最后挂载到 ctx.request.body 对象上。 async &#x2F; await 方法解析12345678async function async1() &#123; console.log(&#x27;async1 start&#x27;); await async2(); console.log(&#x27;async1 end&#x27;);&#125;async function async2() &#123; console.log(&#x27;async2&#x27;);&#125; async 函数通过 babel 后为一个自执行函数，返回另一个函数, 而原 async 函数里所要执行的内容将由 function*() &#123; // 执行内容 &#125; 包裹传入 _asyncToGenerator 里 123456789101112131415161718192021let async1 = (() =&gt; &#123; var _ref = _asyncToGenerator(function*() &#123; console.log(&quot;async1 start&quot;); yield async2(); console.log(&quot;async1 end&quot;); &#125;); return function async1() &#123; return _ref.apply(this, arguments); &#125;;&#125;)();let async2 = (() =&gt; &#123; var _ref2 = _asyncToGenerator(function*() &#123; console.log(&quot;async2&quot;); &#125;); return function async2() &#123; return _ref2.apply(this, arguments); &#125;;&#125;)(); 解析 _asyncToGenerator _asyncToGenerator \b的执行1.会先执行传入的 generator 函数2.然后返回一个 new Promise()3.在 new Promise 里执行 step(“next”) 来检查当前函数是否 有 yield 可执行4.有 yield 可执行就通过 Promise.resolve(value).then(&#x2F;&#x2F; 继续执行 step(‘“next”, value))5.一直到当前 generator 函数执行完毕，next() 返回 done 为 true 时才最终返回 resolve(value) 并把执行的结果带出，也就是 await 出来的值。1234567891011121314151617181920212223242526272829function _asyncToGenerator(fn) &#123; return function() &#123; var gen = fn.apply(this, arguments); // 先执行传入 generator 函数 return new Promise(function(resolve, reject) &#123; function step(key, arg) &#123; try &#123; var info = gen[key](arg); var value = info.value; &#125; catch (error) &#123; reject(error); return; &#125; if (info.done) &#123; resolve(value); &#125; else &#123; return Promise.resolve(value).then( function(value) &#123; step(&quot;next&quot;, value); &#125;, function(err) &#123; step(&quot;throw&quot;, err); &#125; ); &#125; &#125; return step(&quot;next&quot;); &#125;); &#125;;&#125; async &#x2F; await 总结当 async 函数执行时，经过内部自执行函数的将会把需要执行的内容直接传入 _asyncToGenerator 中执行，同时直接返回的 new Promise(&#x2F;&#x2F; .. step(“next”)), 而返回的 new Promise 回调中 step(“next”) 函数会一直执行直到 resolve(value) 带出 await 后的执行结果","categories":[],"tags":[]},{"title":"Nodejs 中的 Stream","slug":"Nodejs 中的 Stream","date":"2018-10-28T18:35:00.000Z","updated":"2023-09-13T14:37:03.689Z","comments":true,"path":"2018/10/29/Nodejs 中的 Stream/","link":"","permalink":"http://yoursite.com/2018/10/29/Nodejs%20%E4%B8%AD%E7%9A%84%20Stream/","excerpt":"","text":"什么是 Stream 在 Linux 中，文件实际上可以看做是字节的序列。所有的 I&#x2F;O 设备也是用文件来表示的。 为了区别不同文件的类型，会有一个 type 来进行区别： 普通文件：包含任意数据 目录：相关一组文件的索引 套接字 Socket：和另一台机器上的进程通信的类型 &gt; + 打开文件(open): 返回文件描述符(file descriptor) `注意这里文件的概念` `fs.open(path, flags[, mode], callback) fs.openSync(path, flags[, mode])` `0: standard input(stdin)` `1: standard output(stdout)` `2: standar error(stderr)` 关闭文件(close): 关闭文件描述符(file descriptor) fs.close(fd, callback) fs.closeSync(fd) 读取文件(read): 在打开和关闭之间就是读取文件，实际上就是把文件中对应的字节复制到内存中，并更新文件指针到变量中. fs.read(fd, buffer, offset, length, position, callback) fs.createReadStream(path[, options]) 写入文件(write): 是把内存中的数据复制到文件中，并更新文件指针 fs.write(fd, buffer[, offset[, length[, position]]], callback) fs.createWriteStream(path[, options]) 元数据(stats): 元数据是用来描述数据的数据，由内核维护 fs.statSync(path[, options]) 12345678910111213141516171819Stats &#123; dev: 2114, // Device ino: 48064969, // inode mode: 33188, // Protection &amp; file type nlink: 1, // Number of hard links uid: 85, // User ID of owner gid: 100, // Group ID of owner rdev: 0, // Device type (if inode device) size: 527, // Total size, in bytes blksize: 4096, // Blocksize for filesystem I/O blocks: 8, // Number of blocks allocated atimeMs: 1318289051000.1, mtimeMs: 1318289051000.1, ctimeMs: 1318289051000.1, birthtimeMs: 1318289051000.1, atime: Mon, 10 Oct 2011 23:24:11 GMT, // Time of last access mtime: Mon, 10 Oct 2011 23:24:11 GMT, // Time of last modification ctime: Mon, 10 Oct 2011 23:24:11 GMT, // Time of last change birthtime: Mon, 10 Oct 2011 23:24:11 GMT &#125; 重定向参考操作系统输入输出 了解了具体的结构之后，我们来看看内核是如何表示已打开的文件的。其实过程很简单，每个进程都有自己的描述符表(Descriptor table)，然后 Descriptor 1 指向终端，Descriptor 4 指向磁盘文件，如下图所示： 这里有一个需要说明的情况，就是使用 fork。子进程实际上是会继承父进程打开的文件的。在 fork 之后，子进程实际上和父进程的指向是一样的，这里需要注意的是会把引用计数加 1，如下图所示 了解了这个，我们我们就可以知道所谓的重定向是怎么实现的了。其实很简单，只要调用 dup2(oldfd, newfd) 函数即可。我们只要改变文件描述符指向的文件，也就完成了重定向的过程，下图中我们把原来指向终端的文件描述符指向了磁盘文件，也就把终端上的输出保存在了文件中： 标准 IO 会用流(stream)的形式打开文件，所谓流(stream)实际上是文件描述符(file descriptor)和缓冲区(buffer)在内存中的抽象 Nodejs 中的 StreamStream 模块在 nodejs 中只是处理流数据的抽象接口(abstract interface)，Stream 模块只提供了基础的 API，使用者可以使用这些 API 构建实现流接口的对象。 Stream 流的类型 Readable - 可读的流 (例如 fs.createReadStream()). Writable - 可写的流 (例如 fs.createWriteStream()). Duplex - 可读写的流 (例如 net.Socket). Transform - 在读写过程中可以修改和变换数据的 Duplex 流 (例如 zlib.createDeflate()).Stream 模块还包含 pipeline 和 finished 公用功能 nodejs 中使用到 Stream 接口的模块 nodejs程序一般以标准输入流（stdin）、标准输出流（stdout）、标准错误流（stderr）分别对应 process.stdin、process.stdout、process.stderr 开始的 Stream 事件(event)Stream 中 Readable 和 Writable Readable 发起的重要事件 data 产生数据 end 产生数据结束 Writable 发起的重要事件 drain 缓存区处理完毕 finish 处理结束 可读流 Readable Stream创建一个可读流123456789101112131415const fs = require(&#x27;fs&#x27;)// 创建一个可读流const rs = fs.createReadStream(&#x27;./package-lock.json&#x27;, &#123; // 相当于控制水桶大小 highWaterMark: 1024 // 控制流每次 on data 的大小，默认是16kb&#125;)let onDataCount = 0rs.on(&#x27;data&#x27;, chunk =&gt; &#123; // 每挑桶一次 console.log(chunk.toString(&#x27;utf-8&#x27;)) console.log(onDataCount++) // \b挑桶多少次&#125;)rs.on(&#x27;end&#x27;, () =&gt; &#123; console.log(&#x27;end&#x27;)&#125;) 可读流的 flowing &#x2F; paused 模式 如果我们‘挑‘来的水是需要‘喝’的，每次用桶‘挑’来的水需要‘喝掉’后再去挑下一桶水，那么上一桶水才不会浪费，不然上一桶水没消耗掉就挑来下一桶造成了数据传输的浪费。也就是数据传输时需要考虑到数据消费者的消费速度才能保证高利用率，而发送数据端就是‘生产者’， 接收数据端处理数据是‘消费者’。消费者有：http 请求处理，文件写入处理，数据库处理等。 123456789101112`消费者示例1`const rs = process.stdinlet count = 0rs.on(&#x27;data&#x27;, chunk =&gt; &#123; console.log(chunk.toString()) rs.pause() // 每次接收到数据后都暂停 console.log(rs.isPaused()) console.log(&#x27;count: &#x27;, count++) // 这里我们模拟每次接收的数据处理3 秒再回复flowing 模式 setTimeout(() =&gt; rs.resume(), 3000) &#125;) 上面的例子会导致每次在控制台输入数据后都需要等待3秒后, 再次输入的数据才能被可读流对象接收。在 pause 模式的这段时间里 rs 是不接收 onData 的数据的 1234567891011121314151617181920212223`消费者示例2`const fs = require(&#x27;fs&#x27;)const rs = fs.createReadStream(&#x27;./package-lock.json&#x27;, &#123; highWaterMark: 1024&#125;)console.log(rs.isPaused()) // 检查可读流当前的模式，已经注册let onDataCount = 0rs.on(&#x27;data&#x27;, (data) =&gt; &#123; console.log(data.toString(&#x27;utf-8&#x27;)) console.log(onDataCount++) rs.pause() console.log(&#x27;on data=&gt;&#x27;, rs.isPaused()) setTimeout(() =&gt; rs.resume(), 3000) // 恢复，控制流速，解决背压问题&#125;)console.log(rs.isPaused())rs.on(&#x27;end&#x27;, () =&gt; &#123; console.log(&#x27;end&#x27;)&#125;) 上面是读取文件的情况，会发现每次读取足够 highWaterMark 的数据后会等待3 秒进行消费，消费结束会才会进行下一次 onData 事件。 stream 的背压问题 一个 stream 数据的生产速度远大于 stream 的消费的速度，就会造成数据的堆积。比如不停增长的日志文件(1秒产生100条)作为流的生产者，有个服务处理日志文件(3秒处理100条到数据库)\b作为消费者，如果没有 pause &#x2F; flowing 模式就会撑爆内存造成浪费，让开发者对流的处理具有控制权。 readable 事件精确控制可读流 readable 区别于 data 事件, readable 事件回调内 rs.read(size) 方法就好像从桶中用瓢再一点点的取水一样，可以更精确的控制流数据的读取。但在此事件回调中无法使用paused &#x2F; flowing 模式 12345678// 此事件无法使用 paused resume， 因为不处理完是无法继续操作的.rs.on(&#x27;readable&#x27;, () =&gt; &#123; // 一次处理完成 let dataChunk = rs.read() if (dataChunk) &#123; // 判 null ，有数据后才开始读 console.log(dataChunk.toString()) &#125;&#125;) 1234567rs.on(&#x27;readable&#x27;, () =&gt; &#123; // 精准读取 let dataChunk = rs.read(10) while (dataChunk) &#123; rs.read(10) // 每次挑水到后使用一个 10字节的瓢进行少量读取 &#125;&#125;) 可写流 Writeable Stream创建一个可写流12345678910const fs = require(&#x27;fs&#x27;)const ws = fs.createWriteStream(&#x27;./out.txt&#x27;, &#123; // highWaterMark: 3&#125;)for (let i = 0; i &lt; 1000; i++) &#123; const drained = ws.write(&#x27;hahahahaha\\n&#x27;) // 一个状态，有没有排干，是否写完这一段, highWaterMark 的大小决定 console.log(drained) // 这个状态为false 时 highWaterMark 缓存已经满了，会发送 drain 事件&#125; 实现和使用 Stream 的各种流接口可写流 WriteableWriteable 使用123456789const &#123; Writable &#125; = require(&#x27;stream&#x27;);const outStream = new Writable(&#123; // 创建一个可写流实例 write(chunk, encoding, callback) &#123; // 定义写入数据的操作 console.log(chunk.toString()); callback(); &#125;&#125;);// process.stdin 可读流把控制台输入的数据通过 pipe 方法传输到 outStream 可写流里，调用 write 方法process.stdin.pipe(outStream); write 方法有三个参数 chunk 默认为写入数据的 buffer encoding 写入数据的编码，通常忽略 callback 在处理完 chunk 后需要调用，它通知写入操作成功执行。 自定义 Writeable 实现123456789101112131415161718192021const &#123; Writable &#125;= require(&#x27;stream&#x27;)const fs = require(&#x27;fs&#x27;)class MyWriteable extends Writable &#123; constructor (options) &#123; super(options) &#125; _write(chunk, encoding, callback) &#123; fs.writeSync(1, chunk.toString() + &#x27;\\n&#x27;) // 1 为写入到命令行 和 console.log 一样 setTimeout(() =&gt; callback(null), 100) // callback 传入 null 为正常，出错需要传入一个 Error 对象 &#125; _writev() &#123;&#125; // 并行写入，与_write 冲突&#125;const ws = new MyWriteable()for (let i = 0; i &lt; 100; i++) &#123; ws.write(&#x27;hahahahah&#x27;)&#125; 可读流 ReadableReadable 使用123456789const &#123; Readable &#125; = require(&#x27;stream&#x27;); const inStream = new Readable(&#123; read() &#123;&#125;&#125;);inStream.push(&#x27;ABCDEFGHIJKLM&#x27;);inStream.push(&#x27;NOPQRSTUVWXYZ&#x27;);inStream.push(null); // 通知可读流不再输入数据// inStream 可读流通过 pipe 输出到 process.stdout 可写流中输出到控制台上inStream.pipe(process.stdout); 1234567891011const inStream = new Readable(&#123; // read 方法会在 inStream 可读流调用 pipe 建立通道时执行，不停的发送 data 事件 read(size) &#123; this.push(String.fromCharCode(this.currentCharCode++)); if (this.currentCharCode &gt; 90) &#123; this.push(null); &#125; &#125;&#125;);inStream.currentCharCode = 65;inStream.pipe(process.stdout); 自定义 Readable 实现 自定义 Readable 只需要继承 Readable 并重写实现 _read() 方法就可以了 12345678910111213141516171819202122const &#123; Readable &#125; = require(&#x27;stream&#x27;);// Readable里面有一个read()方法，默认掉_read()// Readable中提供了一个push方法你调用push方法就会触发data事件class MyReadable extends Readable &#123; constructor(options) &#123; super(options) this.count = 0 &#125; _read() &#123; this.count++ if (this.count &gt; 10) &#123; return this.push(null) // push null 就结束了 &#125; &#125;&#125;let rs = new MyReadable(); rs.on(&#x27;data&#x27;, function(data) &#123; // 当 rs 注册 onData 时就开始调用 _reade() console.log(data);&#125;); 背压 back preesurewiki back presssure 在数据传输过程中有一大堆数据在缓存之后积压着。每次当数据到达结尾又遇到复杂的运算，又或者无论什么原因它比预期的慢，这样累积下来，从源头来的数据就会变得很庞大，像一个塞子一样堵塞住。 实现背压123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869const &#123; Readable, Writable &#125;= require(&#x27;stream&#x27;)const colors = require(&#x27;colors&#x27;);const monent = require(&#x27;moment&#x27;)class MyReadable extends Readable &#123; constructor(options) &#123; super(options) this.count = 0 &#125; _read(size) &#123; if (this.count &gt; 1000) &#123; return this.push(null) // push null 就结束了 &#125; if (this.count === 0) console.log(colors.yellow(&#x27;建立连接, 第一次 push 没返回&#x27;)) this.count++ let r setTimeout(() =&gt; &#123; // push -&gt; readQueue highWaterMark 缓存池, flowing 模式下才触发 onData 清理此缓存池 r = this.push(&#x27;...&#x27; + this.count) // 是否到达 readable 水位 console.log(colors.yellow(&#x27;=======reading call push ret======:&#x27;, r, &#x27;count: &#x27;, this.count + &#x27; | &#x27; + monent().format(&#x27;mm:ss&#x27;))) &#125;, 100) if (!r) &#123; // 暂停模式 // 如果生产者的桶满了可以控制生产, 比如通过 size 记录位置 &#125; &#125;&#125;class MyWriteable extends Writable &#123; constructor (options) &#123; super(options) &#125; _write(chunk, encoding, cb) &#123; console.log(colors.blue(&#x27;=======writing======:&#x27; + chunk.toString() + &#x27; | &#x27; + monent().format(&#x27;mm:ss&#x27;))) setTimeout(() =&gt; &#123; console.log(colors.blue(&#x27;=======write finish======:&#x27; + chunk.toString() + &#x27; | &#x27; + monent().format(&#x27;mm:ss&#x27;) + &#x27;\\n&#x27;)) cb(null) &#125;, 500) // 延迟写完数据 &#125;&#125;const rs = new MyReadable(&#123; highWaterMark: 50&#125;)const ws = new MyWriteable(&#123; highWaterMark: 50&#125;)rs.on(&#x27;data&#x27;, data =&gt; &#123; console.log(&#x27;=======on data ready for write======:&#x27;, data.toString() + &#x27; | &#x27; + monent().format(&#x27;mm:ss&#x27;)) // write -&gt; writeQueue highWaterMark 缓存池, writeQueue 任务清理完毕才触发 onDrain const drained = ws.write(data) // 返回 boolean 是否排空, rs 是否还能放更多的东西, 到达 ws 水位 if (!drained) &#123; // 没吸满20就暂停, 没排干, 桶里的水还没喝完 console.log(colors.red(&#x27;=======on data check drained is======:&#x27;, drained, data.toString() + &#x27; | &#x27; + monent().format(&#x27;mm:ss&#x27;))) console.log(colors.red(&#x27;=======on data pause for read======:&#x27; + monent().format(&#x27;mm:ss&#x27;) + &#x27;\\n&#x27;) ) rs.pause() &#125;&#125;)ws.on(&#x27;drain&#x27;, () =&gt; &#123; console.log(colors.green(&#x27;=======on drain with resume for read======:&#x27; + monent().format(&#x27;mm:ss&#x27;) + &#x27;&#x27;) ) rs.resume() // 吸满了，恢复&#125;) 执行结果上面代码，我们让 生产者 100 毫秒生产一次数据 push 到可读流 highWaterMark 缓存池，触发 onData 执行 可写流 write 存放到可写流的 highWaterMark 缓存池，让消费者 500 毫秒消耗一次可写流缓存池的数据，消耗完可写流缓存池的数据后触发 onDrain。这个过程中，消费者消耗的速度远大于生产者的生产速度，当可读流的缓存池满时使可写流进入 pause 状态停止触发 onData 事件，\b直到可写流缓存池消耗完毕触发 onDrain 后才恢复可读流 flowing 事件。 pipe 原理和实现 \bpipe 可以有不同的目的地，pipe 就是解决了背压问题，实现方式就是在可读流上注册一个 onData 事件，达到阈值后进行 pausepipe 源码核心 \b使用 pipe pipe 最大的作用是解决了背压的细节 123456const fs = require(&#x27;fs&#x27;)const rs = fs.createReadStream(&#x27;./package.json&#x27;)const ws = fs.createWriteStream(&#x27;./out.txt&#x27;)rs.pipe(ws) // 解决了背压的细节 实现 pipe看了 node 源码很简单，就是在可写流上注册 onData 和 onDrain 根据可写流的阈值和释放进行 pause flowing 的切换。因为实例是可写可读 pipe 到各个地方，这里的实例应该是个双工流 1234567891011pipe(ws) &#123; this.on(&#x27;data&#x27;, (chunk) =&gt; &#123; let drained = ws.write(chunk); if (!drained) &#123; this.pause(); &#125; &#125;); ws.on(&#x27;drain&#x27;, () =&gt; &#123; this.resume(); &#125;)&#125; 双工流 Duplex 双工流结合了可写流和可读流，同时做到读写互不干扰双工流 duplex 源码继承了 Readable 同时拥有Writeable 方法 123456789101112const util = require(&#x27;util&#x27;);const Readable = require(&#x27;_stream_readable&#x27;);const Writable = require(&#x27;_stream_writable&#x27;);util.inherits(Duplex, Readable);var keys = Object.keys(Writable.prototype);for (var v = 0; v &lt; keys.length; v++) &#123; var method = keys[v]; if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];&#125; Duplex 使用1234567891011121314151617181920const &#123; Duplex &#125; = require(&#x27;stream&#x27;);const inoutStream = new Duplex(&#123; // 通过 pipe 通道进行写入操作时执行 write(chunk, encoding, callback) &#123; console.log(&#x27;w-&#x27;, chunk.toString()); callback(); &#125;, // 建立通道时执行 read read(size) &#123; this.push(String.fromCharCode(this.currentCharCode++)); if (this.currentCharCode &gt; 90) &#123; this.push(null); &#125; &#125;&#125;);inoutStream.currentCharCode = 65;process.stdin.pipe(inoutStream).pipe(process.stdout); 转换流 Transform 转换流本质仍然是双工流，它的输入和输出是存在相互关联的，中间做了一次转换处理，它只需要实现一个transform方法用于转换。 Transform 使用12345678910const &#123; Transform &#125; = require(&#x27;stream&#x27;);const upperCaseTr = new Transform(&#123; transform(chunk, encoding, callback) &#123; this.push(chunk.toString().toUpperCase()); callback(); &#125;&#125;);process.stdin.pipe(upperCaseTr).pipe(process.stdout); Object Mode 对象流默认 Stream 处理的数据是 Buffer 或者 String类型。我们可以设置 objectMode 让流可以接受任何JavaScript对象。 Object Mode 模式的使用1234567891011121314151617181920212223242526272829303132const &#123; Transform &#125; = require(&#x27;stream&#x27;);const commaSplitter = new Transform(&#123; readableObjectMode: true, transform(chunk, encoding, callback) &#123; this.push(chunk.toString().trim().split(&#x27;,&#x27;)); callback(); &#125;&#125;);const arrayToObject = new Transform(&#123; readableObjectMode: true, writableObjectMode: true, transform(chunk, encoding, callback) &#123; const obj = &#123;&#125;; for(let i=0; i &lt; chunk.length; i+=2) &#123; obj[chunk[i]] = chunk[i+1]; &#125; this.push(obj); callback(); &#125;&#125;);const objectToString = new Transform(&#123; writableObjectMode: true, transform(chunk, encoding, callback) &#123; this.push(JSON.stringify(chunk) + &#x27;\\n&#x27;); callback(); &#125;&#125;);process.stdin .pipe(commaSplitter) .pipe(arrayToObject) .pipe(objectToString) .pipe(process.stdout) 参考Stream 文档官方背压系统输入输出参考1参考2参考3-1参考3-2","categories":[{"name":"nodejs","slug":"nodejs","permalink":"http://yoursite.com/categories/nodejs/"}],"tags":[{"name":"nodejs","slug":"nodejs","permalink":"http://yoursite.com/tags/nodejs/"}]},{"title":"编写React组件要点-单一责任原则","slug":"编写React组件要点-单一责任原则","date":"2018-10-28T15:22:31.000Z","updated":"2023-09-12T16:43:23.698Z","comments":true,"path":"2018/10/28/编写React组件要点-单一责任原则/","link":"","permalink":"http://yoursite.com/2018/10/28/%E7%BC%96%E5%86%99React%E7%BB%84%E4%BB%B6%E8%A6%81%E7%82%B9-%E5%8D%95%E4%B8%80%E8%B4%A3%E4%BB%BB%E5%8E%9F%E5%88%99/","excerpt":"","text":"什么是单一原则 单一责任原则 SRP(Single responsibility principle) 是一种计算机编程原理，它规定每个模块或类应该对软件提供的单个功能负责。\b 在 React 里单一责任原则要求组件改变时只有一个原因。 React 组件使用单一责任原则时，当它改变时只会有一个原因，做一件事就会更简单。 多责任陷阱 直接编码，不划分结构 写一个大组件，不划分组件 对 callback、props、fetch 都不拆分 反模式、上帝组件。 多见于 , , , 大量代码 React 单一责任原则设想一个组件12345678910111213141516171819202122232425262728import axios from &#x27;axios&#x27;; // 组件具有多个职责class Weather extends Component &#123; constructor(props) &#123; super(props); this.state = &#123; temperature: &#x27;N/A&#x27;, windSpeed: &#x27;N/A&#x27; &#125;; &#125; render() &#123; const &#123; temperature, windSpeed &#125; = this.state; return ( &lt;div className=&quot;weather&quot;&gt; &lt;div&gt;Temperature: &#123;temperature&#125;°C&lt;/div&gt; &lt;div&gt;Wind: &#123;windSpeed&#125;km/h&lt;/div&gt; &lt;/div&gt; ); &#125; componentDidMount() &#123; axios.get(&#x27;http://weather.com/api&#x27;).then(function(response) &#123; const &#123; current &#125; = response.data; this.setState(&#123; temperature: current.temperature, windSpeed: current.windSpeed &#125;) &#125;); &#125;&#125; 这个组件有两个方式会改变：**(setState 和 render 会导致组件渲染)**1 componentDidMount() 请求 http://weather.com/api 获取数据时 this.setState2 在 render() 里渲染数据时 改写当前组件123456789101112131415161718192021222324import axios from &#x27;axios&#x27;; // 当前组件只负责获取数据class WeatherFetch extends Component &#123; constructor(props) &#123; super(props); this.state = &#123; temperature: &#x27;N/A&#x27;, windSpeed: &#x27;N/A&#x27; &#125;; &#125; render() &#123; const &#123; temperature, windSpeed &#125; = this.state; return ( &lt;WeatherInfo temperature=&#123;temperature&#125; windSpeed=&#123;windSpeed&#125; /&gt; ); &#125; async componentDidMount() &#123; const response = await axios.get(&#x27;http://weather.com/api&#x27;); const &#123; current &#125; = response.data; this.setState(&#123; temperature: current.temperature, windSpeed: current.windSpeed &#125;); &#125;&#125; 12345678910// 组件只负责展示数据，展示逻辑可写在内部 function WeatherInfo(&#123; temperature, windSpeed &#125;) &#123; const windInfo = windSpeed === 0 ? &#x27;calm&#x27; : `$&#123;windSpeed&#125; km/h`; return ( &lt;div className=&quot;weather&quot;&gt; &lt;div&gt;Temperature: &#123;temperature&#125;°C&lt;/div&gt; &lt;div&gt;Wind: &#123;windInfo&#125;&lt;/div&gt; &lt;/div&gt; );&#125; HOC 高阶组件 借用高阶函数的概念：高阶组件是一个函数，入参接受一个组件返回值也是一个组件 属性代理 props proxy 高阶组件为封装的组件传递新的 props 或者改变现有的 props，这种方式称为属性代理 12345678910111213141516function withNewFunctionality(WrappedComponent) &#123; return class NewFunctionality extends Component &#123; render() &#123; const newProp = &#x27;Value&#x27;; const propsProxy = &#123; ...this.props, // Alter existing prop: ownProp: this.props.ownProp + &#x27; was modified&#x27;, // Add new prop: newProp &#125;; return &lt;WrappedComponent &#123;...propsProxy&#125; /&gt;; &#125; &#125;&#125;const MyNewComponent = withNewFunctionality(MyComponent); 渲染劫持 render highjacking 通过更改组件 render 方法来改变组件的渲染方式，这种方式称为渲染劫持 123456789101112131415161718function withModifiedChildren(WrappedComponent) &#123; return class ModifiedChildren extends WrappedComponent &#123; render() &#123; const rootElement = super.render(); const newChildren = [ ...rootElement.props.children, // Insert a new child: &lt;div&gt;New child&lt;/div&gt; ]; return cloneElement( rootElement, rootElement.props, newChildren ); &#125; &#125;&#125;const MyNewComponent = withModifiedChildren(MyComponent); HOC 高阶组件单一责任原则先定义多重责任组件1234567891011121314151617181920212223242526272829class PersistentForm extends Component &#123; constructor(props) &#123; super(props); this.state = &#123; inputValue: localStorage.getItem(&#x27;inputValue&#x27;) &#125;; this.handleChange = this.handleChange.bind(this); this.handleClick = this.handleClick.bind(this); &#125; render() &#123; const &#123; inputValue &#125; = this.state; return ( &lt;div className=&quot;persistent-form&quot;&gt; &lt;input type=&quot;text&quot; value=&#123;inputValue&#125; onChange=&#123;this.handleChange&#125;/&gt; &lt;button onClick=&#123;this.handleClick&#125;&gt;Save to storage&lt;/button&gt; &lt;/div&gt; ); &#125; handleChange(event) &#123; this.setState(&#123; inputValue: event.target.value &#125;); &#125; handleClick() &#123; localStorage.setItem(&#x27;inputValue&#x27;, this.state.inputValue); &#125;&#125; constructor 内进行数据初始化 button 点击时保存数据 input 内容改变时更新组件状态 抽离出保存数据逻辑1234567891011121314151617181920212223242526272829class PersistentForm extends Component &#123; constructor(props) &#123; super(props); this.state = &#123; inputValue: props.initialValue &#125;; this.handleChange = this.handleChange.bind(this); this.handleClick = this.handleClick.bind(this); &#125; render() &#123; const &#123; inputValue &#125; = this.state; return ( &lt;div className=&quot;persistent-form&quot;&gt; &lt;input type=&quot;text&quot; value=&#123;inputValue&#125; onChange=&#123;this.handleChange&#125;/&gt; &lt;button onClick=&#123;this.handleClick&#125;&gt;Save to storage&lt;/button&gt; &lt;/div&gt; ); &#125; handleChange(event) &#123; this.setState(&#123; inputValue: event.target.value &#125;); &#125; handleClick() &#123; this.props.saveValue(this.state.inputValue); &#125;&#125; 改写组件，使数据初始化和保存功能都由 props 传递 此组件现在只负责 input 的数据变化，数据和保存逻辑都由外部提供 编写可复用的单一责任原则的高阶组件12345678910111213141516171819202122232425// 给函数传递两个参数，一个是数据获取的 key 值，一个是存储函数function withPersistence(storageKey, storage) &#123; // 高阶组件函数 return function(WrappedComponent) &#123; return class PersistentComponent extends Component &#123; constructor(props) &#123; super(props); this.state = &#123; initialValue: storage.getItem(storageKey) &#125;; &#125; render() &#123; return ( &lt;WrappedComponent initialValue=&#123;this.state.initialValue&#125; saveValue=&#123;this.saveValue&#125; &#123;...this.props&#125; /&gt; ); &#125; saveValue(value) &#123; storage.setItem(storageKey, value); &#125; &#125; &#125;&#125; 123// 调用方式const LocalStoragePersistentForm = withPersistence(&#x27;key&#x27;, localStorage)(PersistentForm); 隔离了数据操作和展示操作 数据操作可以通过高阶函数传参改变存储 API 或 key 值 符合单一责任原则：允许在隔离中进行修改，从而较少影响系统的其他部分。","categories":[{"name":"React","slug":"React","permalink":"http://yoursite.com/categories/React/"}],"tags":[{"name":"React","slug":"React","permalink":"http://yoursite.com/tags/React/"}]},{"title":"HTTP相关系统知识","slug":"HTTP相关系统知识","date":"2018-10-26T15:22:06.000Z","updated":"2023-09-12T16:44:29.269Z","comments":true,"path":"2018/10/26/HTTP相关系统知识/","link":"","permalink":"http://yoursite.com/2018/10/26/HTTP%E7%9B%B8%E5%85%B3%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86/","excerpt":"","text":"因特网协议五层协议 物理层定义物理设备如何传输数据 数据链路层在通信的实体间建立数据链路连接 网络层为数据在节点之间传输创建逻辑链路 传输层向用户提供可靠的端到端服务传输层向高层屏蔽了下层数据通信的细节 应用层为应用软件提供了更多服务构建于 TCP 协议之上屏蔽网络传输相关细节 HTTP 历史 HTTP &#x2F; 0.9只有一个命令 GET没有HEADER 等描述数据的信息服务器发送完毕就关闭 TCP 连接 HTTP &#x2F; 1.0增加了很多命令增加 status code 和header多字符集的支持、多部分发送、权限、缓存 HTTP &#x2F; 1.1持久连接pipeline(同一个连接里发送多个请求)增加 host 和其他命令 (物理服务、集群里 host 区分部署的 web 服务) HTTP2所有数据以二进制传输同一个连接里发送多个请求不再需要按照顺序(并行)头信息压缩以及推送提高效率的功能(资源返回和 ajax 并行) URI 、URL、URN URIUniform Resource Identifier &#x2F; 统一资源标识符用来标识互联网上唯一的信息资源包括 URL、URN URLUniform Resource Locator &#x2F; 统一资源定位器http、ftp 协议都是同一个格式http://user:pass@host.com:80/path?query=string#hash schema: http:&#x2F;&#x2F; file:&#x2F;&#x2F; https:&#x2F;&#x2F;host: 找到物理服务器端口: 定位 web 服务器path: 路由、资源目录query: 查询参数hash: 文档片段、锚点定位 URN永久统一资源定位符在资源移动之后还能被找到不成熟 HTTP 请求 报文 HTTP 方法用来定义对于资源的操作常用 GET、POST、DETEL、PUT、PATCH有各自的语义 HTTP code定义服务器对请求的处理结果各个区间的 code 各自的语义好的 HTTP 服务可以通过 code 判断结果 命令行发送请求 curl1curl -v url 同源限制Access-Control-Allow-Origin CORS 预请求 允许方法GET HEAD POST 允许的Content-Typetext/plainmultipart/form-dataapplication/x-www-form-urlencoded 其他限制自定义 header 限制XMLHttpRequestUpload 对象没有注册时间监听请求中没有使用 ReadableStream 对象 HTTP 缓存 强缓存 Cache-Control可缓存性public: 任何地方都可缓存，http 代理服务器、发出请求的客户端浏览器都可缓存private: 发起请求的客户端浏览器才可缓存no-cache: 任何节点都不可使用缓存(可缓存但服务器指定其不使用) 到期max-age=&lt;seconds&gt;: 缓存时间s-maxage=&lt;seconds&gt;: 会代替 max-age 只在代理服务器生效max-stale=&lt;seconds&gt;: max-age 过期后仍然使用过期缓存，发起请求的客户端设置(浏览器不常用) 资源重新验证must-revalidate: 过期后会去原服务端验证是否过期proxy-revalidate: 指定的缓存服务器验证是否过期 其他no-store: 本地不可缓存no-transform: 常用于 proxy 服务器里, 资源不可转换压缩 协商缓存验证 header Last-Modified Etag Last-Modified配合 If-Modified-Since 或 If-Unmodified-Since 使用对比上次修改时间验证资源是否需要更新 Etag文件完整性 hash 数据签名配合 If-Match 或 If-Non-Match 使用对比资源的 hash 签名是否一致决定是否使用缓存 cookie &amp; sessioncookieSet-Cookie 设置同源下再次请求会自动带上键值对形式，可以设置多个 cookie 属性max-age 和 expires 设置过期时间Secure 只在 https 请求的时候才发送 cookieHttpOnly 无法通过 document.cookie 访问 cookiedomain 设置二级域名可访问的 cookie (domain&#x3D;yang.com，a.yang.com, b.yang.com 都可以访问) 长连接Connection: keep-alive | closehttp&#x2F;1.1 无法并发，在网速慢的情况下还是会创建多个 ConnectionID 数据协商分类MIME types 请求 响应 请求 header - AcceptAccept: 想要的数据类型Accept-Encoding: 什么样的编码方式传输, 用于数据压缩格式Accept-Language: 数据语言User-Agent: 浏览器信息判断 响应 header - ContentContent-Type: 返回的数据格式Content-Encoding: 对应客户端请求的 Accept-EncodingContent-Language: 对应客户端请求的 Accept-Language 数据压缩zlib 压缩zlib.gzipSync(buffer)Content-Encoding: gzip没压缩前压缩后 文件数据协商Content-Type: multipart/form-data 重定向 redirect响应 header : Location: /url响应 CODE: 302 301 才可以跳转 123response.writeHead(301, &#123; &#x27;Location&#x27;: &#x27;/new&#x27;,&#125;) 301 302 区别 302 临时跳转请求 / 重定向到 /new每次后台都会收到两次请求 301 永久跳转浏览器会尽量长的缓存 301 请求，需要慎重设置, 浏览器如果不清缓存会造成一直跳转 请求 / 重定向到 /new后台第一次会收到两次请求第二次只会收到/new 内容安全策略 CSPContent-Security-Policy: 限制资源获取报告资源获取越权 限制方式default-src 限制全局制定资源类型 资源类型MDNconnect-src &#x2F; img-src &#x2F; style-src &#x2F; script-src 等 设置 CSP12345678// 服务端设置 &#x27;Content-Security-Policy&#x27;: &#x27;default-src http: https:&#x27; // 只能根据外链 &#x27;Content-Security-Policy&#x27;: &#x27;script-src http: https:&#x27; // 只限制script &#x27;Content-Security-Policy&#x27;: &#x27;default-src \\&#x27;self\\&#x27; https://cdn.bootcss.com&#x27; // 只根据本域名, 增加 cdn.bootcss.com 域名 &#x27;Content-Security-Policy&#x27;: &#x27;default-src \\&#x27;self\\&#x27;&#x27; // 只根据本域名 &#x27;Content-Security-Policy&#x27;: &#x27;default-src \\&#x27;self\\&#x27;; form-action \\&#x27;self\\&#x27;&#x27; // 限制表单提交 &#x27;Content-Security-Policy&#x27;: &#x27;default-src \\&#x27;self\\&#x27;; form-action \\&#x27;self\\&#x27;; report-uri /report&#x27; // 服务器上报 &#x27;Content-Security-Policy-Report-Only&#x27;: &#x27;default-src \\&#x27;self\\&#x27;; form-action \\&#x27;self\\&#x27;; report-uri /report&#x27; // 服务器只上报，但是课加载 12// meta 标签设置 &lt;meta http-equiv=&quot;Content-Security-Policy&quot; content=&quot;default-src &#x27;self&#x27;; form-action &#x27;self&#x27;; report-uri /report&quot;&gt; 被 csp 禁止 设置 connect-src 可以限制 ajax 发送 nginx统一配置文件nginx.conf 1include servers/*; // 此目录下的所有 .conf 文件 代理访问 yang.com 下的 &#x2F; 路径代理到本地 8888 端口 123456789server &#123; listen 80; server_name yang.com; # 要配置 host 不然就访问外网了 location / &#123; proxy_pass http://127.0.0.1:8888; proxy_set_header Host $host; # host配置 &#125;&#125; 代理缓存12345678910111213# 缓存proxy_cache_path cache levels=1:2 keys_zone=my_cache:10m; # levels=1:2 是否创建二级文件夹, keys_zone 缓存大小server &#123; listen 80; server_name yang.com; # 要配置 host 不然就访问外网了 location / &#123; proxy_cache my_cache; # 配置的缓存名 proxy_pass http://127.0.0.1:8888; proxy_set_header Host $host; # host配置 &#125;&#125; 1234&#x27;Cache-Control&#x27;: &#x27;max-age=5, s-maxage=20&#x27; 浏览器缓存 5s 代理服务器缓存 20s&#x27;Cache-Control&#x27;: &#x27;max-age=5, s-maxage=20, private&#x27; // 只可浏览器缓存&#x27;Cache-Control&#x27;: &#x27;max-age=5, s-maxage=20, no-store&#x27; // 都不可缓存&#x27;Vary&#x27;: &#x27;X-Test-Cache&#x27; // 指定的 X-Test-Cache 头才可缓存，比如 req header 发了 X-Test-Cache： user-agent， s-maxage 代理服务器缓存，对应多个客户端请求加速 Vary 当 req.header: X-Test-Cache 为 1 时发送后，代理缓存了 X-Test-Cache 为 1 这个请求，下次其他客户端请求 X-Test-Cache 为 1 则使用代理服务器缓存。可以使用 user-agent 进行代理服务器的设备缓存。 HTTPS 生成密钥1openssl req -x509 -newkey rsa:2048 -nodes -sha256 -keyout test-privkey.pem -out test-cert.pem nginx 生成 https 服务1234567891011121314server &#123; listen 443; server_name yang.com; # 要配置 host 不然就访问外网了 ssl on; ssl_certificate_key /usr/local/etc/openssl/test/test-privkey.pem; # 密钥路径 ssl_certificate /usr/local/etc/openssl/test/test-cert.pem; # 密钥路径 location / &#123; proxy_cache my_cache; # 配置的缓存名 proxy_pass http://127.0.0.1:8888; proxy_set_header Host $host; # host配置 &#125;&#125; http 跳转到 https1234567# http 跳转到 httpsserver &#123; listen 80 default_server; listen [::]:80 default_server; server_name yang.com; return 302 https://$server_name$request_uri; # 进行 302 跳转&#125; HTTP2开启 https 才可使用 http2 优势信道复用、分帧传输: 并发的 TCP 连接只创建一个 TCPServer Push: 服务端主动发送 server 编写 http2123456789101112// ... if (request.url === &#x27;/&#x27;) &#123; response.writeHead(200, &#123; &#x27;Content-Type&#x27;: &#x27;text/html&#x27;, &#x27;Connection&#x27;: &#x27;close&#x27;, &#x27;Link&#x27;: &#x27;&lt;/carbon.png&gt;; as=image; rel=preload&#x27; // http2 需要进行服务端推送 &#125;) response.end(html) &#125;// ... nginx 将 http2 转为 http1.1nginx 可以将 http2 转成 1.1 版本传输给服务端 123456789101112131415server &#123; listen 443 http2; server_name yang.com; # 要配置 host 不然就访问外网了 http2_push_preload on; # 开启服务器推送 ssl on; ssl_certificate_key /usr/local/etc/openssl/test/test-privkey.pem; ssl_certificate /usr/local/etc/openssl/test/test-cert.pem; location / &#123; proxy_cache my_cache; # 配置的缓存名 proxy_pass http://127.0.0.1:8888; proxy_set_header Host $host; # host配置 &#125;&#125; 推送结果测试 HTTP2 性能 123$ curl -v https://yang.com $ curl -v -k https://yang.com // 打开不安全 ssl 限制$ curl -v -k --http1.1 https://yang.com // 指定 http1.1 访问","categories":[{"name":"http","slug":"http","permalink":"http://yoursite.com/categories/http/"}],"tags":[{"name":"http","slug":"http","permalink":"http://yoursite.com/tags/http/"}]},{"title":"nodejs 的 Event Loop 和 EventEmitter","slug":"nodejs 的 Event Loop 和 EventEmitter","date":"2018-09-07T11:25:00.000Z","updated":"2023-09-13T14:24:25.672Z","comments":true,"path":"2018/09/07/nodejs 的 Event Loop 和 EventEmitter/","link":"","permalink":"http://yoursite.com/2018/09/07/nodejs%20%E7%9A%84%20Event%20Loop%20%E5%92%8C%20EventEmitter/","excerpt":"","text":"nodejs 的 Event Loopnodejs 执行环境的 Event Loop 与浏览器上的不同，\bnodejs 使用 V8 作为 JS 的解释器，在 I&#x2F;O 处理方面使用自己设计的 libuv，libuv 封装了不同 OS 平台的 I&#x2F;O 操作，提供一致的异步(asynchronous) 、非阻塞(non-blocking) API、事件循环方式。 nodejs 的单线程nodejs 的单线程不是绝对的，在用户界面视图上的 js 是单线程的，\b但是使用 nodejs 创建应用程序是多线程的。nodejs 需要维持一个线程池用来委托同步任务，同时 V8 会为垃圾回收创建自己的线程。 The famous statement ‘Node.js runs in a single thread’ is only partly true. Actually only your ‘userland’ code runs in one thread. Starting a simple node application and looking at the processes reveals that Node.js in fact spins up a number of threads. This is because Node.js maintains a thread pool to delegate synchronous tasks to, while Google V8 creates its own threads for tasks like garbage collection. Event Loop 模型 Event Loop 的特点 每个 phase 阶段都有存放与自己相关回调的 queue 进入一个 phase 后，都会执行完自己 queue 的回调才会进入下一个 phase 在回调中执行长时间任务会被阻塞 在每次运行的事件循环之间，Node.js 检查它是否在等待任何异步 I&#x2F;O 或计时器，如果没有的话，则关闭干净, 事件循环就结束了 比如 app.js 里只有简单的运行代码，执行完后进事件循环就结束了。 1234// app.jsconsole.log(&#x27;event loop start!&#x27;)console.log(&#x27;event loop stop&#x27;) 如果启动了一个 http.createServer().listen 就会一直执行，底层开启了 socket 一直等待 I&#x2F;O 事件, 直到进行 close 1234567891011121314151617181920212223// app.jsconst http = require(&#x27;http&#x27;)const server = http.createServer()console.log(&#x27;event loop start!&#x27;)setTimeout(() =&gt; server.close(), 2000) // timers 阶段let t = null// 启动 I/O 事件server.listen(3000, () =&gt; &#123; console.log(&#x27;poll running&#x27;) t = setInterval(() =&gt; console.log(&#x27;poll&#x27;), 500) // 进行轮询&#125;)// close callbacks 阶段server.on(&#x27;close&#x27;, () =&gt; &#123; clearInterval(t) console.log(&#x27;event loop stop&#x27;)&#125;) Event Loop 各阶段说明 timers 阶段：执行已经准备好的 setTimeout、setInterval 回调。 pending callbacks 阶段：执行被延迟到下一个 event loop 的I&#x2F;O回调。如网络、stream、tcp错误回调 idle, prepare 阶段：内部使用。 poll 阶段：取出新的 I&#x2F;O 事件回调执行，(除: close 事件、setImmediate、timers 回调) node 程序将在这个阶段阻塞。 check 阶段：setImmediate() 将在这个阶段调用。 close callbacks 阶段：close 事件的回调将在这执行，如 socket.on(‘close’, …) 事件轮询机制 nodejs 事件循环的轮询阶段跟浏览器上的 event loop 相似，区别在于置入回调队列的任务是 连接、数据、输入等。有关轮询中有关 promise 等 MicroTask MacroTask 执行顺序可以查看下面两篇事件循环中的 MacroTask与 MicroTask浏览器的事件循环 setTimeout() 与 setImmediate() 对比 setTimeout() 属于 timers phase，设计在定时完成后执行。 setImmediate() 属于 check phase。每次 poll phase 后执行。 如果在 I&#x2F;O 循环中调用，setImmediate 一定先执行 (因为下一个阶段就是 check 阶段)。否则 setImmediate() 与 setTimeout(cb, 0) 的执行顺序不可预测 两者在执行顺序上不能确定 1234567setImmediate(() =&gt; &#123; console.log(&#x27;immediate&#x27;);&#125;);setTimeout(() =&gt; &#123; console.log(&#x27;timeout&#x27;);&#125;, 0); 如果处于 IO 循环，setImmediate() 回调的执行一定先于 setTimeout() 12345678910const fs = require(&#x27;fs&#x27;);fs.readFile(__filename, () =&gt; &#123; setTimeout(() =&gt; &#123; console.log(&#x27;timeout&#x27;); &#125;, 0); setImmediate(() =&gt; &#123; console.log(&#x27;immediate&#x27;); &#125;);&#125;); 理解 process.nextTick() process.nextTick() 不属于 Event Loop 的各个阶段 process.nextTick() 的回调在每个阶段结束后进入下个阶段前同步执行 绝不可在 process.nextTick 的 callback 中执行 long-running task 不要执行会返回process.nextTick 的函数，不然这个阶段会一直认为还有回调需要执行，事件循环会被阻塞在这个阶段。 12345678910let bar;function someAsyncApiCall(callback) &#123; callback(); &#125;someAsyncApiCall(() =&gt; &#123; // 同步的执行，但此时变量还没赋值 console.log(&#x27;bar&#x27;, bar); // undefined&#125;);bar = 1; 123456789101112let bar;function someAsyncApiCall(callback) &#123; process.nextTick(callback);&#125;someAsyncApiCall(() =&gt; &#123; // process.nextTick 使此回调在阶段结束后才执行 console.log(&#x27;bar&#x27;, bar); // 1&#125;);bar = 1; 1234567891011121314const EventEmitter = require(&#x27;events&#x27;);class MyEmitter extends EventEmitter &#123; constructor() &#123; super() this.emit(&#x27;event&#x27;); // 不会正常触发，事件还没绑定 &#125;&#125;const myEmitter = new MyEmitter();myEmitter.on(&#x27;event&#x27;, () =&gt; &#123; console.log(&#x27;an event occurred!&#x27;);&#125;); 12345678910111213141516const EventEmitter = require(&#x27;events&#x27;);class MyEmitter extends EventEmitter &#123; constructor() &#123; super() process.nextTick(() =&gt; &#123; this.emit(&#x27;event&#x27;); // 会正常触发，因为是在继承阶段结束后才执行 &#125;) &#125;&#125;const myEmitter = new MyEmitter();myEmitter.on(&#x27;event&#x27;, () =&gt; &#123; console.log(&#x27;an event occurred!&#x27;);&#125;); process.nextTick() 与 setImmediate() 对比 process.nextTick() 不属于 Event Loop 的各个阶段 process.nextTick() 的回调在每个阶段结束后进入下个阶段前同步执行 process.nextTick() 在同一个阶段立即执行。 setImmediate() 只每次 poll phase 后进入 check phase 才执行。 process.nextTick() 比 setImmediate() 触发得更直接。 setImmediate() 更容易理解，如果需要拆分 long-running task 请使用 setImmediate() EventEmitternodejs 的大多模块(如HTTP request、response 和 stream)都继承了 EventEmitter 模块，它们可以触发和监听事件。 Events 模块核心实现Events 模块的核心实现非常简单，让你可以创建一个 event pattern 的工具，是 nodejs 事件驱动的核心，但它本身跟 nodejs 的 Event Loop 没有任何关系。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051class MyEventEmitter &#123; constructor () &#123; this.events = &#123;&#125; // 事件对象 &#125; listeners (type) &#123; return this.events[type] &#125; addListener (type, listener) &#123; if (this.events[type]) this.events[type] = [ ...this.events[type], listener ] else this.events[type] = [ listener ] &#125; once (type, listener) &#123; this.addListener(type, _onceWrap(this, type, listener)) return this &#125; removeListener (type, listener) &#123; if (this.events[type].length &gt; 0) this.events[type] = this.events[type].filter(item =&gt; item !== listener) return this &#125; removeAllListener (type) &#123; delete this.events[type] &#125; emit (type, ...args) &#123; if (type === &#x27;error&#x27; &amp;&amp; !this.events[type].length) throw new Error(&#x27;emit error event !~&#x27;) this.events[type] &amp;&amp; this.events[type].forEach(listener =&gt; Reflect.apply(listener, this, args)) &#125; get on() &#123; return this.addListener &#125; get off() &#123; return this.removeListener &#125;&#125;function _onceWrap(target, type, listener) &#123; const wrapped = (...args) =&gt; target.removeListener(type, wrapped) &amp;&amp; Reflect.apply(listener, target, args) return wrapped&#125; Events 是同步的Events 的调用非常简单 12e.on(&#x27;event&#x27;)e.emit(&#x27;event&#x27;, cb) Events 仅仅只是简单的执行了事件的回调函数，它是同步执行的。每一次的 emit，都是同步的执行了所绑定事件 queue 里的回调 。而 EventEmitter 本身与 nodejs 的 Event Loop 没有关系，也不存在异步执行的代码，是否异步只跟传入的回调函数有关。 123456EE.on(&#x27;data&#x27;, function (data) &#123; console.log(data);&#125;);fs.readFile(__filename, (err, data) =&gt; &#123; if (!err) EE.emit(&#x27;data&#x27;, data);&#125;); EventEmitter 需要注意的地方下面代码会造成 Maximum call stack size exceeded 报错, 因为所有的回调都是同步的，会在一个 poll phase 阶段不停执行下去，一直到系统崩溃. 123456789101112131415const EventEmitter = require(&quot;events&quot;)const EE = new EventEmitter()EE.on(&#x27;event1&#x27;, function () &#123; console.log(&#x27;event1 fired!&#x27;); EE.emit(&#x27;event2&#x27;);&#125;)EE.on(&#x27;event2&#x27;, function () &#123; console.log(&#x27;event2 fired!&#x27;); EE.emit(&#x27;event3&#x27;);&#125;)EE.on(&#x27;event3&#x27;, function () &#123; console.log(&#x27;event3 fired!&#x27;); EE.emit(&#x27;event1&#x27;);&#125;)EE.emit(&#x27;event1&#x27;); 换成 setImmediate() 来调用 emit ，会发现这段程序不会崩溃，setImmediate 把回调放入了每次轮询的下个阶段才进行，一个真正的通过 events 模块创建的异步代码. 123456789101112131415161718192021const EventEmitter = require(&quot;events&quot;)const EE = new EventEmitter()EE.on(&#x27;event1&#x27;, function () &#123; console.log(&#x27;event1 fired!&#x27;); setImmediate(() =&gt; &#123; EE.emit(&#x27;event2&#x27;); &#125;)&#125;)EE.on(&#x27;event2&#x27;, function () &#123; console.log(&#x27;event2 fired!&#x27;); setImmediate(() =&gt; &#123; EE.emit(&#x27;event3&#x27;); &#125;)&#125;)EE.on(&#x27;event3&#x27;, function () &#123; console.log(&#x27;event3 fired!&#x27;); setImmediate(() =&gt; &#123; EE.emit(&#x27;event1&#x27;); &#125;)&#125;)EE.emit(&#x27;event1&#x27;); EventEmitter 中使用 process.nextTick()如果把上面的代码 setImmediate() 换成 process.nextTick() 讲会报错，因为 process.nextTick() 是在当前阶段结束时且在下个阶段前执行，而在 process.nextTick() 里触发回调会导致程序一直认为当前阶段还有任务需要执行而出错的，这个阶段将会有无法清除的 nextTick 需要执行。 参考1参考2参考3","categories":[{"name":"nodejs","slug":"nodejs","permalink":"http://yoursite.com/categories/nodejs/"}],"tags":[{"name":"nodejs","slug":"nodejs","permalink":"http://yoursite.com/tags/nodejs/"}]},{"title":"JavaScript 中的垃圾回收","slug":"JavaScript中的垃圾回收","date":"2018-04-16T17:12:31.000Z","updated":"2018-04-16T17:12:57.000Z","comments":true,"path":"2018/04/17/JavaScript中的垃圾回收/","link":"","permalink":"http://yoursite.com/2018/04/17/JavaScript%E4%B8%AD%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/","excerpt":"","text":"1234内存的生命周期javascript 的内存分配javascript 垃圾回收的方法和方式哪些操作会造成内存泄漏 内存的生命周期1 分配所需要的内存2 使用分配到的内存进行读写操作3 不需要时将内存进行清除 javascript 的内存分配 变量初始化分配1234567891011var str = &#x27;string&#x27; // 为字符串分配内存var arr = [1, 2] // 为数组及数值分配内存var obj = &#123; // 为对象及承载的数值分配内存 a: 1&#125;function fn(a, b) &#123; // 为可调用的函数变量 fn 对象分配内存 return a + b&#125;el.addEventListener(&#x27;click&#x27;, function() &#123; // 函数表达式, 匿名函数分配内存 el.style.color = &#x27;red&#x27; &#125;) 调用函数分配123var d = new Date(); // 为Date 对象值分配内存var e = document.createElement(&#x27;div&#x27;); // 为 DOM 对象分配内存 javascript 垃圾回收的方法 引用计数 标记清除(常用) 引用计数引用计数垃圾回收算法 123456789101112131415161718192021var o = &#123; a: &#123; b:2 &#125;&#125;; // 两个对象被创建// &#123; b: 2 &#125; 作为一个属性被引用 +1 = 1// &#123; a: &#123; b: 2 &#125; &#125; 被分配给变量 o +1 = 1var o2 = o; // o2变量是第二个对 &#123; a: &#123; b: 2 &#125; &#125; +1 = 2 的引用 o = 1; // 现在，&#123; a: &#123; b: 2 &#125; &#125; 的原始引用o被o2替换了 -1 = 1var oa = o2.a; // 引用 &#123; a: &#123; b: 2 &#125; &#125; + 1 = 2的a属性 &#123; b: 2 &#125; + 1 = 2// 现在，&#123; a: &#123; b: 2 &#125; &#125; 有两个引用了，一个是o2，一个是oao2 = &quot;yo&quot;; // &#123; a: &#123; b: 2 &#125; &#125; = 0 对象的原始引用被清除 // 然而它的属性a的对象还在被oa引用，所以还不能回收oa = null; // a属性 &#123; b: 2 &#125; 现在也是零引用了// &#123; a: &#123; b: 2 &#125; &#125; 它可以被垃圾回收了 循环引用 12345678910function f()&#123; var o = &#123;&#125;; + 1 var o2 = &#123;&#125;; + 1 o.a = o2; // o 引用 o2 + 1 o2.a = o; // o2 引用 o + 1 return &quot;str&quot;;&#125;f()// var o = &#123;&#125;; var o2 = &#123;&#125;; 在栈中运行后该被清除 // o.a, o2.a 都至少引用了一次 o 和 o2 无法被清除 12345678var el;window.onload = function()&#123; el = document.getElementById(&quot;element&quot;); el.circularReference = el; el.lotsOfData = new Array(10000).join(&quot;*&quot;);&#125;;// 当element 元素被删除后应该被回收// el.circularReference 循环引用了 el, 导致对此 dom 元素的引用无法被回收, el.lotsOfData 的数据无法释放 标记清除(常用) 在全局环境或函数环境声明变量时，进入执行环境，\u001d垃圾回收器将其标记为’进入环境’，当变量离开环境、函数执行结束后将其标记为’离开环境’。垃圾收集器会在运行时通过给存储在内存中的所有变量加上标记的方式决定是否应该清除，闭包只有’进入环境’标记。垃圾收集器运行时会对标记为’离开环境’的变量和全局环境无法访问到的对象进行清除。 标记清除的循环引用 123456789// 函数内声明的 o 和 o2 因为在全局环境下无法访问会被清除function f()&#123; var o = &#123;&#125;; + 1 var o2 = &#123;&#125;; + 1 o.a = o2; // o 引用 o2 + 1 o2.a = o; // o2 引用 o + 1 return &quot;str&quot;;&#125;f() 12345678// 当 element 被删除后或手动取消引用时，全局环境 el 变量为null，dom 对象占用的内存则被清除var el;window.onload = function()&#123; el = document.getElementById(&quot;element&quot;); el.circularReference = el; el.lotsOfData = new Array(10000).join(&quot;*&quot;);&#125;;el = null // 全局环境无法访问到el.circularReference 被清除 哪些操作会造成内存泄漏 settimeout的第一个参数使用字符串而非函数的话,会引发内存泄漏。意外的全局变量、闭包、控制台日志、遗留的定时器、在两个对象彼此引用且彼此保留解决方法:函数运行后手动设置 dom 为null， 手动 clear 定时器，避免循环引用。 WeakMapWeakMap 作用 WeakMap WeakSet对于值的引用都是不计入垃圾回收机制的，表示这是弱引用。先新建一个 Weakmap 实例。然后，将一个 DOM 节点作为键名存入该实例，并将一些附加信息作为键值，一起存放在 WeakMap 里面。这时，WeakMap 里面对element的引用就是弱引用，不会被计入垃圾回收机制。当我们想为对象添加数据但是又不想干扰垃圾回收机制就可以使用 123456const wm = new WeakMap();const element = document.getElementById(&#x27;example&#x27;); // 引用计数 + 1wm.set(element, &#x27;some information&#x27;); // 弱引用 - 引用计数不变wm.get(element) // &quot;some information&quot; value 可以为对象 WeakMap 示例当called 大于10后 进行 report 上报 map 对 obj 参数的引用仍然存在，造成了内存泄漏，而我们只是为obj添加了一些额外信息 12345678var map = new Map(); // maps can have object keysfunction useObj(obj)&#123; doSomethingWith(obj); var called = map.get(obj) || 0; called++; // called one more time if(called &gt; 10) report(); // 应该手动清除 map 对 obj 的引用 map.set(obj, called);&#125; 使用WeakMap用于处理为对象添加信息的场景 12345678var map = new WeakMap(); // create a weak mapfunction useObj(obj)&#123; doSomethingWith(obj); var called = map.get(obj) || 0; called++; // called one more time if(called &gt; 10) report(); // 无需清除引用 map.set(obj, called);&#125;","categories":[{"name":"Font-End Basis","slug":"Font-End-Basis","permalink":"http://yoursite.com/categories/Font-End-Basis/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"实现一个 Vue (1) 实现响应式原理","slug":"实现一个 Vue (1) 实现响应式原理","date":"2018-04-11T11:28:09.000Z","updated":"2023-09-12T16:43:30.909Z","comments":true,"path":"2018/04/11/实现一个 Vue (1) 实现响应式原理/","link":"","permalink":"http://yoursite.com/2018/04/11/%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%20Vue%20(1)%20%E5%AE%9E%E7%8E%B0%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86/","excerpt":"","text":"new Vue(options) 创建 Vue 实例 observer() 将处理 options.data1 创建 dep &#x3D; new Dep()(订阅者) 闭包等待依赖收集 watcher(观察者)2 创建 getter 函数等待 options.data 被 getter 后执行依赖收集3 创建 setter 函数等待 options.data 改变时遍历 dep.subs: watcher[] 通知每个 watcher 进行更新 Vue 构造函数 init 执行 compile() compile() 时执行了 observer(options.data) 的 getter 函数进行 dep 对 watcher 的依赖收集 创建实例 &#x2F; 更新数据 方便演示为 options.data 定义 testA testB 待响应数据 创建实例执行 Vue 按顺序执行 observer 更新 testA testB 响应数据通过 setter -&gt; dep.subs -&gt; watcher -&gt; update 更新 123456789101112// vm.jslet vm = new Vue(&#123; // 实例初始化 el: &#x27;#app&#x27;, data: &#123; testA: &#x27;i am testA&#x27;, testB: &#x27;i am testB&#x27;, &#125;,&#125;)// 对观察者数据更新vm._data.testA = &#x27;testA change&#x27;vm._data.testB = &#x27;testB change&#x27; Dep 订阅者依赖收集 var dep &#x3D; new Dep() 创建一个订阅者 subs 为 watcher[] 类型的数组 dep.notify 会通知每个 watcher 进行更新 1234567891011121314151617// dep.jsexport default class Dep &#123; constructor() &#123; this.subs = [] &#125; addSub(sub) &#123; this.subs.push(sub) console.log(this.subs) &#125; notify() &#123; this.subs.forEach(sub =&gt; &#123; sub.update() &#125;) &#125;&#125; Watcher 观察者 被用来收集 new Watcher 时 给 Dep.target 指向为一个 watcher 实例对象 为 dep.subs addSub 时只需要增加 Dep.target update 为响应数据更新时的需处理的逻辑 123456789101112// watcher.jsimport Dep from &#x27;./dep&#x27;export default class Wathcher &#123; constructor() &#123; Dep.target = this &#125; update() &#123; console.log(&#x27;wathcher updating!&#x27;) &#125;&#125; 实现 observer1234567891011121314151617181920212223242526272829303132// observer.jsimport Dep from &#x27;./dep.js&#x27;export function observer(data) &#123; if (!data || typeof data !== &#x27;object&#x27;) &#123; return &#125; Object.keys(data).forEach(key =&gt; &#123; defineReactive(data, key, data[key]) &#125;) Dep.target = null // Watcher 添加完毕&#125;function defineReactive(data, key, val) &#123; observer(val) // 对子属性进行绑定 const dep = new Dep() // 创建一个订阅者 Object.defineProperty(data, key, &#123; enumerable: true, configurable: true, get: function proxyGetter() &#123; // view 层绑定几次 addSub 注册几个 Watcher 绑定完了Dep.target = null 继续绑定注册下个数据 Dep.target &amp;&amp; dep.addSub(Dep.target) return val &#125;, set: function proxySetter(newVal) &#123; if (val === newVal) return val = newVal dep.notify() // 响应数据更新后此数据的 dep 订阅者通知所有 watcher 观察对象 &#125; &#125;)&#125; mvvm Vue 构造函数的 compile 为 view 层绑定数据逻辑 compile 会触发响应数据的 getter 1234567891011121314151617181920212223242526// mvvm.jsimport Watcher from &#x27;./watcher&#x27;import &#123; observer &#125; from &#x27;./observer&#x27;export default class Vue &#123; constructor(options) &#123; this._data = options.data observer(this._data) new Watcher() this._init() &#125; _init() &#123; this._compile(this._data) &#125; _compile(data) &#123; // 每次 log 模拟绑定一次视图， 触发一次响应数据的 getter console.log(&#x27;view 层绑定&#x27;, data.testA) console.log(&#x27;view 层绑定&#x27;, data.testA) console.log(&#x27;view 层绑定&#x27;, data.testA) console.log(&#x27;view 层绑定&#x27;, data.testB) console.log(&#x27;view 层绑定&#x27;, data.testB) &#125;&#125;","categories":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/tags/Vue/"}]},{"title":"学习并实现 redux(1) - 基础 API","slug":"学习并实现 redux(1) - 基础 API","date":"2018-04-03T13:50:27.000Z","updated":"2023-09-12T16:43:48.556Z","comments":true,"path":"2018/04/03/学习并实现 redux(1) - 基础 API/","link":"","permalink":"http://yoursite.com/2018/04/03/%E5%AD%A6%E4%B9%A0%E5%B9%B6%E5%AE%9E%E7%8E%B0%20redux(1)%20-%20%E5%9F%BA%E7%A1%80%20API/","excerpt":"","text":"redux 基础 API createStore 创建 store (对外直接暴露 createStore(reducer)) getState 获取 store 当前 state，(store.getState()) subscribe 注册监听器函数(listener)，(store.subscribe(listener)) dispatch 触发 action，(store.dispatch({ type: ‘actionType’ })) reducer &#x2F; listener &#x2F; action reducer 由createStore(reducer) 创建store，\b用来被 store.dispatch({ type: ‘TYPE’ })命中更改 state\b 12345678910111213// reducerfunction counter(state = 0, action) &#123; console.log(state, action) // log 每次action switch (action.type) &#123; case &#x27;ADD&#x27;: return state + 1 case &#x27;SUB&#x27;: return state - 1 default: return 10 // &#123; type: @@redux/INIT &#125; 命中 &#125;&#125; listener 由store.subscribe(listener) 注册监听函数，每次 action 时都会执行 action 由store.dispatch(action) 触发通知 reducer 命中后更改store 的state redux 应用流程图 根据流程图实现 redux12345678910111213141516171819202122// redux.jsexport function createStore(reducer) &#123; let currentState = &#123;&#125; // state let currentListeners = [] // 监听器 function getState() &#123; // store.getState() 获取 state return currentState &#125; function subscribe(listener) &#123; // store.subscribe(listener) 注册listener currentListeners.push(listener) &#125; function dispatch(action) &#123; currentState = reducer(currentState, action) // 更改 state currentListeners.forEach(v =&gt; v()) // 执行listeners return action // 返回action &#125; dispatch(&#123; type: &#x27;@@redux/INIT&#x27; &#125;) // store 初始化时命中 reducer default return &#123; getState, subscribe, dispatch &#125; // 暴露store API&#125; 定义 reducer 创建 store 1234567891011121314151617181920import &#123; createStore &#125; from &#x27;./redux&#x27;// reducerfunction counter(/*initState*/state = 0, action) &#123; console.log(state, action) // log 每次action switch (action.type) &#123; case &#x27;ADD&#x27;: return state + 1 case &#x27;SUB&#x27;: return state - 1 default: return 10 // &#123; type: @@redux/INIT &#125; 命中 &#125;&#125;// storeconst store = createStore(counter)const init = store.getState()console.log(&#x27;initCount:&#x27; + init) 注册listener 123456// listenerfunction listener() &#123; const current = store.getState() console.log(&#x27;listener - currentCount:&#x27; + current)&#125;store.subscribe(listener) 执行 store.dispatch 命中reducer 123456789// actionconst ADD = &#x27;ADD&#x27;const SUB = &#x27;SUB&#x27;store.dispatch(&#123; type: ADD &#125;)store.dispatch(&#123; type: ADD &#125;)store.dispatch(&#123; type: SUB &#125;)store.dispatch(&#123; type: ADD &#125;)store.dispatch(&#123; type: SUB &#125;) 控制台输出","categories":[{"name":"React","slug":"React","permalink":"http://yoursite.com/categories/React/"}],"tags":[{"name":"Redux","slug":"Redux","permalink":"http://yoursite.com/tags/Redux/"}]},{"title":"React Tips 依赖注入、全局包裹Context","slug":"React Tips: 依赖注入、全局包裹Context","date":"2018-03-23T09:34:37.000Z","updated":"2018-03-23T09:36:12.000Z","comments":true,"path":"2018/03/23/React Tips: 依赖注入、全局包裹Context/","link":"","permalink":"http://yoursite.com/2018/03/23/React%20Tips:%20%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E3%80%81%E5%85%A8%E5%B1%80%E5%8C%85%E8%A3%B9Context/","excerpt":"","text":"依赖注入props 传递 props 层层传递 很多组件并不需要使用 props 不推荐 1234// Title.jsxexport default function Title(props) &#123; return &lt;h1&gt;&#123; props.title &#125;&lt;/h1&gt;;&#125; 123456789// Header.jsximport Title from &#x27;./Title.jsx&#x27;;export default function Header() &#123; return ( &lt;header&gt; &lt;Title /&gt; &lt;/header&gt; );&#125; 1234567891011// App.jsximport Header from &#x27;./Header.jsx&#x27;;class App extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; title: &#x27;React Dependency Injection&#x27; &#125;; &#125; render() &#123; return &lt;Header /&gt;; &#125;&#125; HOC 高阶组件123456// title.jsximport React from &#x27;react&#x27;export default function Title(props) &#123; return &lt;h1&gt;&#123; props.title &#125;&lt;/h1&gt;&#125; 1234567891011121314151617// inject.jsximport React from &#x27;react&#x27;export default function inject(Component) &#123; return class Injector extends React.Component &#123; render() &#123; const &#123; title &#125; = this.props return ( &lt;Component &#123;...this.state&#125; &#123;...this.props&#125; &#123;...this.children&#125; title=&#123; title &#125; /&gt; ) &#125; &#125;&#125; 123456789101112131415// header.jsximport React from &#x27;react&#x27;import inject from &#x27;./inject&#x27;import Title from &#x27;./title&#x27;const title = &#x27;React Dependency Injection&#x27;const EnhancedTitle = inject(Title)export default function Header() &#123; return ( &lt;header&gt; &lt;EnhancedTitle title=&#123;title&#125; /&gt; &lt;/header&gt; )&#125; 新版 Context API123456789101112131415161718// title.jsximport React from &#x27;react&#x27;import &#123; InjectContext &#125; from &#x27;./inject&#x27;export default class Title extends React.Component &#123; render() &#123; return ( &lt;InjectContext.Consumer&gt; &#123;context =&gt; ( &lt;div&gt; &#123;console.log(context)&#125; &lt;h1&gt;&#123;context.title&#125;&lt;/h1&gt; &lt;/div&gt; )&#125; &lt;/InjectContext.Consumer&gt; ) &#125;&#125; 123// inject.jsximport React from &#x27;react&#x27;export const InjectContext = React.createContext(&#123;&#125;) 12345678// header.jsximport React from &#x27;react&#x27;import Title from &#x27;./title&#x27;export default class Header extends React.Component &#123; render() &#123; return &lt;Title /&gt; &#125;&#125; 12345678910111213141516// App.jsimport React, &#123; Component &#125; from &#x27;react&#x27;;import Header from &#x27;./header&#x27;import &#123; InjectContext &#125; from &#x27;./inject&#x27;class App extends Component &#123; render() &#123; return ( &lt;InjectContext.Provider value=&#123;&#123; title: &#x27;React Dependency Injection&#x27; &#125;&#125;&gt; &lt;Header /&gt; &lt;/InjectContext.Provider&gt; ); &#125;&#125;export default App; 全局包裹Context新版Context API 实现 相比于单纯的数据对象，将context包装成一个提供一些方法的对象会是更好的实践。因为这样能提供一些方法供我们操作context里面的数据。 12345678910// dependcies.jsexport default &#123; data: &#123;&#125;, get(key) &#123; return this.data[key]; &#125;, register(key, value) &#123; this.data[key] = value; &#125;&#125; 1234567891011// header.jsximport React from &#x27;react&#x27;import Title from &#x27;./title.jsx&#x27;export default function Header() &#123; return ( &lt;header&gt; &lt;Title /&gt; &lt;/header&gt; )&#125; 1234// inject.jsimport React from &#x27;react&#x27;export const InjectContext = React.createContext(&#123;&#125;) 创建dependcies后可以用dependencies.register 注册数据 12345678910111213141516171819// App.jsimport React, &#123; Component &#125; from &#x27;react&#x27;;import dependencies from &#x27;./dependencies&#x27;import Header from &#x27;./header&#x27;import &#123; InjectContext &#125; from &#x27;./inject&#x27;dependencies.register(&#x27;title&#x27;, &#x27;context-react-patterns&#x27;)class App extends Component &#123; render() &#123; return ( &lt;InjectContext.Provider value=&#123;dependencies&#125;&gt; &lt;Header /&gt; &lt;/InjectContext.Provider&gt; ) &#125;&#125;export default App; 然后在 Title 组件中直接从 Context 获取数据 12345678910111213141516import React from &#x27;react&#x27;import &#123; InjectContext &#125; from &#x27;./inject&#x27;export default class Title extends React.Component &#123; render() &#123; return ( &lt;InjectContext.Consumer&gt; &#123;context =&gt; ( &lt;div&gt; &lt;h1&gt;&#123;context.get(&#x27;title&#x27;)&#125;&lt;/h1&gt; &lt;/div&gt; )&#125; &lt;/InjectContext.Consumer&gt; ) &#125;&#125; 高阶组件 HOC 实现123456789101112131415161718192021222324252627282930313233// dependencies.jsximport React from &#x27;react&#x27;let dependencies = &#123;&#125;export function register(key, dependency) &#123; dependencies[key] = dependency&#125;export function fetch(key) &#123; if (dependencies.hasOwnProperty(key)) return dependencies[key] throw new Error(`&quot;$&#123; key &#125; is not registered as dependency.`)&#125;export function wire(Component, deps, mapper) &#123; return class Injector extends React.Component &#123; constructor(props) &#123; super(props) this._resolvedDependencies = mapper(...deps.map(fetch)) &#125; render() &#123; return ( &lt;Component &#123;...this.state&#125; &#123;...this.props&#125; &#123;...this._resolvedDependencies&#125; // &#123;title: &quot;react-patterns&quot;&#125; /&gt; ) &#125; &#125;&#125; 在App 组件中使用register 注册数据 123456789101112131415// App.jsimport React, &#123; Component &#125; from &#x27;react&#x27;;import Header from &#x27;./header&#x27;import &#123; register &#125; from &#x27;./dependencies&#x27;register(&#x27;awesome-title&#x27;, &#x27;HOC-react-patterns&#x27;)class App extends Component &#123; render() &#123; return &lt;Header /&gt; &#125;&#125;export default App; 1234567891011// header.jsximport React from &#x27;react&#x27;import Title from &#x27;./title.jsx&#x27;export default function Header() &#123; return ( &lt;header&gt; &lt;Title /&gt; &lt;/header&gt; )&#125; 在 Title 组件中通过 wire 注入数据 1234567// title.jsximport React from &#x27;react&#x27;import &#123; wire &#125; from &#x27;./dependencies&#x27;const Title = props =&gt; (&lt;h1&gt;&#123; props.title &#125;&lt;/h1&gt;)export default wire(Title, [&#x27;awesome-title&#x27;], title =&gt; (&#123; title &#125;))","categories":[{"name":"React","slug":"React","permalink":"http://yoursite.com/categories/React/"}],"tags":[{"name":"React Tips","slug":"React-Tips","permalink":"http://yoursite.com/tags/React-Tips/"}]},{"title":"React Tips  JSX条件语句、setState 异步特性","slug":"React Tips  JSX条件语句、setState 异步特性","date":"2018-03-22T10:51:29.000Z","updated":"2018-03-22T10:52:59.000Z","comments":true,"path":"2018/03/22/React Tips  JSX条件语句、setState 异步特性/","link":"","permalink":"http://yoursite.com/2018/03/22/React%20Tips%20%20JSX%E6%9D%A1%E4%BB%B6%E8%AF%AD%E5%8F%A5%E3%80%81setState%20%E5%BC%82%E6%AD%A5%E7%89%B9%E6%80%A7/","excerpt":"","text":"JSX 条件语句三元表达式1234567891011const Test = function(props) &#123; const &#123; flag1, flag2 &#125; = props return ( &lt;div&gt; &#123;flag1 &amp;&amp; flag2 ? &lt;h1&gt;11111&lt;/h1&gt; : &lt;h1&gt;22222&lt;/h1&gt; &#125; &lt;/div&gt; )&#125; 立即执行函数12345678910111213141516const Test = function(props) &#123; const &#123; flag1, flag2 &#125; = props return ( &lt;div&gt; &#123; (() =&gt; &#123; if (flag1 &amp;&amp; flag2) &#123; return &lt;h1&gt;11111&lt;/h1&gt; &#125; else &#123; return &lt;h1&gt;22222&lt;/h1&gt; &#125; &#125;)() &#125; &lt;/div&gt; )&#125; 条件语句1234567const Test = function(props) &#123; const &#123; flag1, flag2 &#125; = props const condition = flag1 &amp;&amp; flag2 if (condition) return &lt;h1&gt;111111&lt;/h1&gt; if (!condition) return &lt;h1&gt;222222&lt;/h1&gt; return &lt;h1&gt;333333&lt;/h1&gt;&#125; do 表达式(stage0新提案)12345678910111213141516const Test = function(props) &#123; const &#123; flag1, flag2 &#125; = props return ( &lt;div&gt; &#123; do &#123; if (flag1 &amp;&amp; flag2) &#123; &lt;h1&gt;11111&lt;/h1&gt; &#125; else &#123; &lt;h1&gt;22222&lt;/h1&gt; &#125; &#125; &#125; &lt;/div&gt; )&#125; setState() 异步 setState 时 函数会创建一个暂态的state作为过渡state，而不是立即修改this.state。 如果在调用setState()函数之后尝试去访问this.state，你得到的可能还是setState()函数执行之前的结果。 setState 在执行多次state 更新时会合并成一次更新，这时setState 会显示为异步函数 而有些浏览器 API 会造成 state 更新同步化 addEventListener setTimeout fetch 等 当setState() 函数执行的时候，函数会创建一个暂态的state作为过渡state，而不是立即修改this.state。 如果在调用setState()函数之后尝试去访问this.state，你得到的可能还是setState()函数执行之前的结果。 123456789101112131415161718192021222324252627class TestComponent extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; count: 0 &#125; &#125; componentDidMount() &#123; this.setState(&#123;count: this.state.count + 1&#125;) console.log(this.state.count) // 0 state 更新为异步 this.setState(&#123;count: this.state.count + 1&#125;) console.log(this.state.count) // 0 state 更新为异步 setTimeout(() =&gt; &#123; console.log(this.state.count) // 1 state 更新异步被合并, 只更新了一次 this.setState(&#123;count: this.state.count + 1&#125;) console.log(this.state.count) // 2 state 更新同步化 this.setState(&#123;count: this.state.count + 1&#125;) console.log(this.state.count) // 3 state 更新同步化 &#125;) &#125;&#125; 当和addEventListener, setTimeout 函数或者发出ajax call的时候，调用setState, state会发生改变。并且render函数会在setState()函数被触发之后马上被调用。 addEventListener setTimeout ajax call 在事件循环里都只是属于浏览器层面的 API ，这些 API 的回调函数将会在浏览器资源里执行完成再进入队列最后通过事件循环进入 script 里执行。 浏览器层面的API 的上下文环境已经不属于 React 中了，React 无法控制这些这些回调函数，无法合并他们导致的state 更新, 于是使用同步化策略及时更新，确保在这些函数执行之后的其他代码能拿到正确的数据 而在 JSX 中通过props 绑定 onClick 的事件则仍然是在 React 上下文中，React 仍然可以控制这类事件回调函数 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071class TestComponent extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; count: 0 &#125; &#125; componentDidMount() &#123; document.getElementById(&#x27;button1&#x27;).addEventListener(&#x27;click&#x27;, this.onClickHandler1); setTimeout(this.onTimeoutHandler, 10000); fetch(&#x27;https://api.github.com/users&#x27;) .then(this.onAjaxCallback); &#125; onClickHandler1 = () =&gt; &#123; console.log(&#x27;State before (onClickHandler1): &#x27; + JSON.stringify(this.state)); this.setState(&#123; count: this.state.count + 1 &#125;); console.log(&#x27;State after (onClickHandler1): &#x27; + JSON.stringify(this.state)); &#125; onClickHandler2 = () =&gt; &#123; console.log(&#x27;State before (onClickHandler2): &#x27; + JSON.stringify(this.state)); this.setState(&#123; count: this.state.count + 2 &#125;); console.log(&#x27;State after (onClickHandler2): &#x27; + JSON.stringify(this.state)); &#125; onTimeoutHandler = () =&gt; &#123; console.log(&#x27;State before (timeout): &#x27; + JSON.stringify(this.state)); this.setState(&#123; count: this.state.count + 3 &#125;); console.log(&#x27;State after (timeout): &#x27; + JSON.stringify(this.state)); &#125; onAjaxCallback = (err, res) =&gt; &#123; console.log(&#x27;State before (AJAX call): &#x27; + JSON.stringify(this.state)); this.setState(&#123; count: this.state.count + 4 &#125;); console.log(&#x27;State after (AJAX call): &#x27; + JSON.stringify(this.state)); &#125; render() &#123; console.log(&#x27;State in render: &#x27; + JSON.stringify(this.state)); return ( &lt;div&gt; &lt;button id=&quot;button1&quot; &gt; &#x27;addEventListener&#x27; &lt;/button&gt; &lt;button id=&quot;button2&quot; onClick=&#123;this.onClickHandler2&#125;&gt; &#x27;props bind in jsx&#x27; &lt;/button&gt; &lt;/div&gt; ); &#125;&#125;","categories":[{"name":"React","slug":"React","permalink":"http://yoursite.com/categories/React/"}],"tags":[{"name":"React Tips","slug":"React-Tips","permalink":"http://yoursite.com/tags/React-Tips/"}]},{"title":"学习并实现react4","slug":"学习并实现react4","date":"2018-03-16T08:30:41.000Z","updated":"2023-09-12T16:43:33.740Z","comments":true,"path":"2018/03/16/学习并实现react4/","link":"","permalink":"http://yoursite.com/2018/03/16/%E5%AD%A6%E4%B9%A0%E5%B9%B6%E5%AE%9E%E7%8E%B0react4/","excerpt":"","text":"实现生命周期生命周期介绍1234567componentWillMount // 组件挂载前componentDidMount // 组件挂载后componentWillReceiveProps // 组件props 变化时shouldComponentUpdate // (props / state) 变化时componentWillUpdate // 组件更新前componentDidUpdate // 组件更新后componentWillUnmount // 组件即将销毁 React 生命周期图 React 子组件在父组件下的生命周期流程 实现 componentWillMount, componentDidMount, componentDidUpdatecomponentWillMount在组件实例新建时执行 componentDidMount、componentDidUpdate相同点：组件render 执行完成后执行的不同点：新建的实例render 后执行componentDidMount， 已创建的实例组件再次render 则调用componentDidUpdate 12345678910111213141516171819202122232425262728function render(vnode, parent, comp, olddomOrComp, myIndex) &#123; ... if (typeof vnode.type === &#x27;function&#x27;) &#123; let func = vnode.type let inst if (olddomOrComp &amp;&amp; olddomOrComp instanceof func) &#123; inst = olddomOrComp inst.props = vnode.props &#125; else &#123; inst = new func(vnode.props) // 新建组件实例执行 componentWillMount inst.componentWillMount &amp;&amp; inst.componentWillMount.call() if (comp) comp.__rendered = inst else parent.__rendered[myIndex] = inst // dom 渲染 &#125; let innerVNode = inst.render() render(innerVNode, parent, inst, inst.__rendered, myIndex) // render 后进行判断调用 componentDidUpdate componentDidMount if (olddomOrComp &amp;&amp; olddomOrComp instanceof func) &#123; inst.componentDidUpdate &amp;&amp; inst.componentDidUpdate.call() &#125; else &#123; inst.componentDidMount &amp;&amp; inst.componentDidMount.call() &#125; &#125;&#125; 实现 componentWillReceiveProps， shouldComponentUpdate， componentWillUpdatecomponentWillReceiveProps1234componentWillReceiveProps(nextProps) &#123; console.log(nextProps) // 变化后的 props console.log(this.props) // 变化前的 props&#125; componentWillReceiveProps 具有一个 nextProps 参数，表示改变后的新props，而在componentWillReceiveProps 内执行的 this.props 还是指向未改变的 oldProps 1234567891011121314151617181920212223242526if (typeof vnode.type === &#x27;function&#x27;) &#123; let func = vnode.type let inst if (olddomOrComp &amp;&amp; olddomOrComp instanceof func) &#123; inst = olddomOrComp // 父组件改变时 inst.props 改变前 调用 componentWillReceiveProps inst.componentWillReceiveProps &amp;&amp; inst.componentWillReceiveProps(vnode.props) inst.props = vnode.props &#125; else &#123; inst = new func(vnode.props) inst.componentWillMount &amp;&amp; inst.componentWillMount.call() if (comp) comp.__rendered = inst else parent.__rendered[myIndex] = inst // dom 渲染 &#125; let innerVNode = inst.render() render(innerVNode, parent, inst, inst.__rendered, myIndex) if (olddomOrComp &amp;&amp; olddomOrComp instanceof func) &#123; inst.componentDidUpdate &amp;&amp; inst.componentDidUpdate.call() &#125; else &#123; inst.componentDidMount &amp;&amp; inst.componentDidMount.call() &#125;&#125; shouldComponentUpdate &#x2F; componentWillUpdate1234shouldComponentUpdate(nextProps, nextState) &#123; return boolean&#125;componentWillUpdate(nextProps, nextState) &#123;&#125; 组件setState 或props 后决定组件是否更新，返回一个 true 或 false 通知组件是否执行 componentWillUpdate - render - componentDidUpdate, 组件不存在shouldComponentUpdate 则直接更新 componentWillUpdate 只有当shouldComponentUpdate 返回值是true 时才会调用 12345678910111213141516171819202122232425262728293031323334353637// render.js 父组件props 改变时 if (typeof vnode.type === &#x27;function&#x27;) &#123; let func = vnode.type let inst if (olddomOrComp &amp;&amp; olddomOrComp instanceof func) &#123; inst = olddomOrComp inst.componentWillReceiveProps &amp;&amp; inst.componentWillReceiveProps(vnode.props) let shouldUpdate // ture or false if (inst.shouldComponentUpdate) &#123; shouldUpdate = inst.shouldComponentUpdate(vnode.props, olddomOrComp.state) // 进行比较 &#125; else &#123; // 组件实例不存在shouldComponentUpdate 为true shouldUpdate = true &#125; // 这里调用componentWillUpdate shoudUpdate &amp;&amp; inst.componentWillUpdate &amp;&amp; inst.componentWillUpdate(inst.props, olddomOrComp.state) inst.props = vnode.props if (!shouldUpdate) return // 无需更新时阻止组件 render &#125; else &#123; inst = new func(vnode.props) inst.componentWillMount &amp;&amp; inst.componentWillMount.call() if (comp) comp.__rendered = inst else parent.__rendered[myIndex] = inst // dom 渲染 &#125; let innerVNode = inst.render() render(innerVNode, parent, inst, inst.__rendered, myIndex) if (olddomOrComp &amp;&amp; olddomOrComp instanceof func) &#123; inst.componentDidUpdate &amp;&amp; inst.componentDidUpdate.call() &#125; else &#123; inst.componentDidMount &amp;&amp; inst.componentDidMount.call() &#125; &#125; 123456789101112131415161718192021222324// component.js 当组件本身调用 setStateclass Component &#123; constructor(props) &#123; this.props = props &#125; setState(state) &#123; setTimeout(() =&gt; &#123; let shouldUpdate if (this.shouldComponentUpdate) &#123; // state 改变时 shouldUpdate = this.shouldComonentUpdate(this.props, state) &#125; else shouldUpdate = true this.state = state if (!shouldUpdate) return // 判断是否组织render const vnode = this.render() let olddom = getDOM(this) // 获取渲染此实例的 olddom const myIndex = getDOMIndex(olddom) render(vnode, olddom.parentNode, this.__rendered, myIndex) this.componentDidUpdate &amp;&amp; this.componentDidUpdate.call() // 最后执行componentDidUpdate &#125;, 0) &#125;&#125; componentWillUnmountcomponentWillUnmount 调用的场景1组件实例销毁时2组件实例不被复用时3包裹组件的dom 不被复用时 &lt;div&gt;&lt;Comp /&gt;&lt;/div&gt; 12345678function recoveryComp(comp) &#123; if (comp instanceof Component) &#123; comp.componentWillUnmount &amp;&amp; comp.componentWillUnmount.call() recoveryComp(comp.__rendered) &#125; else if (comp.__rendered instanceof Array) &#123; // 包裹的dom，&lt;div&gt; / &lt;span&gt; comp.__rendered.forEach(el =&gt; recoveryComp(el)) &#125; else return // 文本节点&#125; recoveryComp 对传入的参数进行判断 当为组件实例时调用 componentWillUnmount 然后递归调用 comp.__rendered 当comp.__rendered 为数组时comp 为dom 节点，对__rendered 里的各元素进行 recoveryComp(el) 最后如果是文本节点则不操作 12345678910111213141516171819202122function diffDOM(vnode, parent, comp, olddom) &#123; const &#123; onlyInLeft, onlyInRight, bothIn &#125; = diffObject(vnode.props, olddom.__vnode.props) setAttrs(olddom, onlyInLeft) // 添加新属性 removeAttrs(olddom, onlyInRight) // 删除旧属性 diffAttrs(olddom, bothIn) // 比较且更新新旧属性的不同 const willRemoveArr = olddom.__rendered.slice(vnode.children.length) // 将要删除的 dom const renderedArr = olddom.__rendered.slice(0, vnode.children.length) olddom.__rendered = renderedArr for (let i = 0; i &lt; vnode.children.length; i++) &#123; // 顺序固定，有缺点，原来是replaceChild，现在对dom 或 text 节点进行重新render _render(vnode.children[i], olddom, null, renderedArr[i], i) &#125; willRemoveArr.forEach(el =&gt; &#123; recoveryComp(el) // 当组件不被复用时进行 调用recoveryComp olddom.removeChild(getDOM(el)) &#125;) olddom.__vnode = vnode // 不忘重新标记&#125; 现在我们把生命周期都加入了。 首次挂载到根节点时 12// document.getElementById(&#x27;app&#x27;) dom 节点也需要初始化__rendered 和 myIndexrender(&lt;App /&gt;, document.getElementById(&#x27;app&#x27;)) 12345678export function render(vnode, parent) &#123; parent.__rendered = [] // 为 document.getElementById(&#x27;root&#x27;) 初始化__rendered _render(vnode, parent, null, null, 0)&#125;function _render(vnode, parent, comp, olddomOrComp, myIndex) &#123; ...&#125;","categories":[{"name":"React","slug":"React","permalink":"http://yoursite.com/categories/React/"}],"tags":[{"name":"React","slug":"React","permalink":"http://yoursite.com/tags/React/"}]},{"title":"学习并实现react3","slug":"学习并实现react3","date":"2018-03-15T14:36:00.000Z","updated":"2023-09-12T16:43:38.477Z","comments":true,"path":"2018/03/15/学习并实现react3/","link":"","permalink":"http://yoursite.com/2018/03/15/%E5%AD%A6%E4%B9%A0%E5%B9%B6%E5%AE%9E%E7%8E%B0react3/","excerpt":"","text":"复用组件React 组件书写规则 组件可以直接渲染组件 组件渲染多个children 时需要用 dom 元素进行包裹 123456789101112131415161718192021222324252627class Parent extends Component &#123; render() &#123; return &lt;Child /&gt; &#125;&#125;class Child extends Component &#123; render() &#123; return ( &lt;div&gt; &lt;SubChild /&gt; &lt;SubChild /&gt; &lt;SubChild /&gt; &lt;/div&gt; ) &#125;&#125;class SubChild extends Component &#123; render() &#123; return ( &lt;div&gt; &lt;span&gt;SubChild&lt;/span&gt; &lt;/div&gt; ) &#125;&#125; 组件复用策略 每个组件渲染时都增加 __rendered 确定渲染元素的标记 对于渲染多个组件(children)时 children 为数组，__rendered 标记每个children 元素 __rendered 标记组件或dom 组件渲染树绝对不会出现下列情况 渲染多个组件(children)时 必须用 dom 元素包裹 最后正确渲染后的Tree 改造render 为了复用组件 render 第四个参数由 olddom 改为 olddomOrComp 12345678910111213141516171819202122232425262728293031function render(vnode, parent, comp, olddomOrComp) &#123; let dom if (typeof vnode === &#x27;string&#x27; || typeof vnode === &#x27;number&#x27;) &#123; // 文本节点直接渲染 if (olddomOrComp &amp;&amp; olddomOrComp.nodeType === 3) &#123; // 是一个文本节点 if (olddomOrComp.nodeValue !== vnode) olddomOrComp.nodeValue = vnode &#125; else &#123; dom = document.createTextNode(vnode) if (olddomOrComp) parent.replaceChild(dom, olddomOrComp) else parent.appendChild(dom) &#125; &#125; if (typeof vnode.type === &#x27;string&#x27;) &#123; // dom 节点 if (!olddomOrComp || olddomOrComp.nodeName !== vnode.type.toUpperCase()) &#123; createNewDom(vnode, parent, comp, olddomOrComp) &#125; else &#123; diffDOM(vnode, olddomOrComp) &#125; &#125; if (typeof vnode.type === &#x27;function&#x27;) &#123; let func = vnode.type let inst = new func(vnode.props) comp &amp;&amp; (comp.__rendered = inst) let innerVNode = inst.render() render(innerVNode, parent, inst, inst.__rendered) // 比较是否复用组件 &#125;&#125; 修改前olddom 参数可以判断是否复用，也可以判断replace(newdom, olddom) 的替换位置 当&lt;Parent /&gt; __rendered = &lt;Child1 /&gt; – setState变成 – &lt;Parent /&gt; __rendered = &lt;Child2 /&gt;, 而&lt;Child2 /&gt; 这个组件实例的inst.__rendered 应该是 undefined 原逻辑中 olddom 不存在时进行 appendChild 存在则进行replacechild 现在olddomOrComp 在替换组件时为 undefined 只会操作appendChild\b 为 render 函数增加第五个参数 myIndex 标识 dom 的位置 12345678function setNewDom(parent, newDom, myIndex) &#123; const old = parent.childNodes[myIndex] if (old) &#123; parent.replaceChild(newDom, old) &#125; else &#123; parent.appendChild(newDom) &#125;&#125; 123456789101112131415161718192021222324252627282930function render(vnode, parent, comp, olddomOrComp, myIndex) &#123; let dom if (typeof vnode === &#x27;string&#x27; || typeof vnode === &#x27;number&#x27;) &#123; // 文本节点直接渲染 if (olddomOrComp &amp;&amp; olddomOrComp.nodeType === 3) &#123; // 是一个文本节点 if (olddomOrComp.nodeValue !== vnode) olddomOrComp.nodeValue = vnode &#125; else &#123; dom = document.createTextNode(vnode) setNewDom(parent, dom, myIndex) // &#125; &#125; if (typeof vnode.type === &#x27;string&#x27;) &#123; // dom 节点 if (!olddomOrComp || olddomOrComp.nodeName !== vnode.type.toUpperCase()) &#123; createNewDom(vnode, parent, comp, olddomOrComp, myIndex) &#125; else &#123; diffDOM(vnode, parent, comp, olddomOrComp, myIndex) &#125; &#125; if (typeof vnode.type === &#x27;function&#x27;) &#123; let func = vnode.type let inst = new func(vnode.props) comp &amp;&amp; (comp.__rendered = inst) let innerVNode = inst.render() render(innerVNode, parent, inst, inst.__rendered, myIndex) &#125;&#125; 123456789101112131415161718192021function createNewDom(vnode, parent, comp, olddomOrComp, myIndex) &#123; ... setAttrs(dom, vnode.props) setNewDom(parent, dom, myIndex) // 创建时根据myIndex 决定是append / replace for(let i = 0; i &lt; vnode.children.length; i++) &#123; render(vnode.children[i], dom, null, null, i) // myIndex 其实就是 children 的 i &#125;&#125;function diffDOM(vnode, parent, comp, olddom) &#123; ... const willRemoveArr = olddom.__rendered.slice(vnode.children.length) // 将要删除的 dom const renderedArr = olddom.__rendered.slice(0, vnode.children.length) olddom.__rendered = renderedArr for(let i = 0; i &lt; vnode.children.length; i++) &#123; render(vnode.children[i], olddom, null, renderedArr[i], i) // 同样要增加 children 的 i &#125; ...&#125; 实现 __rendered 链123456789101112// __rendered 链场景class Child extends Component &#123; render() &#123; return ( &lt;div&gt; // 此处dom，__rendered 在这里应该为数组 &lt;SubChild 1/&gt; &lt;SubChild 2/&gt; &lt;SubChild 3/&gt; &lt;/div&gt; ) &#125;&#125; 现在 __rendered 标识组件实例后再标识到 dom 节点就结束了。 现在需要实现 div.__rendered 关联 SubChild 组件 确定__rendered 链的思想，当渲染的是dom 元素时(组件被根dom包裹), __rendered 为数组 1234567891011121314151617181920212223242526272829303132333435363738function render(vnode, parent, comp, olddomOrComp, myIndex) &#123; let dom if (typeof vnode === &#x27;string&#x27; || typeof vnode === &#x27;number&#x27;) &#123; // 文本节点直接渲染 if (olddomOrComp &amp;&amp; olddomOrComp.nodeType === 3) &#123; // 是一个文本节点 if (olddomOrComp.nodeValue !== vnode) olddomOrComp.nodeValue = vnode &#125; else &#123; dom = document.createTextNode(vnode) parent.__rendered[myIndex] = dom // comp 为 null 组件实例不会渲染文本节点 setNewDom(parent, dom, myIndex) &#125; &#125; if (typeof vnode.type === &#x27;string&#x27;) &#123; // dom 节点 if (!olddomOrComp || olddomOrComp.nodeName !== vnode.type.toUpperCase()) &#123; createNewDom(vnode, parent, comp, olddomOrComp, myIndex) &#125; else &#123; diffDOM(vnode, parent, comp, olddomOrComp) &#125; &#125; if (typeof vnode.type === &#x27;function&#x27;) &#123; let func = vnode.type let inst if (olddomOrComp &amp;&amp; olddomOrComp instanceof func) &#123; inst = olddomOrComp inst.props = vnode.props &#125; else &#123; inst = new func(vnode.props) if (comp) comp.__rendered = inst else parent.__rendered[myIndex] = inst // dom 渲染 &#125; let innerVNode = inst.render() render(innerVNode, parent, inst, inst.__rendered, myIndex) &#125;&#125; 1234567891011121314151617181920212223function setNewDom(parent, newDom, myIndex) &#123; const old = parent.childNodes[myIndex] if (old) parent.replaceChild(newDom, old) else parent.appendChild(newDom)&#125;function createNewDom(vnode, parent, comp, olddomOrComp, myIndex) &#123; let dom = document.createElement(vnode.type) dom.__rendered = [] // 创建dom 时 初始的 __rendered 未数组 dom.__vnode = vnode if (comp) comp.__rendered = dom else parent.__rendered[myIndex] = dom setAttrs(dom, vnode.props) setNewDom(parent, dom, myIndex) for (let i = 0; i &lt; vnode.children.length; i++) &#123; render(vnode.children[i], dom, null, null, i) // 标记位置 &#125;&#125; 1234567891011121314151617181920function diffDOM(vnode, parent, comp, olddom) &#123; const &#123; onlyInLeft, onlyInRight, bothIn &#125; = diffObject(vnode.props, olddom.__vnode.props) setAttrs(olddom, onlyInLeft) // 添加新属性 removeAttrs(olddom, onlyInRight) // 删除旧属性 diffAttrs(olddom, bothIn) // 比较且更新新旧属性的不同 // 比较__rendered 和children 删除多余的 const willRemoveArr = olddom.__rendered.slice(vnode.children.length) const renderedArr = olddom.__rendered.slice(0, vnode.children.length) olddom.__rendered = renderedArr for (let i = 0; i &lt; vnode.children.length; i++) &#123; // 顺序固定，有缺点，原来是replaceChild，现在对dom 或 text 节点进行重新render _render(vnode.children[i], olddom, null, renderedArr[i], i) &#125; willRemoveArr.forEach(el =&gt; olddom.removeChild(getDOM(el))) olddom.__vnode = vnode // 不忘重新标记&#125; 123456789101112131415161718192021222324class Component &#123; constructor(props) &#123; this.props = props &#125; setState(state) &#123; setTimeout(() =&gt; &#123; this.state = state const vnode = this.render() let olddom = getDOM(this) // 获取渲染此实例的 olddom const myIndex = getDOMIndex(olddom) const startTime = new Date().getTime() render(vnode, olddom.parentNode, this.__rendered, myIndex) // 传入此组件渲染的内容 console.log(&quot;duration for setState:&quot;, new Date().getTime() - startTime) &#125;, 0) &#125;&#125;function getDOMIndex(dom) &#123; const nodes = dom.parentNode.childNodes for (let i = 0; i &lt; nodes.length; i++) &#123; if (nodes[i] === dom) return i &#125;&#125; 最后再看下这张图，setState 后也会尝试复用组件，完善 __rendered 链","categories":[{"name":"React","slug":"React","permalink":"http://yoursite.com/categories/React/"}],"tags":[{"name":"React","slug":"React","permalink":"http://yoursite.com/tags/React/"}]},{"title":"学习并实现react2","slug":"学习并实现react2","date":"2018-03-13T13:09:05.000Z","updated":"2023-09-12T16:43:41.323Z","comments":true,"path":"2018/03/13/学习并实现react2/","link":"","permalink":"http://yoursite.com/2018/03/13/%E5%AD%A6%E4%B9%A0%E5%B9%B6%E5%AE%9E%E7%8E%B0react2/","excerpt":"","text":"组件列表渲染场景123456789101112131415161718192021222324252627// app.jsclass App extends Component &#123; constructor(props) &#123; super(props) this.state = &#123; number: 10000 &#125; &#125; render() &#123; const list = new Array(this.state.number).fill(&#x27;item&#x27;) return ( &lt;div width=&#123;100&#125;&gt; &lt;button onClick=&#123;e =&gt; &#123; this.setState(&#123; number: this.state.number &#125;) &#125;&#125;&gt;click me&lt;/button&gt; &#123;list.map((item, index) =&gt; &lt;div key=&#123;item + index&#125; style=&#123;listStyle&#125;&gt;&#123;`$&#123;item&#125;:$&#123;index&#125;`&#125;&lt;/div&gt;)&#125; &lt;/div&gt; ) &#125;&#125;const startTime = new Date().getTime()render(&lt;App /&gt;, document.getElementById(&#x27;app&#x27;))console.log(&quot;duration for render:&quot;, new Date().getTime() - startTime) 1234567891011// component.js setState(state) &#123; setTimeout(() =&gt; &#123; this.state = state const vnode = this.render() let olddom = getDOM(this) // 获取渲染此实例的 olddom const startTime = new Date().getTime() render(vnode, olddom.parentNode, this, olddom) console.log(&quot;duration for setState:&quot;, new Date().getTime() - startTime) &#125;, 0) &#125; 在这里组件首次渲染(render)和更新状态(setState)后都将渲染10000 条列表, 用时平局150ms \bDOM复用 react 的重点在于首次渲染和更新渲染，现在考虑更新渲染如何复用DOM 让渲染更有效率. 分析更新前后的 vnode 结构1234567891011121314151617181920212223242526const beforeVnode = &#123; tagName: &#x27;div&#x27;, props: &#123; width: &#x27;20px&#x27;, className: &#x27;before&#x27; &#125;, chilren: [child1, child2]&#125;const afterVnode1 = &#123; tagName: &#x27;div&#x27;, props: &#123; width: &#x27;30px&#x27;, className: &#x27;after1&#x27; &#125;, children:[child1, child2, child3]&#125;const afterVnode2 = &#123; tagName: &#x27;span&#x27;, props: &#123; width: &#x27;20px&#x27;, className: &#x27;after2&#x27; &#125;, children:[child1, child2]&#125; beforeVnode vs afterVnode1: tagName 仍然是 div ，只改变了props 和childrenbeforeVnode vs afterVnode2: tagName 由 div -&gt; span 更新原则: dom 节点不变则更新 props 属性，复用 children dom 节点改变则创建新节点 更改 render 函数 render 函数复用 DOM 的情况只存在于文本节点及 DOM 节点 更改前文本节点与 DOM 节点在首次渲染及更新都是 create 或 replace 一个新的节点 1234567891011121314151617181920212223242526// code1/render.jsfunction render(vnode, parent, comp, olddom) &#123; let dom if (typeof vnode === &#x27;string&#x27;) &#123; // 文本节点直接渲染 dom = document.createTextNode(vnode) comp &amp;&amp; (comp.__rendered = dom) if (olddom) parent.replaceChild(dom, olddom) else parent.appendChild(dom) &#125; if (typeof vnode.type === &#x27;string&#x27;) &#123; // dom 节点 dom = document.createElement(vnode.type) comp &amp;&amp; (comp.__rendered = dom) setAttrs(dom, vnode.props) // props 已经被createElement 解析成对象 if (olddom) parent.replaceChild(dom, olddom) else parent.appendChild(dom) for(let i = 0; i &lt; vnode.children.length; i++) &#123; render(vnode.children[i], dom, null, null) // 递归 render children &#125; &#125; ...&#125; 文本节点我们增加了一个对olddom value 的比较 标签节点的渲染逻辑分为首次渲染的 createNewDom 和更新的 diffDOM 1234567891011121314151617181920212223// code2/render.jsfunction render(vnode, parent, comp, olddom) &#123; let dom if (typeof vnode === &#x27;string&#x27; || typeof vnode === &#x27;number&#x27;) &#123; // 文本节点直接渲染 if (olddom &amp;&amp; olddom.nodeType === 3) &#123; // 是一个文本节点 if (olddom.nodeValue !== vnode) olddom.nodeValue = vnode &#125; else &#123; dom = document.createTextNode(vnode) if (olddom) parent.replaceChild(dom, olddom) else parent.appendChild(dom) &#125; &#125; if (typeof vnode.type === &#x27;string&#x27;) &#123; // dom 节点 if (!olddom || olddom.nodeName !== vnode.type.toUpperCase()) &#123; createNewDom(vnode, parent, comp, olddom) &#125; else &#123; diffDOM(vnode, parent, comp, olddom) &#125; &#125; ...&#125; createNewDom 抽离 DOM 节点首次渲染方法，首次渲染为每个节点添加 vnode 标记。 12345678910111213function createNewDom(vnode, parent, comp) &#123; let dom = document.createElement(vnode.type) dom.__vnode = vnode // 为 DOM 节点对象增加 vnode 标记，diffDOM 时会用到 comp &amp;&amp; (comp.__rendered = dom) setAttrs(dom, vnode.props) parent.appendChild(dom) for (let i = 0; i &lt; vnode.children.length; i++) &#123; render(vnode.children[i], dom, null, null) &#125;&#125; diffDOM 设计思路 diffObject \b比较新旧vnode 的属性 然后通过新旧vnode 的差异更改 olddom 的属性 比较新children 与olddom 的子节点进行递归渲染 最后记得删除 olddom 123456789101112131415161718192021222324252627/** * * @param vnode &#123;object&#125; 即将更新的vnode * @param olddom &#123;HTMLElement&#125; * __vnode (object) 渲染olddom 的vnode 标记 */function diffDOM(vnode, olddom) &#123; const &#123; onlyInLeft, onlyInRight, bothIn &#125; = diffObject(vnode.props, olddom.__vnode.props) setAttrs(olddom, onlyInLeft) // 添加新属性 removeAttrs(olddom, onlyInRight) // 删除旧属性 diffAttrs(olddom, bothIn) // 比较且更新新旧属性的不同 let olddomChild = olddom.firstChild for (let i = 0; i &lt; vnode.children.length; i++) &#123; // 顺序固定，有缺点，原来是replaceChild，现在对dom 或 text 节点进行重新render render(vnode.children[i], olddom, null, olddomChild) olddomChild = olddomChild &amp;&amp; olddomChild.nextSibling &#125; while (olddomChild) &#123; // 递归后删除所有 olddom let next = olddomChild.nextSibling olddom.removeChild(olddomChild) olddomChild = next &#125; olddom.__vnode = vnode&#125; 1234567891011121314151617181920212223242526272829303132333435/** * * @param leftProps &#123;object&#125; newProps * @param rightProps &#123;object&#125; oldProps */function diffObject(leftProps, rightProps) &#123; const onlyInLeft = &#123;&#125;, // 只存在于left onlyInRight = &#123;&#125;, // 只存在于right bothLeft = &#123;&#125;, // 两者都有 bothRight = &#123;&#125; // 两者都有 for (let key in leftProps) &#123; if (!rightProps[key]) &#123; onlyInLeft[key] = leftProps[key] &#125; else &#123; bothLeft[key] = leftProps[key] bothRight[key] = rightProps[key] &#125; &#125; for (let key in rightProps) &#123; if (!leftProps[key]) &#123; onlyInRight[key] = rightProps[key] &#125; &#125; return &#123; onlyInRight, onlyInLeft, bothIn: &#123; left: bothLeft, right: bothRight &#125; &#125;&#125; 12345678910111213141516171819202122232425262728function setAttrs(dom, props) &#123; Object.keys(props).forEach(k =&gt; &#123; const v = props[k] if (k === &#x27;className&#x27;) &#123; dom.setAttribute(&#x27;class&#x27;, v) return &#125; if (k === &#x27;style&#x27;) &#123; if (typeof v === &#x27;string&#x27;) dom.style.cssText = v if (typeof v === &#x27;object&#x27;) &#123; for (let i in v) &#123; dom.style[i] = v[i] &#125; &#125; return &#125; if (k[0] === &#x27;o&#x27; &amp;&amp; k[1] === &#x27;n&#x27;) &#123; // onClick of onClickCapture const capture = k.indexOf(&#x27;Capture&#x27;) !== -1 dom.addEventListener(k.replace(&#x27;Capture&#x27;, &#x27;&#x27;).substring(2).toLowerCase(), v, capture) return &#125; dom.setAttribute(k, v) &#125;)&#125; 1234567891011121314151617181920212223function removeAttrs(dom, props) &#123; Object.keys(props).forEach(k =&gt; &#123; const v = props[k] if (k === &#x27;className&#x27;) &#123; dom.removeAttribute(&#x27;class&#x27;, v) return &#125; if (k === &#x27;style&#x27;) &#123; dom.style.cssText = &#x27;&#x27; return &#125; if (k[0] === &#x27;o&#x27; &amp;&amp; k[1] === &#x27;n&#x27;) &#123; // onClick of onClickCapture const capture = k.indexOf(&#x27;Capture&#x27;) !== -1 dom.removeEventListener(k.replace(&#x27;Capture&#x27;, &#x27;&#x27;).substring(2).toLowerCase(), v, capture) return &#125; dom.removeAttribute(k) &#125;)&#125; 123456789101112131415161718192021222324252627282930313233343536373839function diffAttrs(dom, &#123; left: newProps, right: oldProps &#125;) &#123; Object.keys(newProps).forEach(k =&gt; &#123; let nv = newProps[k] // newValue let ov = oldProps[k] // oldValue if (nv === ov) return if (k === &#x27;className&#x27;) &#123; dom.setAttribute(&#x27;class&#x27;, nv) return &#125; if (k === &#x27;style&#x27;) &#123; if (typeof nv === &#x27;string&#x27;) &#123; dom.style.cssText = nv &#125; else if (typeof nv === &#x27;object&#x27; &amp;&amp; typeof ov === &#x27;object&#x27;) &#123; Object.keys(nv).forEach(nk =&gt; &#123; if (nv[nk] !== ov[nk]) dom.style[nk] = nv[nk] &#125;) Object.keys(ov).forEach(ok =&gt; &#123; if (!nv[ok]) dom.style[ok] = &#x27;&#x27; &#125;) &#125; else if (typeof nv === &#x27;object&#x27; &amp;&amp; typeof ov === &#x27;string&#x27;) &#123; dom.style = &#123;&#125; Object.keys(nv).forEach(nk =&gt; dom.style[nk] = nv[nk]) &#125; return &#125; if (k[0] === &#x27;o&#x27; &amp;&amp; k[1] === &#x27;n&#x27;) &#123; const capture = k.indexOf(&#x27;Capture&#x27;) !== -1 const eventKey = k.replace(&#x27;Capture&#x27;, &#x27;&#x27;).substring(2).toLowerCase() dom.removeEventListener(eventKey, ov, capture) dom.addEventListener(eventKey, nv, capture) return &#125; dom.setAttribute(k, nv) &#125;)&#125; 通过diffDOM 实现了复用 DOM 节点，更新渲染的速度更快。不过这里没实现react 的key 值比较，children 的属性依赖 olddom 的顺序。","categories":[{"name":"React","slug":"React","permalink":"http://yoursite.com/categories/React/"}],"tags":[{"name":"React","slug":"React","permalink":"http://yoursite.com/tags/React/"}]},{"title":"学习并实现react1","slug":"学习并实现react1","date":"2018-03-09T10:37:23.000Z","updated":"2023-09-12T16:43:45.765Z","comments":true,"path":"2018/03/09/学习并实现react1/","link":"","permalink":"http://yoursite.com/2018/03/09/%E5%AD%A6%E4%B9%A0%E5%B9%B6%E5%AE%9E%E7%8E%B0react1/","excerpt":"","text":"搭建学习环境1npm install -g parcel-bundler package.json 123456789101112131415161718192021&#123; &quot;name&quot;: &quot;myReact&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;&quot;, &quot;main&quot;: &quot;index.js&quot;, &quot;scripts&quot;: &#123; &quot;start&quot;: &quot;parcel index.html&quot;, &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot; &#125;, &quot;keywords&quot;: [], &quot;author&quot;: &quot;&quot;, &quot;license&quot;: &quot;ISC&quot;, &quot;dependencies&quot;: &#123; &quot;babel-preset-env&quot;: &quot;^1.6.1&quot;, &quot;babel-preset-es2015&quot;: &quot;^6.24.1&quot;, &quot;parcel-bundler&quot;: &quot;^1.6.2&quot; &#125;, &quot;devDependencies&quot;: &#123; &quot;babel-plugin-transform-react-jsx&quot;: &quot;^6.24.1&quot; &#125;&#125; 支持 JSX在 js 文件中我们是不能写 jsx 语法的，必须使用一种 babel 插件 transform-react-jsx 才能使用。\b新建.babelrc 12345678&#123; &quot;presets&quot;: [&quot;env&quot;], &quot;plugins&quot;: [ [&quot;transform-react-jsx&quot;, &#123; &quot;pragma&quot;: &quot;createElement&quot; &#125;] ]&#125; 这样我们在写React 组件时 babel 会帮我们自动编译成 实现一个 createElement.babelrc 文件中使用了transform-react-jsx 插件，告诉babel 解析 jsx 需要 createElement方法，也就是 babel 编译后的React.createElement createElement 有三个参数 12345678910111213function createElement(type, props, ...args) &#123; props = props || &#123;&#125; let children = [] for (let i = 0; i &lt; args.length; i++) &#123; if (Array.isArray(args[i])) &#123; children = [ ...children, ...args[i] ] &#125; else &#123; children = [ ...children, args[i] ] &#125; &#125; return &#123; type, props, children &#125;&#125; 然后我们来试验下createElement 结果 12345678910111213141516171819import &#123; createElement &#125; from &#x27;./src/react&#x27;const React = &#123;&#125;React.createElement = createElementReact.Component = class Component &#123;&#125;class App extends React.Component &#123; render() &#123; return ( &lt;div&gt; &lt;span&gt;App&lt;/span&gt; &lt;span&gt;component&lt;/span&gt; &lt;/div&gt; ) &#125;&#125;const app = new App().render()console.log(app) new App().render() 这种格式跟 react 组件区别有些大，再实现一个renderVDOM(&lt;App /&gt;) 的格式 1234567891011121314151617181920function reactVDOM(vnode) &#123; if (typeof vnode === &#x27;string&#x27;) return vnode // 文本节点 if (typeof vnode.type === &#x27;string&#x27;) &#123; // type 为标签名 - dom节点 let ret = &#123; type: ret.type, props: ret.props, children: [] &#125; for (let i = 0; i &lt; vnode.children.length; i++) &#123; ret.children.push(reactVDOM(vnode.children[i])) // 递归children &#125; return ret &#125; if (typeof vnode.type === &#x27;function&#x27;) &#123; // type 为 class 组件 let func = vnode.type let inst = new func(vnode.props) // 把 props 传入 let innerVNODE = inst.render() return reactVDOM(innerVNODE) // 递归渲染后的组件 &#125;&#125; 1234567891011121314151617181920import &#123; createElement &#125; from &#x27;./src/react&#x27;import &#123; renderVDOM &#125; from &#x27;./src/renderVDOM&#x27;const React = &#123;&#125;React.createElement = createElementReact.Component = class Component &#123;&#125;class App extends React.Component &#123; render() &#123; return ( &lt;div&gt; &lt;span&gt;App&lt;/span&gt; &lt;span&gt;component&lt;/span&gt; &lt;/div&gt; ) &#125;&#125;const app = renderVDOM(&lt;App /&gt;)console.log(app) // 与 new App().render() 一样 父子组件 12345678910111213141516171819202122232425262728293031323334class ChildrenChild extends React.Component &#123; render() &#123; return ( &lt;div&gt; children-child &lt;/div&gt; ) &#125;&#125;class Children extends React.Component &#123; render() &#123; return ( &lt;div&gt; children &lt;ChildrenChild /&gt; &lt;/div&gt; ) &#125;&#125;class App extends React.Component &#123; render() &#123; return ( &lt;div&gt; &lt;span&gt;App&lt;/span&gt; &lt;span&gt;component&lt;/span&gt; &lt;Children /&gt; &lt;/div&gt; ) &#125;&#125;const app = renderVDOM(&lt;App /&gt;) 结果中组件的文本内容、dom、组件实例都在children 数组里，React.render 时只需要识别这些children 就可以做到真实渲染 实现 render改写 renderVDMO 加入真实 dom 操作 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354function render(vnode, parent) &#123; let dom if (typeof vnode === &#x27;string&#x27;) &#123; // 文本节点直接渲染 dom = document.createTextNode(vnode) parent.appendChild(dom) &#125; if (typeof vnode.type === &#x27;string&#x27;) &#123; // dom 节点 dom = document.createElement(vnode.type) setAttrs(dom, vnode.props) // props 已经被createElement 解析成对象 parent.appendChild(dom) for(let i = 0; i &lt; vnode.children.length; i++) &#123; render(vnode.children[i], dom) // 递归 render children &#125; &#125; if (typeof vnode.type === &#x27;function&#x27;) &#123; // class 组件 let func = vnode.type let inst = new func(vnode.props) // props 已经被createElement 解析成对象 let innerVNode = inst.render() render(innerVNode, parent) &#125;&#125;function setAttrs(dom, props) &#123; Object.keys(props).forEach(k =&gt; &#123; const v = props[k] if (k === &#x27;className&#x27;) &#123; dom.setAttribute(&#x27;class&#x27;, v) return &#125; if (k === &#x27;style&#x27;) &#123; if (typeof v === &#x27;string&#x27;) dom.style.cssText = v if (typeof v === &#x27;object&#x27;) &#123; for (let i in v) &#123; dom.style[i] = v[i] &#125; &#125; return &#125; if (k[0] === &#x27;o&#x27; &amp;&amp; k[1] === &#x27;n&#x27;) &#123; // onClick of onClickCapture const capture = k.indexOf(&#x27;Capture&#x27;) !== -1 dom.addEventListener(k.replace(&#x27;Capture&#x27;, &#x27;&#x27;).substring(2).toLowerCase(), v, capture) return &#125; dom.setAttribute(k, v) &#125;)&#125; 把上面例子换一下 1234567891011121314151617181920212223242526272829303132333435363738394041// app.jsclass ChildrenChild extends React.Component &#123; render() &#123; return ( &lt;div&gt; children-child &lt;/div&gt; ) &#125;&#125;class Children extends React.Component &#123; render() &#123; return ( &lt;div&gt; children &lt;ChildrenChild /&gt; &lt;/div&gt; ) &#125;&#125;class App extends React.Component &#123; render() &#123; return ( &lt;div&gt; &lt;span&gt;App&lt;/span&gt; &lt;span&gt;component&lt;/span&gt; &lt;Children /&gt; &lt;/div&gt; ) &#125;&#125;render(&lt;App /&gt;, document.getElementById(&#x27;app&#x27;))// index.html&lt;body&gt; &lt;div id=&quot;app&quot;&gt;&lt;/div&gt; &lt;script src=&quot;./app.js&quot;&gt;&lt;/script&gt;&lt;/body&gt; 实现props 和state12345678910111213141516171819202122232425262728293031class Color extends React.Component &#123; render() &#123; return ( &lt;div style=&#123;&#123; color: this.props.color &#125;&#125;&gt;color is: &#123;this.props.color&#125;&lt;/div&gt; ) &#125;&#125;const colorArr = [&#x27;red&#x27;, &#x27;blue&#x27;, &#x27;black&#x27;, &#x27;green&#x27;, &#x27;gray&#x27;]class App extends React.Component &#123; constructor(props) &#123; super(props) this.state = &#123; color: &#x27;black&#x27; &#125; &#125; handleClick() &#123; console.log(&quot;handleClick&quot;) this.setState(&#123; color: colorArr[Math.random() * 5 | 0] &#125;) &#125; render() &#123; return ( &lt;div onClick=&#123;this.handleClick.bind(this)&#125;&gt; &lt;Color color=&#123;this.state.color&#125; /&gt; &lt;/div&gt; ) &#125;&#125;render(&lt;App /&gt;, document.getElementById(&#x27;app&#x27;)) 目的: 我们要通过点击 App 组件中的元素来改变 Color 文字的颜色步骤: 把新的state 传入 this.setState 来更新组件 - 调用render 方法 setState123456789101112export default class Component &#123; constructor(props) &#123; this.props = props &#125; setState(state) &#123; setTimeout(() =&gt; &#123; this.state = state // ...render() &#125;) &#125;&#125; 回忆 render 函数有两个参数，vnode， parent，vnode 我们可以使用 this.render() 获取当前组件，但我们要知道需要更新dom 内容的 parent 就需要在首次render 时记录。 改写 render给render 增加参数，comp(当前更新组件)， olddom(当前组件曾经的dom)拿首次渲染举例: parent - document.getElementById(&#39;app&#39;), comp - &lt;App /&gt;, olddom - 当App组件更新时就是App 首次渲染的dom 12345678910111213141516171819202122232425262728293031323334export function render(vnode, parent, comp, olddom) &#123; let dom if (typeof vnode === &#x27;string&#x27;) &#123; // 文本节点直接渲染 dom = document.createTextNode(vnode) comp &amp;&amp; (comp.__rendered = dom) if (olddom) parent.replaceChild(dom, olddom) else parent.appendChild(dom) &#125; if (typeof vnode.type === &#x27;string&#x27;) &#123; // dom 节点 dom = document.createElement(vnode.type) comp &amp;&amp; (comp.__rendered = dom) setAttrs(dom, vnode.props) // props 已经被createElement 解析成对象 if (olddom) parent.replaceChild(dom, olddom) else parent.appendChild(dom) for(let i = 0; i &lt; vnode.children.length; i++) &#123; render(vnode.children[i], dom, null, null) // 递归 render children &#125; &#125; if (typeof vnode.type === &#x27;function&#x27;) &#123; // class 组件 let func = vnode.type let inst = new func(vnode.props) // props 已经被createElement 解析成对象 comp &amp;&amp; (comp.__rendered = inst) // 这里记录的是 Component 实例 let innerVNode = inst.render() render(innerVNode, parent, inst, olddom) &#125;&#125; 在这里我们每次render 的时候都会判断这次render 是否是class 组件触发的render，如果是组件触发的render 我们就会在这个组件comp 上增加 __rendered 记录当前渲染的 dom 或 当前渲染的组件 (组件追溯到顶层也是dom) ，这时候我们需要一个方法来获得olddom 1234567function getDOM (comp) &#123; let rendered = comp.__rendered while (rendered instanceof Component) &#123; rendered = rendered.__rendered &#125; return rendered&#125; 实现 setState1234567891011121314151617import &#123; getDOM &#125; from &#x27;./util&#x27;import &#123; render &#125; from &#x27;./render&#x27;export default class Component &#123; constructor(props) &#123; this.props = props &#125; setState(state) &#123; setTimeout(() =&gt; &#123; this.state = state const vnode = this.render() let olddom = getDOM(this) // 获取渲染此实例的 olddom render(vnode, olddom.parentNode, this, olddom) &#125;) &#125;&#125; 实现效果12345678910111213141516171819202122232425262728293031323334353637383940import &#123; render, createElement, Component &#125; from &#x27;./src/code1/react&#x27;const React = &#123;&#125;React.createElement = createElementReact.Component = Componentclass Color extends React.Component &#123; render() &#123; return ( &lt;div style=&#123;&#123; color: this.props.color &#125;&#125;&gt;color is: &#123;this.props.color&#125;&lt;/div&gt; ) &#125;&#125;const colorArr = [&#x27;red&#x27;, &#x27;blue&#x27;, &#x27;black&#x27;, &#x27;green&#x27;, &#x27;gray&#x27;]class App extends React.Component &#123; constructor(props) &#123; super(props) this.state = &#123; color: &#x27;black&#x27; &#125; &#125; handleClick() &#123; console.log(&quot;handleClick&quot;) this.setState(&#123; color: colorArr[Math.random() * 5 | 0] &#125;) &#125; render() &#123; return ( &lt;div onClick=&#123;this.handleClick.bind(this)&#125;&gt; &lt;Color color=&#123;this.state.color&#125; /&gt; &lt;/div&gt; ) &#125;&#125;render(&lt;App /&gt;, document.getElementById(&#x27;app&#x27;))","categories":[{"name":"React","slug":"React","permalink":"http://yoursite.com/categories/React/"}],"tags":[{"name":"React","slug":"React","permalink":"http://yoursite.com/tags/React/"}]},{"title":"前端基础重点回顾6:渲染机制、页面性能优化、错误监控","slug":"前端基础重点回顾6-渲染机制、页面性能优化、错误监控","date":"2018-02-05T12:26:55.000Z","updated":"2023-09-12T16:43:52.981Z","comments":true,"path":"2018/02/05/前端基础重点回顾6-渲染机制、页面性能优化、错误监控/","link":"","permalink":"http://yoursite.com/2018/02/05/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E9%87%8D%E7%82%B9%E5%9B%9E%E9%A1%BE6-%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6%E3%80%81%E9%A1%B5%E9%9D%A2%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E3%80%81%E9%94%99%E8%AF%AF%E7%9B%91%E6%8E%A7/","excerpt":"","text":"渲染机制DOCTYPE DOCTYPE是用来声明文档类型的，告诉浏览器使用哪一种DTD规范的文档类型。 DTD(document type definition, 文档类型定义) 是一些列的语法规则，用来定义HTML文件类型。用来给浏览器判断文档类型。 声明文档类型 HTML5 HTML 4.01 有宽松模式和严格模式(不包括展示性和弃用的元素) 浏览器渲染过程 HTML通过HTML解析转化成DOM树 Style样式通过CSS解析转化成Style规则 DOM树和Style规则结合成渲染树(Render Tree) 然后渲染树通过layout 计算出各元素在浏览器上的宽高颜色位置等属性，最后在浏览器上进行绘制。 重排Reflow DOM元素的盒模型需要浏览器根据样式计算结果将他们绘制在页面上，这个过程就是reflow 触发Reflow 条件 增加、删除、修改DOM节点时，会触发Reflow 或 Repaint 移动DOM节点、动画 修改CSS样式 resize 窗口、滚动页面 修改页面默认字体 重绘Repaint 当DOM元素盒模型的各种属性确定计算结果后，浏览器根据这些元素的样式属性绘制一遍出现在页面上的过程就是repaint 触发Repaint DOM改动 CSS改动 减少Reflow Repaint的开销 DOM拼接后一次append 到页面上(列表) 页面性能优化打开浏览器，在地址栏输入 url 直到页面展现，整个过程发生了什么？ DNS(Domain Name System)域名系统预解析(应用层)，输入url后,浏览器会进行DNS解析出, 对应服务器的ip地址. 浏览器会将用户输入的请求信息打包发送给nginx服务器. 服务器会分析用户的请求寻找处理请求的对应文件，发送给浏览器. 最后浏览器接收服务器的响应,解析并渲染呈现给用户。 提升页面性能的方法有哪些？ 资源压缩合并，减少HTTP请求 非核心代码异步加载 利用浏览器缓存 使用CDN 预解析DNS 非核心代码异步加载 动态脚本加载动态创建&lt;script&gt;标签添加到html 文档中内 &lt;script&gt; 标签的defer 属性在html 文档解析完执行，按加载顺序依次执行 &lt;script&gt; 标签的async 属性在html 文档解析完执行，加载顺序与执行顺序无关 利用浏览器缓存 强缓存:客户端无需再次请求服务端，客户端直接根据缓存条件决定是否使用缓存资源 响应header 描述 常用响应返回内容 推荐 特点 缺点 场景 Cache-Control 在多少秒内进行缓存 public, max-age&#x3D;秒 是 固定时间 客户端服务端时间可能不一致 Expires 在此时间前进行缓存 格林威治时间 否 绝对时间 客户端服务端时间可能不一致 兼容http1.0 协商缓存:客户端需请求服务端进行比较缓存条件，符合条件则返回304使用缓存资源 响应header 请求header 描述 常用响应返回内容 推荐 特点 缺点 场景 ETag If-None-Match 固定字符串 md5 hash值 是 检测文件完整性 Last-Modified If-Modified-Since 在某时间后没再更改 格林威治时间 否 浏览器根据返回的时间自己决定缓存 浏览器差异 DNS 预解析123// 强制打开a 标签的DNS 预解析，https 默认关闭a 标签的DNS 预解析&lt;meta http-equiv=&quot;x-dns-prefetch-control&quot; content=&quot;on&quot;&gt;&lt;link rel=&quot;dns-prefatch&quot; href=&quot;url&quot;&gt; 前端错误监控 保证产品质量 即时运行错误(代码错误)收集 资源加载错误收集 即时运行错误的捕获方式123456// 代码块使用错误捕获try &#123;&#125; catch (e) &#123;&#125;// 使用window对象错误事件捕获window.onerror = function(e) &#123;&#125;window.addEventListener(&#x27;error&#x27;, function(e) &#123;&#125;) 资源加载错误&lt;img&gt;等资源加载错误不会冒泡，window.onerror 无法捕获到标签资源加载的错误 \bdom 捕获 123elScript.onerror = function (e)&#123;&#125;elImg.onerror = function (e)&#123;&#125;... 跨域js 错误捕获 js 文件资源响应头设置Access-Control-Allow-Origin: * script 标签增加crossorigin 属性&lt;script crossorigin src=&#39;url&#39;&gt;&lt;/script&gt; 获取成功加载的资源12performance.getEntries()performance.getEntries().map(item =&gt; item.name) // 获取所有成功资源加载地址 通过Error 事件捕获1234window.addEventListener(&#x27;error&#x27;, function(e) &#123; console.log(&#x27;捕获&#x27;, e) // 将会捕获到资源加载错误&#125;, true)&lt;script src=&#x27;错误url&#x27;&gt;&lt;/script&gt; 上报错误的基本原理 采用Ajax 通信方式上报 利用Image 对象上报 123&lt;script&gt; new Image().src = &#x27;url?k=val&#x27; // 会发送一个请求用于上报&lt;/script&gt; 参考","categories":[{"name":"Font-End Basis","slug":"Font-End-Basis","permalink":"http://yoursite.com/categories/Font-End-Basis/"}],"tags":[]},{"title":"前端基础重点回顾5:XSS、CSRF攻击","slug":"前端基础重点回顾5-XSS、CSRF攻击","date":"2018-01-31T09:01:53.000Z","updated":"2023-09-12T16:43:55.063Z","comments":true,"path":"2018/01/31/前端基础重点回顾5-XSS、CSRF攻击/","link":"","permalink":"http://yoursite.com/2018/01/31/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E9%87%8D%E7%82%B9%E5%9B%9E%E9%A1%BE5-XSS%E3%80%81CSRF%E6%94%BB%E5%87%BB/","excerpt":"","text":"XSS攻击前提 攻击脚本必须添加到页面上 攻击方式 跨站脚本XSS(Cross site script) 代码注入 script 标签注入攻击 &lt;li&gt;&lt;script&gt;alert(1)&lt;/script&gt;&lt;/li&gt; 标签属性注入攻击 &lt;img src=&quot;&quot; onerror=&quot;alert(1)&quot;&gt; &lt;p onclick=&quot;alert(2)&quot;&gt;诱导点击&lt;/p&gt; 广告注入 &lt;iframe src=&#39;&#39;&gt;&lt;/iframe&gt; 防止XSS攻击 获取的数据不允许进行字符串拼接 使用element.inneText方法 把数据添加到dom 中，inneText 方法会转义所有内容 把所有数据里的/[&quot;&#39;&amp;&lt;&gt;]/使用正则进行转义 存储数据时过滤并转义/[&quot;&#39;&amp;&lt;&gt;]/ 防止URL 上的参数在页面上展示 http://url?code=&lt;p onclick=&quot;alert(2)&quot;&gt;诱导点击&lt;/p&gt; 这里的code query参数内容不得在页面中渲染 CSRF 攻击原理 利用用户已经登录的状态 伪造请求发送给服务器进行用户操作 攻击方式 跨站请求伪造(Cross site request forgery) 用户已登录(cookie登录)如果没设置httpOnly cookie是根据域名和路径访问的, 无关端口 伪造请求(GET, POST) 123伪造GET&lt;img src=&quot;http://localhost:3000/csrf?data=111&quot; alt=&quot;&quot;&gt;http://localhost:3000/csrf?data=111 // 直接地址栏中输入 1234567891011表单伪造POST &lt;form id=&quot;form&quot; style=&quot;display: none;&quot; action=&quot;http://localhost:3000/csrf?data=111&quot; method=&quot;post&quot; target=&quot;csrf&quot;&gt; &lt;/form&gt; &lt;input id=&quot;btn&quot; type=&quot;button&quot; value=&quot;submit&quot;&gt; &lt;iframe src=&quot;&quot; style=&quot;display: none;&quot; name=&quot;csrf&quot; frameborder=&quot;0&quot;&gt;&lt;/iframe&gt; &lt;script&gt; btn.addEventListener(&#x27;click&#x27;, (e) =&gt; &#123; e.preventDefault() form.submit() &#125;) &lt;/script&gt; 防止CSRF攻击 请求时不仅浏览器携带cookie， 请求参数也需要把跟cookie 相关的值携带到参数中, 伪造的请求无法获取正确网站cookie的值, 比如常见约定的csrfToken 使用Authorization 的token 授权 提交表单的时候增加token 认证 验证请求header 的Referer 携带请求来源信息","categories":[{"name":"Font-End Basis","slug":"Font-End-Basis","permalink":"http://yoursite.com/categories/Font-End-Basis/"}],"tags":[{"name":"http","slug":"http","permalink":"http://yoursite.com/tags/http/"}]},{"title":"前端基础重点回顾4:前后端通信","slug":"前端基础重点回顾4-前后端通信","date":"2018-01-30T05:16:50.000Z","updated":"2023-09-12T16:43:57.168Z","comments":true,"path":"2018/01/30/前端基础重点回顾4-前后端通信/","link":"","permalink":"http://yoursite.com/2018/01/30/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E9%87%8D%E7%82%B9%E5%9B%9E%E9%A1%BE4-%E5%89%8D%E5%90%8E%E7%AB%AF%E9%80%9A%E4%BF%A1/","excerpt":"","text":"同源策略及限制同源策略的概念 同源:http协议，域名， 端口三者均相同 同源策略是用来限制在一个源上加载的文档或脚本与来自另一个源的资源进行交互。这是一个用于隔离潜在恶意文件的关键的安全机制。 同源策略的限制 cookie localStorage indexDB 无法读取 dom 无法获得 ajax请求不能发送 前后端通信的常见几种方式 Ajax(同源通信) WebSocket(协议不同的不同源通信) CORS(用于支持不同源之间ajax通信的方法) Ajax通信参考 Ajax 概念 Ajax(Async JavaScript And XML)是一种依赖CSS&#x2F;HTML&#x2F;JAVASCRIPT 等现有技术使用XMLHttpRequest 对象发送http 请求并接受响应的一种技术方案 实现一个Ajax1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/** * &#123;string&#125; param.url * &#123;string&#125; param.type? || &#x27;get&#x27; * &#123;object&#125; param.data * &#123;function&#125; param.success * &#123;function&#125; param.error */var ajax = function(param) &#123; var xhr = XMLHttpRequest ? new XMLHttpRequest() : new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;) var type = (param.type || &#x27;get&#x27;).toUpperCase() var url = param.url if(!url) return var data = param.data var dataArr = [] for (var k in data) &#123; dataArr.push(k + &#x27;=&#x27; + data[k]) &#125; if (type === &#x27;GET&#x27;) &#123; url = url + &#x27;?&#x27; + dataArr.join(&#x27;&amp;&#x27;) xhr.open(type, url) xhr.send() &#125; if (type === &#x27;POST&#x27;) &#123; xhr.open(type, url) xhr.setRequestHeader(&quot;Content-type&quot;, &quot;application/x-www.form-urlencoded&quot;) xhr.send(dataArr.join(&#x27;&amp;&#x27;)) &#125; xhr.onreadystatechange = function () &#123; if (xhr.readyState === 4) &#123; if (xhr.status === 200 || xhr.status === 304) &#123; var res if (param.success &amp;&amp; typeof param.success === &#x27;function&#x27;) &#123; res = xhr.responseText if (typeof res === &#x27;string&#x27;) &#123; res = JSON.parse(res) param.success.call(xhr, res) &#125; &#125; &#125; else &#123; param.error.call() &#125; &#125; &#125;&#125; 跨域通信的几种方式 首先我们先给host 设置几个子域名来模拟跨域 跨域代码示例 1234$ npm install$ npm startport: 3000 使用示例前记得设置本机host JSONPjsonp 原理就是在页面上动态添加一个script标签，给标签的src 指定一个url 路径并加上回调函数query 参数，发送给后端后，后端利用需返回的数据和回调函数的query 参数拼接成类似handleJsonp(&#123; a:1, b:2 &#125;)的字符串返回前端，前端定义的handleJsonp 的函数会直接运行并处理&#123; a:1, b:2 &#125; 这个后端返回的数据 只能发送GET请求 可能会被注入恶意代码 callback&#x3D;alter(‘111’) 任何域都可以发送jsonp请求，需进行验证，如token 1234567891011// 前端代码 jsonpBtn.addEventListener(&#x27;click&#x27;, function() &#123; const script = document.createElement(&#x27;script&#x27;) script.src = &#x27;http://b.yang.com:3000/jsonp?callback=handleJsonp&#x27; document.head.appendChild(script) // document.head.removeChild(script) &#125;) function handleJsonp(data) &#123; console.log(data) &#125; 123456789101112// 后端代码// JSONProuter.get(&#x27;/jsonp&#x27;, function(req, res, next) &#123; let &#123; callback: cb &#125; = req.query const data = &#123; type: &#x27;jsonp&#x27;, data: &#x27;data&#x27; &#125; cb = cb.replace(/\\(/g, &#x27;&#x27;); // 替换掉() 防止恶意代码注入 cb = cb.replace(/\\)/g, &#x27;&#x27;); res.send(cb + &#x27;(&#x27; + JSON.stringify(data) + &#x27;)&#x27;)&#125;) CORS CORS(cross-origin resource sharing) 跨域资源共享，是一种ajax 跨域请求资源的方式， 普遍用于前后端分离开发环境 原理就在于Access-Control-Allow-Origin 响应头，它指定浏览器在何种域下发送的ajax 请求服务器资源时可以跨域 服务器响应还可以设置其它header:1Access-Control-Allow-Methods: POST, GET, OPTIONS表明服务器允许客户端使用 POST, GET 和 OPTIONS 方法发起请求2Access-Control-Allow-Headers: X-PINGOTHER, Content-Type表明服务器允许请求中携带字段 X-PINGOTHER 与 Content-Type3Access-Control-Max-Age: 86400表明该响应的有效时间为 86400 秒4Access-Control-Allow-Credentials: true 表明跨域请求允许携带cookieMDN 12345678910111213// 前端代码 cors.addEventListener(&#x27;click&#x27;, function() &#123; let reqHeaders = new Headers() reqHeaders.append(&#x27;Content-Type&#x27;, &#x27;application/x-www-form-urlencoded&#x27;) fetch(&#x27;http://b.yang.com:3000/cors/&#x27;, &#123; method: &#x27;post&#x27;, headers: reqHeaders, mode: &#x27;cors&#x27;, body: &#x27;post body&#x27; &#125;).then(function (response) &#123; console.log(response) &#125;) &#125;) 1234567// 后端代码// CORSrouter.post(&#x27;/cors&#x27;, function(req, res, next) &#123; // res.header(&#x27;Access-Control-Allow-Origin&#x27;, &#x27;http://a.yang.com:3000&#x27;) res.header(&#x27;Access-Control-Allow-Origin&#x27;, &#x27;*&#x27;) res.send(&#x27;cors ok&#x27;)&#125;) WebSocket利用websocket 协议进行前后端跨域通信 123456789101112// 前端代码 var ws socket.addEventListener(&#x27;click&#x27;, function() &#123; ws = new WebSocket(`ws://b.yang.com:3000/`) ws.onmessage = (data) =&gt; console.log(data); ws.onerror = () =&gt; console.log(&#x27;WebSocket error&#x27;); ws.onopen = () =&gt; console.log(&#x27;WebSocket connection established&#x27;); ws.onclose = () =&gt; console.log(&#x27;WebSocket connection closed&#x27;); &#125;) sendmsg.addEventListener(&#x27;click&#x27;, function() &#123; ws.send(&#x27;send a msg&#x27;) &#125;) 1234567891011121314// 后端代码var express = require(&#x27;express&#x27;);var app = express();const WebSocket = require(&#x27;ws&#x27;)var server = http.createServer(app);const wss = new WebSocket.Server(&#123; server &#125;)wss.on(&#x27;connection&#x27;, (ws, req) =&gt; &#123; ws.on(&#x27;message&#x27;, message =&gt; &#123; console.log(message) ws.send(message) &#125;)&#125;)server.listen(3000) 降域(使用iframe)1234567891011121314151617// URL: http://a.yang.com:3000/a&lt;div class=&quot;ct&quot;&gt; &lt;h1&gt;使用降域实现跨域&lt;/h1&gt; &lt;div class=&quot;main&quot;&gt; &lt;h4&gt;URL: http://a.yang.com:3000/a&lt;/h4&gt; &lt;input type=&quot;text&quot; placeholder=&quot;http://a.yang.com:3000/a&quot;&gt; &lt;/div&gt; &lt;iframe src=&quot;http://b.yang.com:3000/b&quot; frameborder=&quot;0&quot; &gt;&lt;/iframe&gt;&lt;/div&gt;&lt;script&gt; document.querySelector(&#x27;.main input&#x27;).addEventListener(&#x27;input&#x27;, function()&#123; console.log(location.host, this.value); window.frames[0].document.querySelector(&#x27;input&#x27;).value = this.value; &#125;) document.domain = &quot;yang.com&quot;&lt;/script&gt; 123456789// URL: http://b.yang.com:3000/b&lt;input id=&quot;input&quot; type=&quot;text&quot; placeholder=&quot;http://b.yang.com:3000/b&quot;&gt;&lt;script&gt; document.querySelector(&#x27;#input&#x27;).addEventListener(&#x27;input&#x27;, function()&#123; console.log(location.host, this.value); window.parent.document.querySelector(&#x27;input&#x27;).value = this.value; &#125;) document.domain = &#x27;yang.com&#x27;;&lt;/script&gt; postMessage(使用iframe)123456789101112131415161718192021//URL: http://a.yang.com:3000/c&lt;div class=&quot;ct&quot;&gt; &lt;h1&gt;使用postMessage实现跨域&lt;/h1&gt; &lt;div class=&quot;main&quot;&gt; &lt;h4&gt;URL: http://a.yang.com:3000/c&lt;/h4&gt; &lt;input type=&quot;text&quot; placeholder=&quot;http://a.yang.com:3000/c&quot;&gt; &lt;/div&gt; &lt;iframe src=&quot;http://localhost:3000/d&quot; frameborder=&quot;0&quot; &gt;&lt;/iframe&gt;&lt;/div&gt;&lt;script&gt; var input = document.querySelector(&#x27;.main input&#x27;) input.addEventListener(&#x27;input&#x27;, function()&#123; console.log(&#x27;a.yang.com - input event value&#x27;, this.value); window.frames[0].postMessage(this.value,&#x27;*&#x27;); &#125;) window.addEventListener(&#x27;message&#x27;,function(e) &#123; input.value = e.data console.log(&#x27;a.yang.com - message event value&#x27;, e.data); &#125;);&lt;/script&gt; 1234567891011121314// URL: http://b.yang.com:3000/d&lt;input id=&quot;input&quot; type=&quot;text&quot; placeholder=&quot;http://b.yang.com:3000/d&quot;&gt;&lt;script&gt; var input = document.querySelector(&#x27;#input&#x27;) input.addEventListener(&#x27;input&#x27;, function()&#123; console.log(&#x27;b.yang.com - input event value&#x27;, this.value); window.parent.postMessage(this.value, &#x27;*&#x27;); &#125;) window.addEventListener(&#x27;message&#x27;,function(e) &#123; input.value = e.data console.log(&#x27;b.yang.com - message event value&#x27;, e.data); &#125;);&lt;/script&gt; 其他hack改变hash值","categories":[{"name":"Font-End Basis","slug":"Font-End-Basis","permalink":"http://yoursite.com/categories/Font-End-Basis/"}],"tags":[{"name":"http","slug":"http","permalink":"http://yoursite.com/tags/http/"}]},{"title":"前端基础重点回顾3:原型链、面向对象、继承","slug":"前端基础重点回顾3:原型链、面向对象、继承","date":"2018-01-26T15:22:17.000Z","updated":"2023-09-12T16:43:59.841Z","comments":true,"path":"2018/01/26/前端基础重点回顾3:原型链、面向对象、继承/","link":"","permalink":"http://yoursite.com/2018/01/26/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E9%87%8D%E7%82%B9%E5%9B%9E%E9%A1%BE3:%E5%8E%9F%E5%9E%8B%E9%93%BE%E3%80%81%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E3%80%81%E7%BB%A7%E6%89%BF/","excerpt":"","text":"创建对象的几种方法 字面量创建对象1var o1 = &#123; name: &#x27;o1&#x27; &#125; 使用Object构造函数创建对象1var o2 = new Object(&#123; name: &#x27;o2&#x27; &#125;) 使用显式构造函数创建12var Obj = function (name) &#123; this.name = name &#125;var o3 = new Obj(&#x27;o3&#x27;) 是用Object.create 创建一个指定原型的对象12var proto = &#123; name: &#x27;o4&#x27; &#125;var o4 = Object.create(proto) 原型链 原型链描述 1.从一个实例对象向上找构造这个实例相关联的对象，2.再从从这个相关联的对象继续向上找创建这个对象相关联的对象，3.以此类推一直到Object.prototype (null)终止。 原型链通过什么连接和寻找 通过构造函数prototype 和 实例对象的proto 进行寻找 原型对象prototype 有什么特点 构造函数的prototype 由此构造函数创建的多个实例共同使用的对象 instanceof的原理 判断实例对象:proto 和构造函数:prototype 两者的引用是否是同一个原型的引用地址(比如Object.prototype ) 在原型链上的构造函数都会返回true 面向对象类与实例1234567891011var P = function (name) &#123; this.name = name&#125;class P &#123; constructor (name) &#123; this.name = name &#125;&#125;const p = new P(&#x27;name&#x27;) new 操作符使用1234567// 使用new 操作符直接创建实例var p1 = new Person(&#x27;laoyang&#x27;, &#x27;22&#x27;, &#x27;coding&#x27;)// 不使用new 操作符var p2 = new Object() // p2 创建成为一个对象 这时p2的原型是ObjectPerson.call(p2, &#x27;xiaoyang&#x27;, &#x27;2&#x27;, &#x27;test&#x27;) // Person构造函数在 p2 对象的环境内执行 这时p2已经是一个具有Person属性的实例了，但原型是Objectp2.__proto__ = Object.create(Person.prototype) // 最后创建一个原型为Person.prototype 的p2.__proto__，让p2的原型为Person.prototype new 操作符做了什么 创建一个空对象，它继承自构造函数Person.prototype 构造函数Person被执行，执行时相应的参数会被传入，同时上下文this会被指定为这个新实例 如果构造函数Person返回了一个对象，那么这个对象会取代整个new 出来的结果，如果构造函数没有返回对象，那么new 出来的结果为创建的对象 123456789101112var new = function(func) &#123; var o = Object.create(func.prototype) var k = function.call(o) if (typeof k === &#x27;object&#x27;) &#123; return k &#125; else &#123; return o &#125;&#125;var obj = new(P)obj instanceof P // trueobj.__proto__.constructor === P // true 继承有几种方式 借助构造函数实现继承123456789function Parent () &#123; this.name = &#x27;parent&#x27;&#125;Parent.prototype.fn = function () &#123;&#125;function Child () &#123; Parent.call(this) this.type = &#x27;child&#x27;&#125;缺点: Parent 的原型对象prototype 无法继承 借助原型链实现继承1234567891011121314function Parent () &#123; this.name = &#x27;parent&#x27; this.arr = [1,2,3]&#125;function Child () &#123; this.type = &#x27;child&#x27;&#125;Child.prototype = new Parent()优点: 解决了Parent 原型对象的继承缺点: 由Child 创建的多个实例对象共享父类的引用类型var c1 = new Child()var c2 = new Child()c1.arr.push(4)c2.arr // [1, 2, 3, 4] 前两种的组合方式1234567891011function Parent () &#123; this.name = &#x27;parent&#x27; this.arr = [1, 2, 3, 4]&#125;function Child () &#123; Parent.call(this) this.type = &#x27;child&#x27;&#125;Child.prototype = new Parent()优点: 不仅实现了父类prototype 的继承，也通过Parent.call(this) 创建了各实例独自的arr 复杂类型缺点: 不够优雅，可以优化 组合方式优化11234567891011function Parent () &#123; this.name = &#x27;parent&#x27; this.arr = [1, 2, 3]&#125;function Child () &#123; Parent.call(this) this.type = &#x27;child&#x27;&#125;Child.prototype = Parent.prototype优点: \bChild不仅继承了Parent 的prototype，而且实现优雅缺点: Child 创建的实例constructor 指向是Parent, 而且修改了Parent.prototype 会同时改变Child.prototype 和由Child 创建实例的__proto__ 组合方式优化21234567891011function Parent () &#123; this.name = &#x27;parent&#x27; this.arr = [1, 2, 3]&#125;function Child () &#123; Parent.call(this) this.type = &#x27;child&#x27;&#125;Child.prototype = Object.create(Parent.prototype) // 创建一个纯净的对象Child.prototype.constructor = Child // 把Child 原型的constructor 指向自己优点: 不仅完成了继承，同时把Child.prototype.constructor 指向自己，使得每个实例的__proto__.constructor 都指向Child构造函数，更规范。使用Object.create(proto) 方法创建了一个原型对象为Parent.prototype 但是又和Parent.prototype 彻底分离的纯净对象，与Child.prototype 两者互不影响。","categories":[{"name":"Font-End Basis","slug":"Font-End-Basis","permalink":"http://yoursite.com/categories/Font-End-Basis/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"前端基础重点回顾2:HTTP协议","slug":"前端基础重点回顾2:HTTP协议","date":"2018-01-24T08:50:04.000Z","updated":"2018-01-24T08:54:24.000Z","comments":true,"path":"2018/01/24/前端基础重点回顾2:HTTP协议/","link":"","permalink":"http://yoursite.com/2018/01/24/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E9%87%8D%E7%82%B9%E5%9B%9E%E9%A1%BE2:HTTP%E5%8D%8F%E8%AE%AE/","excerpt":"","text":"HTTP协议的主要特点 简单快速URI固定，处理简单 灵活http协议可以通过修改header 指定传输的数据类型，一个http 传输可以完成不同数据类型的传输 无连接http协议每次传输后连接都会断开 无状态客户端和服务端是两块，客户端再次访问服务端是无法区分客户端的(单从http 协议上是无法区分客户端身份的) HTTP报文组成请求报文 请求行http方法、请求地址、http协议版本 请求头header：key value 格式 空行(CR+LF)用于识别请求头和请求体的分隔符，CR+LF 回车+换行符 请求体 响应报文 状态行状态码、http协议版本 响应头header：key value 格式 空行(CR+LF)用于识别响应头和响应体的分隔符，CR+LF 回车+换行符 响应体响应的实体内容 HTTP方法 get 获取 post 传输 put 更新 delete 删除 header 获得报文首部 options 对服务器预先请求告知 GET &#x2F; POST 区别 get产生的url地址可以被收藏，post不可以 get会被浏览器主动缓存，post不会，除非手动设置 get只能进行url编码，post支持多种编码方式 get参数会被完整保留在浏览器历史记录里，post参数不会保留 get在url中参数有长度限制2kb，post没有限制 参数的数据类型：get只接受ASCII字符，post没有限制 get参数直接暴露在url上，不能传递敏感信息 get通过url传递，post放在request body中 HTTP状态码1xx: 指示信息 - 请求已接收2xx: 成功 - 请求被成功接收 200 OK 206 Partiaml Content 客户端发送了一个带Range头多get请求，服务器完成了它(音频、视频应用) 3xx: 重定向 301 Moved Permanently 所请求的资源已经转移至新的url地址 302 Found 所请求的资源临时转移至新url地址 304 Not Modified 客户端有缓存的文档并发出了一个条件性请求，服务器告诉客户端原来缓存的资源文件可以继续使用 4xx: 客户端错误 400 Bad Request 客户端存在语法错误，服务器无法理解 401 Unauthorized 请求未授权 必须和www-Authenticate 报头域一起使用(JWT鉴权应用) 403 Forbidden 请求被禁止访问(只能通过服务器端访问) 404 Not Found 请求的资源不存在 5xx: 服务器错误 500 Internal server Error 服务器错误 503 Server Unavailable 请求未完成或服务器临时过载当机 HTTP持久连接HTTP协议采用“请求-应答”模式，每进行一次http连接就会断开TCP连接 Keep-Alive Keep-Alive 模式，只要有一方未明确表示断开连接则保持TCP连接状态，此功能避免重复建立连接 HTTP&#x2F;1.0 未标准化 HTTP&#x2F;1.1 版本默认支持 HTTP管线化在HTTP&#x2F;1.1 版本使用Keep-Alive 下可以使用管线化(pipelining)方式发送请求 123456789// 未使用管线化 单个请求req1 &gt; serverres1 &lt; serverreq2 &gt; serverres2 &lt; serverreq3 &gt; serverres3 &lt; server 12345678// 使用管线化 打包发送req1 &gt; serverreq2 &gt; serverreq3 &gt; serverres1 &lt; serverres2 &lt; serverres3 &lt; server 管线化只通过Keep-Alive 完成，http&#x2F;1.1 才支持 只有get 和head 方法请求才可以，post 有限制 初次创建连接不启动管线化机制，因为对方服务器不一定支持http&#x2F;1.1 管线化不会影响服务器响应顺序 http&#x2F;1.1 要求服务端支持管线化处理不失败即可 chrmoe firefox 默认未开启管线化支持，因为管线化功能不一定能带来性能提升，服务器支持也不好。 Cookie 维持客户端访问状态浏览器每次访问会携带cookie 信息，服务器可以设置cookie，通过这个特性可以创建带状态(session)的http 访问连接 123456// 客户端首次访问服务端client -----------无cookie------------&gt; serverclient &lt;-----set-cookie: sid=user1----- server// 客户端再次访问服务端client -----cookie: sid=user1---------&gt; serverclient &lt;--------确认是user1访问---------- server session 就是服务端手动维护每个客户端访问的cookie，可以维护在内存里也可以维护在redis 缓存中。","categories":[{"name":"Font-End Basis","slug":"Font-End-Basis","permalink":"http://yoursite.com/categories/Font-End-Basis/"}],"tags":[{"name":"http","slug":"http","permalink":"http://yoursite.com/tags/http/"}]},{"title":"前端基础重点回顾1:CSS盒模型、DOM、数据类型","slug":"前端基础重点回顾1:CSS盒模型、DOM、数据类型","date":"2018-01-22T13:42:52.000Z","updated":"2023-09-12T16:44:04.114Z","comments":true,"path":"2018/01/22/前端基础重点回顾1:CSS盒模型、DOM、数据类型/","link":"","permalink":"http://yoursite.com/2018/01/22/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E9%87%8D%E7%82%B9%E5%9B%9E%E9%A1%BE1:CSS%E7%9B%92%E6%A8%A1%E5%9E%8B%E3%80%81DOM%E3%80%81%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","excerpt":"","text":"CSS盒模型标准模型与IE模型的区别 计算高度宽度不同 标准盒模型的width 是以盒模型的content 来计算的IE盒模型的width 是以盒模型的border + padding + content 来计算的 CSS如何设置这两种模型 通过设置元素的box-sizing 属性 标准盒模型设置为box-sizing: content-boxIE盒模型设置为box-sizing: border-box JS如何设置获取盒模型对应的宽和高12// 获取内联样式dom.style.width / height 12// 获取渲染后的属性 IE 支持dom.currentStyle.width / height 12// 获取元素渲染后计算完毕的样式，所有浏览器支持window.getComputedStyle(dom).width / height 12// 计算元素的绝对位置dom.getBoundingClientRect().width / height dom.getBoundingClientRect() 函数不仅可以得到元素的宽高还能获得此元素在页面中的位置。[图片上传失败…(image-a1291e-1516628501105)] BFC什么是BFCBFC(block formatting context) 是一个块级格式化上下文，它形成了一个独立的布局环境。 怎么创建一个BFC1 设置float，值不为”none”2 设置overflow，值不为”visible”（hidden，auto，scroll）3 设置display的值为 “table-cell”, “table-caption”,或 “inline-block”4 设置position，值不为 “static” 或 “relative”（absolute，fixed） BFC 有什么特点1 BFC 元素内的各元素会在垂直方向上从顶部一个接一个的放置。2 BFC中的元素的布局是不受外界的影响,内外元素不会互相影响。3 BFC元素不会与浮动元素的区域重叠4 计算BFC元素高度的时候浮动元素也会参与计算 代码5 属于同一个BFC的两个相邻Box的margin会发生叠加 代码 BFC 的使用场景 解决margin叠加问题 代码 用于布局 代码 用于清除浮动 代码 DOMDOM事件的级别12// DOM0级el.onclick=function()&#123;&#125; 12// DOM2级el.addEventListenter(&#x27;click&#x27;, function()&#123;&#125;, &#x27;是否捕获阶段触发&#x27;: boolean) 12// DOM3级 区别DOM2级增加了更多的事件类型el.addEventListenter(&#x27;keyup&#x27;, function()&#123;&#125;, &#x27;是否捕获阶段触发&#x27;: boolean) DOM事件模型 事件捕获 事件冒泡 DOM事件流DOM事件流(event flow)三阶段 事件触发(触发元素) &#x3D;&gt; 事件捕获阶段(事件下传) &#x3D;&gt; 处于目标阶段(达到目标元素) &#x3D;&gt; 事件冒泡阶段(事件上传) 描述DOM事件捕获的具体流程12// IE 只有冒泡流程window =&gt; document =&gt; html(document.documentElement) =&gt; body =&gt; ... =&gt; 目标元素 如何自定义事件Event 对象1234567// 创建var event = new Event(&#x27;custome&#x27;)// 注册el.addEventListener(&#x27;custome&#x27;, function()&#123; console.log(&#x27;custome&#x27;)&#125;)el.dispatchEvent(event) // 触发 CustomEvent 对象123456var event = new CustomEvent(&#x27;build&#x27;, &#123; &#x27;detail&#x27;: elem.dataset.time &#125;);function eventHandler(e) &#123; console.log(&#x27;The time is: &#x27; + e.detail);&#125;el.addEventListener(&#x27;custome&#x27;, eventHandler)el.dispatchEvent(event) // 触发 Event对象的常见应用12345event.preventDefault() // 阻止默认event.stopPropagation() // 阻止冒泡event.stopImmediatePropagation() // 按钮绑定两个click，A点击时候不出发B，A会成功阻止B, 事件响应优先级event.target // 可以用于事件委托，由父级注册事件event.currentTarget currentTarget vs targettarget在事件流的目标阶段；currentTarget在事件流的捕获，目标及冒泡阶段。只有当事件流处在目标阶段的时候，两个的指向才是一样的， 而当处于捕获和冒泡阶段的时候，target指向被单击的对象而currentTarget指向当前事件活动的对象（一般为父级）。 类型转换 数据类型 原始类型 Boolean, String, Number, Null, Undefined, Symbol 复杂类型(对象) Object 显式类型转换Number函数 简单类型: 直接转换end复杂类型: valueOf() &#x3D;&gt; 简单类型 &#x3D;&gt; 直接转换end || 复杂类型 &#x3D;&gt; toString() &#x3D;&gt; 简单类型 &#x3D;&gt; 直接转换end String函数 简单类型: 直接转换end复杂类型: toString() &#x3D;&gt; 简单类型 &#x3D;&gt; 直接转换end || 复杂类型 &#x3D;&gt; valueOf() &#x3D;&gt; 简单类型 &#x3D;&gt; 直接转换end || 复杂类型error Boolean函数 \b 空字符串、Null、undefined、false、0 转化为false","categories":[{"name":"Font-End Basis","slug":"Font-End-Basis","permalink":"http://yoursite.com/categories/Font-End-Basis/"}],"tags":[{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"},{"name":"dom","slug":"dom","permalink":"http://yoursite.com/tags/dom/"}]},{"title":"Vue组件.sync修饰符","slug":"Vue组件-sync修饰符","date":"2018-01-22T05:09:11.000Z","updated":"2018-01-22T05:09:33.000Z","comments":true,"path":"2018/01/22/Vue组件-sync修饰符/","link":"","permalink":"http://yoursite.com/2018/01/22/Vue%E7%BB%84%E4%BB%B6-sync%E4%BF%AE%E9%A5%B0%E7%AC%A6/","excerpt":"","text":"12345&lt;div id=&quot;app&quot;&gt; &lt;div&gt;父组件bar: &#123;&#123;bar&#125;&#125;&lt;/div&gt; &lt;comp :foo.sync=&quot;bar&quot;&gt;&lt;/comp&gt; &lt;!-- &lt;comp :foo=&quot;bar&quot; @update:foo=&quot;val =&gt; bar = val&quot;&gt;&lt;/comp&gt; --&gt;&lt;/div&gt; 1234567891011121314151617&lt;script&gt;Vue.component(&#x27;comp&#x27;, &#123; template: &#x27;&lt;div&gt;&lt;button @click=&quot;increment&quot;&gt;点我更新子组件foo++&lt;/button&gt;&lt;div&gt;子组件foo: &#123;&#123;foo&#125;&#125;&lt;/div&gt;&lt;/div&gt;&#x27;, props: [&#x27;foo&#x27;], methods: &#123; increment: function() &#123; this.foo++; this.$emit(&#x27;update:foo&#x27;, this.foo); &#125; &#125;&#125;);new Vue(&#123; el: &#x27;#app&#x27;, data: &#123;bar: 0&#125;&#125;);&lt;/script&gt; :foo.sync=&quot;bar&quot; 实际就是 :foo=&quot;bar&quot; @update:foo=&quot;val =&gt; bar = val&quot; 的语法糖.sync demo","categories":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/tags/Vue/"}]},{"title":"CSS3总结","slug":"CSS3总结","date":"2018-01-22T05:07:54.000Z","updated":"2023-09-12T16:44:36.692Z","comments":true,"path":"2018/01/22/CSS3总结/","link":"","permalink":"http://yoursite.com/2018/01/22/CSS3%E6%80%BB%E7%BB%93/","excerpt":"","text":"##CSS3 calc() 计算属性 12width: calc(100% - 50px)calc内可以写 + - * / 运算符 记得留空格 ##CSS3效果的简单事例圆角， 圆形div 阴影2D 转换：放大、缩小、偏移、旋转3D 转换：移动、旋转背景色渐变过渡效果动画CSS3效果 ##全屏过渡效果全屏过渡 ##loading效果loading1loading2 本博客版权归 本人和饥人谷所有，转载需说明来源","categories":[{"name":"css","slug":"css","permalink":"http://yoursite.com/categories/css/"}],"tags":[{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"}]},{"title":"使用sftp操作远程服务器","slug":"使用sftp操作远程服务器","date":"2018-01-22T05:07:02.000Z","updated":"2018-01-22T05:07:27.000Z","comments":true,"path":"2018/01/22/使用sftp操作远程服务器/","link":"","permalink":"http://yoursite.com/2018/01/22/%E4%BD%BF%E7%94%A8sftp%E6%93%8D%E4%BD%9C%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8/","excerpt":"","text":"远程连接服务器12sftp user@xxx.xxx.xxxexit // 退出 与Bash相似的功能1234pwd // 查看当前路径ls ls -lacd 进行本地操作123lpwd // 查看本地路径llslcd 使用sftp传输文件12345678// 下载文件get remote_file_name// 下载重命名get remote_file_name local_file_name// 下载文件夹get -r some_directory_name// 下载并保持信息get -Pr some_directory_name 1234// 上传文件put local_file_name// 上传文件夹put -r local_directory_name 查看磁盘123df -h // 查看磁盘大小! // 切换本地使用bash命令exit // 返回远程服务器进行sftp操作 参考文章","categories":[{"name":"network","slug":"network","permalink":"http://yoursite.com/categories/network/"}],"tags":[{"name":"sftp","slug":"sftp","permalink":"http://yoursite.com/tags/sftp/"}]},{"title":"数组去重","slug":"数组去重","date":"2018-01-22T05:06:14.000Z","updated":"2018-01-22T05:06:38.000Z","comments":true,"path":"2018/01/22/数组去重/","link":"","permalink":"http://yoursite.com/2018/01/22/%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D/","excerpt":"","text":"基础类型数组去重1const arr = [1, 1, 2, 3, 3, 4, 5] ES5 123function unique(arr) &#123; return arr.filter((item, index, array) =&gt; array.indexOf(item) === index)&#125; ES6 12345678function unique (arr) &#123; const seen = new Map() return arr.filter((a) =&gt; !seen.has(a) &amp;&amp; seen.set(a, 1))&#125;// orfunction unique(array) &#123; return [...new Set(array)]&#125; 复杂类型数组去重1const array = [&#123;value: 1&#125;, &#123;value: 1&#125;, &#123;value: 2&#125;] ES5 1234function unique(arr) &#123; var obj = &#123;&#125; return arr.filter((item, index, array) =&gt; !obj.hasOwnProperty(JSON.stringify(item)) &amp;&amp; (obj[JSON.stringify(item)] = true))&#125; ES6 1234function unique (arr) &#123; const seen = new Map() return arr.filter((a) =&gt; !seen.has(JSON.stringify(a)) &amp;&amp; seen.set(JSON.stringify(a), 1))&#125;","categories":[{"name":"Font-End Basis","slug":"Font-End-Basis","permalink":"http://yoursite.com/categories/Font-End-Basis/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"Vue生命周期","slug":"Vue生命周期","date":"2018-01-22T05:05:18.000Z","updated":"2023-09-12T16:44:14.530Z","comments":true,"path":"2018/01/22/Vue生命周期/","link":"","permalink":"http://yoursite.com/2018/01/22/Vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/","excerpt":"","text":"vue里的生命周期是什么？vue实例从创建到销毁的过程称之为vue的生命周期 vue的生命周期各阶段都做了什么？beforeCreate 实例创建前：这个阶段实例的data、methods是读不到的created 实例创建后：这个阶段已经完成了数据观测(data observer)，属性和方法的运算， watch&#x2F;event 事件回调。mount挂载阶段还没开始，$el 属性目前不可见，数据并没有在DOM元素上进行渲染beforeMount：在挂载开始之前被调用：相关的 render 函数首次被调用。mounted：el选项的DOM节点 被新创建的 vm.$el 替换，并挂载到实例上去之后调用此生命周期函数。此时实例的数据在DOM节点上进行渲染beforeUpdate：数据更新时调用，但不进行DOM重新渲染，在数据更新时DOM没渲染前可以在这个生命函数里进行状态处理updated：这个状态下数据更新并且DOM重新渲染，当这个生命周期函数被调用时，组件 DOM 已经更新，所以你现在可以执行依赖于 DOM 的操作。当实例每次进行数据更新时updated都会执行beforeDestory：实例销毁之前调用。destroyed：Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。 vue生命周期在真实场景下的业务应用created：进行ajax请求异步数据的获取、初始化数据mounted：挂载元素内dom节点的获取nextTick：针对单一事件更新数据后立即操作domupdated：任何数据的更新，如果要做统一的业务逻辑处理watch：监听具体数据变化，并做相应的处理","categories":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/tags/Vue/"}]},{"title":"Vue.nextTick的实现","slug":"Vue-nextTick的实现","date":"2018-01-22T05:04:21.000Z","updated":"2018-01-22T05:04:51.000Z","comments":true,"path":"2018/01/22/Vue-nextTick的实现/","link":"","permalink":"http://yoursite.com/2018/01/22/Vue-nextTick%E7%9A%84%E5%AE%9E%E7%8E%B0/","excerpt":"","text":"这是一篇继event loop和MicroTask 后的vue.nextTick API实现的源码解析。 预热，写一个sleep函数123456789function sleep (ms) &#123; return new Promise(resolve =&gt; setTimeout(resolve, ms)&#125;async function oneTick (ms) &#123; console.log(&#x27;start&#x27;) await sleep(ms) console.log(&#x27;end&#x27;)&#125;oneTick(3000) 解释下sleep函数async 函数进行await PromiseFn()时函数执行是暂停的，我们也知道现在这个PromiseFn是在microTask内执行。当microTask没执行完毕时，后面的macroTask是不会执行的，我们也就通过microTask在event loop的特性实现了一个sleep函数，阻止了console.log的执行 流程1执行console.log(‘start’)2执行await 执行暂停，等待await函数后的PromiseFn在microTask执行完毕3在sleep函数内，延迟ms返回4返回resolve后执行console.log(‘end’) nextTick API vue中nextTick的使用方法 123vue.nextTick(() =&gt; &#123; // todo...&#125;) 了解用法后看一下源码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263const nextTick = (function () &#123; const callbacks = [] let pending = false let timerFunc // 定时函数 function nextTickHandler () &#123; pending = false const copies = callbacks.slice(0) // 复制 callbacks.length = 0 // 清空 for (let i = 0; i &lt; copies.length; i++) &#123; copies[i]() // 逐个执行 &#125; &#125; if (typeof Promise !== &#x27;undefined&#x27; &amp;&amp; isNative(Promise)) &#123; var p = Promise.resolve() var logError = err =&gt; &#123; console.error(err) &#125; timerFunc = () =&gt; &#123; p.then(nextTickHandler).catch(logError) // 重点 &#125; &#125; else if (&#x27;!isIE MutationObserver&#x27;) &#123; var counter = 1 var observer = new MutationObserver(nextTickHandler) // 重点 var textNode = document.createTextNode(string(conter)) observer.observe(textNode, &#123; characterData: true &#125;) timerFunc = () =&gt; &#123; counter = (counter + 1) % 2 textNode.data = String(counter) &#125; &#125; else &#123; timerFunc = () =&gt; &#123; setTimeout(nextTickHandler, 0) // 重点 &#125; &#125; return function queueNextTick (cb, ctx) &#123; // api的使用方式 let _resolve callbacks.push(() =&gt; &#123; if (cb) &#123; try &#123; cb.call(ctx) &#125; catch (e) &#123; err &#125; &#125; else if (_resolve) &#123; _resolve(ctx) &#125; &#125;) if (!pending) &#123; pending = true timerFunc() &#125; if (!cb &amp;&amp; typeof Promise !== &#x27;undefined&#x27;) &#123; return new Promise((resolve, reject) =&gt; &#123; _resolve =resolve &#125;) &#125; &#125;&#125;)() // 自执行函数 大致看一下源码可以了解到nextTick api是一个自执行函数既然是自执行函数，直接看它的return类型，return function queueNextTick (cb, ctx) {…} 1234567891011121314151617181920212223return function queueNextTick (cb, ctx) &#123; // api的使用方式 let _resolve callbacks.push(() =&gt; &#123; if (cb) &#123; try &#123; cb.call(ctx) &#125; catch (e) &#123; err &#125; &#125; else if (_resolve) &#123; _resolve(ctx) &#125; &#125;) if (!pending) &#123; pending = true timerFunc() &#125; if (!cb &amp;&amp; typeof Promise !== &#x27;undefined&#x27;) &#123; return new Promise((resolve, reject) =&gt; &#123; _resolve =resolve &#125;) &#125; &#125; 只关注主流程queueNextTick函数把我们传入的() &#x3D;&gt; { &#x2F;&#x2F; todo… } 推入了callbacks内 1234567891011121314151617181920212223if (typeof Promise !== &#x27;undefined&#x27; &amp;&amp; isNative(Promise)) &#123; var p = Promise.resolve() var logError = err =&gt; &#123; console.error(err) &#125; timerFunc = () =&gt; &#123; p.then(nextTickHandler).catch(logError) // 重点 &#125;&#125; else if (&#x27;!isIE MutationObserver&#x27;) &#123; var counter = 1 var observer = new MutationObserver(nextTickHandler) // 重点 var textNode = document.createTextNode(string(conter)) observer.observe(textNode, &#123; characterData: true &#125;) timerFunc = () =&gt; &#123; counter = (counter + 1) % 2 textNode.data = String(counter) &#125;&#125; else &#123; timerFunc = () =&gt; &#123; setTimeout(nextTickHandler, 0) // 重点 &#125;&#125; 这一段我们可以看到标注的三个点表明在不同浏览器环境下使用Promise, MutationObserver或setTimeout(fn, 0) 来执行nextTickHandler 1234567891011121314function nextTickHandler () &#123; pending = false const copies = callbacks.slice(0) // 复制 callbacks.length = 0 // 清空 for (let i = 0; i &lt; copies.length; i++) &#123; copies[i]() // 逐个执行 &#125; &#125;``` nextTickHandler就是把我们之前放入callbacks的 () =&gt; &#123; // todo... &#125; 在当前tasks内执行。## 写一个简单的nextTick源码可能比较绕，我们自己写一段简单的nextTick const simpleNextTick &#x3D; (function () { let callbacks &#x3D; [] let timerFunc return function queueNextTick (cb) { callbacks.push(() &#x3D;&gt; { &#x2F;&#x2F; 给callbacks 推入cb() cb() }) timerFunc = () =&gt; &#123; return Promise.resolve().then(() =&gt; &#123; const fn = callbacks.shift() fn() &#125;) &#125; timerFunc() // 执行timerFunc，返回到是一个Promise }})() simpleNextTick(() &#x3D;&gt; { setTimeout(console.log, 3000, ‘nextTick’)}) 123我们可以从这里看出nextTick的原理就是返回出一个Promise，而我们todo的代码在这个Promise中执行，现在我们还可以继续简化 const simpleNextTick &#x3D; (function () { return function queueNextTick (cb) { timerFunc &#x3D; () &#x3D;&gt; { return Promise.resolve().then(() &#x3D;&gt; { cb() }) } timerFunc() }})() simpleNextTick(() &#x3D;&gt; { setTimeout(console.log, 3000, ‘nextTick’)}) 123直接写成这样。 const simpleNextTick &#x3D; function queueNextTick (cb) { timerFunc &#x3D; () &#x3D;&gt; { return Promise.resolve().then(() &#x3D;&gt; { cb() }) } timerFunc() } simpleNextTick(() &#x3D;&gt; { setTimeout(console.log, 3000, ‘nextTick’)}) 123这次我们把自执行函数也简化掉 const simpleNextTick &#x3D; function queueNextTick (cb) { return Promise.resolve().then(cb) } simpleNextTick(() &#x3D;&gt; { setTimeout(console.log, 3000, ‘nextTick’)}) 12345现在我们直接简化到最后，现在发现nextTick最核心的内容就是Promise，一个microtask。现在我们回到vue的nextTick API官方示例 var vm = new Vue({ el: '#example', data: { message: '123' } }) vm.message = 'new message' // 更改数据 vm.$el.textContent === 'new message' // false Vue.nextTick(function () { vm.$el.textContent === 'new message' // true }) 1234567原来在vue内数据的更新后dom更新是要在下一个事件循环后执行的。nextTick的使用原则主要就是解决单一事件更新数据后立即操作dom的场景。既然我们知道了nextTick核心是利用microTasks，那么我们把简化过的nextTick和开头的sleep函数对照一下。 const simpleNextTick = function queueNextTick (cb) { return Promise.resolve().then(cb) } simpleNextTick(() &#x3D;&gt; { setTimeout(console.log, 3000, ‘nextTick’) &#x2F;&#x2F; 也可以换成ajax请求}) 12345678910```function sleep (ms) &#123; return new Promise(resolve =&gt; setTimeout(resolve, ms) // 也可以换成ajax请求&#125;async function oneTick (ms) &#123; console.log(&#x27;start&#x27;) await sleep(ms) console.log(&#x27;end&#x27;)&#125;oneTick(3000) 我们看出nextTick和我么写的oneTick的执行结果是那么的相似。区别只在于nextTick是把callback包裹一个Promise返回并执行，而oneTick是用await执行一个Promise函数，而这个Promise有自己包裹的webapi函数。 那在用ajax请求的时候我们是不是直接这样使用axios可以返回Promise的库 12345async function getData () &#123; const data = await axios.get(url) // 操作data的数据来改变dom return data&#125; 这样也可以达到同nextTick同样的作用 最后我们也可以从源码中看出，当浏览器环境不支持Promise时可以使用MutationObserver或setTimeout(cb, 0) 来达到同样的效果。但最终的核心是microTask","categories":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/tags/Vue/"}]},{"title":"继异步编程的async/await函数补充","slug":"继异步编程的async-await函数补充","date":"2018-01-22T05:01:48.000Z","updated":"2023-09-12T16:43:27.082Z","comments":true,"path":"2018/01/22/继异步编程的async-await函数补充/","link":"","permalink":"http://yoursite.com/2018/01/22/%E7%BB%A7%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E7%9A%84async-await%E5%87%BD%E6%95%B0%E8%A1%A5%E5%85%85/","excerpt":"","text":"这个执行函数顺序的问题是继之前EventLoop 和 MicroTask的文章的补充 1234567891011121314151617181920async function async1() &#123; console.log(&#x27;async1 start&#x27;); // 问题1 async1 start 在script 里执行是什么样的 await async2(); // 问题2 为什么async2 在promise1 前执行 console.log(&#x27;async1 end&#x27;); // 问题3 为什么async1 end 会在 promise2 后执行&#125;async function async2() &#123; console.log(&#x27;async2&#x27;);&#125;console.log(&#x27;script start&#x27;);setTimeout(function() &#123; console.log(&#x27;setTimeout&#x27;);&#125;, 0);async1();new Promise(function(resolve) &#123; console.log(&#x27;promise1&#x27;); resolve(); &#125;).then(function() &#123; console.log(&#x27;promise2&#x27;); &#125;);console.log(&#x27;script end&#x27;); 执行结果 1234567891. script start2. async1 start3. async24. promise15. script end6. promise27. async1 end// stack 清空8. setTimeout 问题1 async1 start 在script 里执行是什么样的?先看下async 函数 babel 后样子 可以看出async 函数只是执行了_asyncToGenerator 这个函数, 再看下_asyncToGenerator 原来_asyncToGenerator 函数只是返回了一个 new Promise()，async1() 的执行也就是在script 里执行里一个new Promise() 问题2 为什么async2 在promise1 前执行从问题1可以知道async2 () 也是一个new Promise() ，不过async2() 多了一个aiwait，看下mdn 的描述 await 表达式会暂停当前 async function 的执行，等待 Promise 处理完成。若 Promise 正常处理(fulfilled)，其处理结果作为 await 表达式的值，继续执行 async function。 再看一下babel 后的babel 后只不过前面多了yield，await async()变成了yield new Promise()，\byield 是一个暂停执行的标记而后面的语句是已经执行完了，async2 也就先于promise1 在script 中执行。 问题3 为什么async1 end 会在 promise2 后执行这里引用阮一峰的对Generator-函数异步应用的解释 传统的编程语言，早有异步编程的解决方案（其实是多任务的解决方案）。其中有一种叫做”协程”（coroutine），意思是多个线程互相协作，完成异步任务。协程有点像函数，又有点像线程。它的运行流程大致如下。第一步，协程A开始执行。第二步，协程A执行到一半，进入暂停，执行权转移到协程B。第三步，（一段时间后）协程B交还执行权。第四步，协程A恢复执行。上面流程的协程A，就是异步任务，因为它分成两段（或多段）执行。 这里的async1 end 与 promise2 的执行就是因为yield 的“协程”，我们这里改写一下问题，让问题更清晰 1234567891011121314151617181920async function async1() &#123; console.log(&#x27;async1 start&#x27;); new Promise(function(resolve) &#123; // 我们把new Promise 放到async1内部 console.log(&#x27;promise1&#x27;); resolve(); &#125;).then(function() &#123; // await 通过yield 协程的功能 把上下两段分割 console.log(&#x27;promise2&#x27;); &#125;); await async2(); // yield 协程分割，但是async2 先执行完毕 console.log(&#x27;async1 end&#x27;); // await 通过yield 协程的功能 把上下两段分割&#125;async function async2() &#123; console.log(&#x27;async2&#x27;);&#125;console.log(&#x27;script start&#x27;);setTimeout(function() &#123; console.log(&#x27;setTimeout&#x27;);&#125;, 0);async1();console.log(&#x27;script end&#x27;); 从上面的改写看出await async2 通过协程把上promise2 和 async1 end 分割成两部分，这里将会把上半部分的microtask 的任务都执行完毕才会执行下一段的代码。 这段代码的执行顺序不仅考察了异步执行主要考察了对async &#x2F; await 函数的降级理解，了解到这一层后发现async &#x2F; await 函数确实是js 异步执行的好方式。 babel编译","categories":[{"name":"Font-End Basis","slug":"Font-End-Basis","permalink":"http://yoursite.com/categories/Font-End-Basis/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"EventLoop事件循环中的 MacroTask与 MicroTask","slug":"EventLoop事件循环中的 MacroTask与 MicroTask","date":"2018-01-22T04:34:47.000Z","updated":"2023-09-12T16:44:32.531Z","comments":true,"path":"2018/01/22/EventLoop事件循环中的 MacroTask与 MicroTask/","link":"","permalink":"http://yoursite.com/2018/01/22/EventLoop%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E4%B8%AD%E7%9A%84%20MacroTask%E4%B8%8E%20MicroTask/","excerpt":"","text":"问题来源在学习Promise时在stackoverflow上看到一个解释Promise运行顺序回答。之前在学习异步编程中讲解了MacroTask和MicroTask， 但在最近深入EventLoop后又有了更多的了解 EventLoop、MacroTask、MicroTask之间的关系 macrotasks 与 microtasks 各自的 APImacrotasks: setTimeout, setInterval, setImmediate, requestAnimationFrame, I&#x2F;O, UI renderingmicrotasks: process.nextTick, Promises, Object.observe, MutationObserver 一张图先了解microtasks 与macrotasks 在eventloop队列里的位置这里用了上一章EventLoop 事件循环文章里的图，并在回调队列里标注里microtask的位置。 microtasks 与macrotasks 在eventloop 里的流程在没有引入microtasks 概念前事件循环是这样执行的 123while (queue是否有task) &#123; 执行task&#125; 引入microtasks 概念后 1234while (queue是否有macrotasks) &#123; if (microtasks) 执行空microtasks 再执行macrotasks&#125; microtasks 与macrotasks 在eventloop 里实际执行结果1234567891011121314// 例1console.log(&#x27;script start&#x27;);setTimeout(function() &#123; console.log(&#x27;setTimeout&#x27;);&#125;, 0);Promise.resolve().then(function() &#123; console.log(&#x27;promise1&#x27;);&#125;).then(function() &#123; console.log(&#x27;promise2&#x27;);&#125;);console.log(&#x27;script end&#x27;); 12345678// 结果script startscript endpromise1promise2setTimeout// 当前循环结束// 进入下一个循环 从webapi在Eventloop的执行环境我们可以知道setTimeout在当前事件循环中将会在script end后执行，这是没问题的。而promise作为microtasks将会在当前事件循环内的macrotasks之前执行完毕。setTimeout作为macrotasks在例1中是最后执行的。 12345678910111213141516171819例2setImmediate(function()&#123; console.log(1);&#125;,0);setTimeout(function()&#123; console.log(2);&#125;,0);new Promise(function(resolve)&#123; console.log(3); resolve(); console.log(4);&#125;).then(function()&#123; console.log(5);&#125;);console.log(6);process.nextTick(function()&#123; console.log(7);&#125;);console.log(8); 12// 执行顺序3 4 6 8 7 5 2 1 例2process.nextTick在node环境中，属于microtasksetImmediate在macrotasks，优先级小于setTimeout定义new Promise() 是同步代码，在栈内先执行 1234567891011121314151617181920212223242526例3const p = new Promise((res, rej) =&gt; &#123; res(1) console.log(&#x27;定义new Promise - 同步&#x27;)&#125;).then(val =&gt; &#123; console.log(&#x27;microtask start&#x27;) console.log(&#x27;执行then，enqueue micarotask 1&#x27;) console.log(val) // 1&#125;)Promise.resolve(&#123; then(res, rej) &#123; console.log(&#x27;执行then，enqueue micarotask 2&#x27;) res(5) &#125;&#125;).then(val =&gt; &#123; console.log(&#x27;执行then，enqueue micarotask 3&#x27;) console.log(val) // 5&#125;)console.log(&#x27;逐行执行1 - 同步&#x27;)console.log(&#x27;逐行执行2 - 同步&#x27;)console.log(3) // 3setTimeout(console.log, 0, &#x27;macrotask start&#x27;) // 4 setTimeout(console.log, 0, 4) // 4 执行结果如下1234567891011121314151617定义new Promise - 同步逐行执行1 - 同步逐行执行2 - 同步3// 同步队列执行完毕为空 进入下一个栈microtask start执行then，enqueue micarotask 11执行then，enqueue micarotask 2执行then，enqueue micarotask 35// microtask执行完毕为空 进入下一个栈macrotask start4// macrotask执行完毕为空 结束 例3定义new Promise是同步函数Promise.resolve等api为异步micarotask 123456789101112131415161718192021222324252627282930例4&lt;div class=&quot;outer&quot;&gt; &lt;div class=&quot;inner&quot;&gt;&lt;/div&gt;&lt;/div&gt;var outer = document.querySelector(&#x27;.outer&#x27;);var inner = document.querySelector(&#x27;.inner&#x27;);new MutationObserver(function() &#123; console.log(&#x27;mutate&#x27;);&#125;).observe(outer, &#123; attributes: true&#125;);function onClick() &#123; console.log(&#x27;click&#x27;); setTimeout(function() &#123; console.log(&#x27;timeout&#x27;); &#125;, 0); Promise.resolve().then(function() &#123; console.log(&#x27;promise&#x27;); &#125;); outer.setAttribute(&#x27;data-random&#x27;, Math.random());&#125;inner.addEventListener(&#x27;click&#x27;, onClick);outer.addEventListener(&#x27;click&#x27;, onClick); 123456789// 同时点击到两个div时执行结果clickpromisemutateclickpromisemutatetimeouttimeout 例4执行效果没点击前：1绑定new MutationObserver 存入浏览器资源2绑定两个div元素的click事件 存入浏览器资源 3触发outer元素click的onClick 存入浏览器资源4触发inner元素click的onClick 存入浏览器资源5先执行outer的回调6输出click7执行setTimeout - macrotask存入浏览器资源8执行outer.setAttribute(‘data-random’, Math.random())，触发MutationObserver - marcotask 等待microtask先执行9执行Promise.resolve - microtask 输出promise10microtask 执行完毕，执行MutationObserver输出mutate—–下面执行的并不是outer回调里的setTimeout——11执行inner的回调12输出inner回调的click13执行inner回调的setTimeout - macrotask存入浏览器资源14执行inner回调outer.setAttribute(‘data-random’, Math.random())，触发MutationObserver - marcotask 等待microtask先执行15执行inner回调的Promise.resolve - microtask 输出promise16microtask 执行完毕，执行MutationObserver输出mutate–最后因为两个setTimeout都是在触发inner回调后存入浏览器资源的–所以最后两个setTimeout回调完成排入队列执行.","categories":[{"name":"Font-End Basis","slug":"Font-End-Basis","permalink":"http://yoursite.com/categories/Font-End-Basis/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"Event Loop 事件循环","slug":"Event Loop 事件循环","date":"2018-01-22T04:32:59.000Z","updated":"2023-09-13T14:33:16.233Z","comments":true,"path":"2018/01/22/Event Loop 事件循环/","link":"","permalink":"http://yoursite.com/2018/01/22/Event%20Loop%20%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/","excerpt":"","text":"名词解释 “event-loop”: 事件循环“non-blocking”: 非堵塞“callback”: 回调函数“asynchronous”: 异步“single-threaded”: 单线程“concurrency”: 并发“web-api”: DOM, ajax, setTimeout… JS在浏览器中的环境先看一张图 图片出自: https://www.youtube.com/watch?v=6MXRNXXgP_0 V8引擎内的JS根据上图，首先可以得到的JS在V8引擎中有一个堆(heap)和栈(stack)的概念堆(heap): 对象被分配的区域栈(stack): 函数调用形成的栈帧 问题1: 执行JS时候发生了什么代码1 12345678910111213var a, bfunction foo () &#123; return a +=1&#125;function bar () &#123; return b += 2&#125;function baz () &#123; bar () foo () console.log( a + b )&#125;baz() 解释1 栈内：1执行baz() 进入栈2执行bar() 进入栈 - bar() return 退出栈3执行foo() 进入栈 - foo() return 退出栈4执行console.log 进入栈 无return并退出栈5baz() 执行完毕退出栈 JS操作WebApi根据图中WebApi所在的位置我们发现它并没有在V8引擎内，而是由stack内执行后再V8资源外层出现然后进入回调队列，并进行了一次event loop的事件 问题2: JS操作WebApi发生了什么?WebApi的执行不在V8内那在哪里?代码2 12345console.log(&#x27;hi&#x27;)setTimeout(function () &#123; console.log(&#x27;ha&#x27;)&#125;, 5000)console.log(&#x27;heng&#x27;) 解释2 栈内:1执行console.log(‘hi’) 进入栈 - 退出栈2执行setTimout 进入栈 - 把回调函数cb放入浏览器资源内(相对V8) - 退出栈3执行console.log(‘heng’)进入栈 - 退出栈4当前栈清空当前事件循环(event loop)结束 栈外:5通过while(queue.length)不停的检查队列(queue)是否为空6存放在浏览器资源内的setTimeout回调cb在5秒完成后进入队列(queue)7事件循环while(queue.length)检查到队列(queue)有回调cb8在当前循环内把cb推入栈内 栈内:9执行cb，console.log(‘ha’)进入栈 - 退出栈10清空栈 问题3: 如果setTimeout(cb, 0) 会是什么情况?代码3 12345console.log(&#x27;hi&#x27;)setTimeout(function () &#123; console.log(&#x27;ha&#x27;)&#125;, 0)console.log(&#x27;heng&#x27;) 解释3 同解释2，但是再第6步: 存放在浏览器资源内的setTimeout回调cb在5秒完成后进入队列(queue)应该变为cb直接进入队列(queue) 问题4: ajax是什么情况?代码4 12345console.log(&#x27;hi&#x27;)$.get(url, function (data) &#123; console.log(data)&#125;)console.log(&#x27;heng&#x27;) 解释4 同解释2，但是再第6步: 存放在浏览器资源内的setTimeout回调cb在5秒完成后进入队列(queue)应该变为ajax取得数据后cb进入队列()所以这也解释了为什么使用setTimeout来模拟ajax 问题5: WebApi中Event事件是什么情况？代码5 12345678console.log(&#x27;start&#x27;)$el.on(&#x27;click&#x27;, function fn() &#123; console.log(&#x27;clicked&#x27;)&#125;)setTimeout(function cb() &#123; console.log(&#x27;timeout&#x27;)&#125;, 5000)console.log(&#x27;done&#x27;) 解释5 栈内:1执行console.log(‘start’)进入栈 - 退出栈2执行$el.on(‘click’)进入栈 - 整个click事件包括回调函数fn放入浏览器资源内 - 退出栈3执行setTImeout 进入栈 - 把回调函数cb放入浏览器资源内 - 退出栈4执行console.log(‘done’)进入栈 - 退出栈 栈外:5通过while(queue.length)不停的检查队列(queue)是否为空6存放在浏览器资源内的setTimeout回调cb在5秒完成后进入队列(queue)7事件循环while(queue.length)检查到队列(queue)有回调cb8在当前循环内把cb推入栈内 栈内:9执行cb，console.log(‘ha’)进入栈 - 退出栈10清空栈 浏览器中:11用户点击$el触发’click’ 事件，回调函数fn进入队列中12事件循环while(queue.length)检查到队列(queue)有回调fn13在当前循环内把fn推入栈内执行并清空 问题6 - 列表滚动优化与Debounce去抖函数从问题5中可以知道，当我们连续不停的点击$el触发click时，队列(queue)内将会排满回调函数，这就是页面造成卡顿的原因。造成这种情况出现最多的就是列表滚动scroll事件, 窗口resize事件。常用的优化方法就是使用debounce去抖函数, 先看一下他的实现方法: 1234567891011function debounce(fn, delay) &#123; var timer return function() &#123; var context = this var args = arguments clearTimeout(timer) timer = setTimeout(function() &#123; fn.apply(context, args) &#125;, delay) &#125;&#125; 分析debouncedebounce函数里有一个重点，就是clearTimeout(timer)现在模拟一个绑定事件 1234document.addEventListener(&#x27;scroll&#x27;, debounce(function() &#123; console.log(&#x27;scroll&#x27;)&#125;, 1000), false); 当scroll事件在栈内执行回调函数被注册到浏览器资源后，当我们触发scroll事件时，我们都会把debounce(function()&#123;console.log(&#39;scroll&#39;)&#125;, 1000)排到队列(queue)里，在通过事件循环放入栈内执行。 如果1秒内只触发1次，那么debounce函数的回调就会因为内部的setTimeout放入浏览器资源等到1秒到后排如队列内在推入栈内执行。\b 但1秒内我们不停的触发scroll事件呢，那么debounce函数内部的clearTimeout(timer)将起到关键作用: 把前一次触发scroll事件放入浏览器资源的setTimeout回调给清空掉并放入新的setTimeout回调直到最后一次触发scroll，把浏览器资源内的setTimeout回调都清空只留下最后一个，等待1秒后回调排入队列(queue)等待推入栈内执行。 此方法相比问题5中的情况大大减少了浏览器资源的占用，使得在固定时间内队列(queue)内都只有一个回调在等待而不是一大堆。 异步执行12345678910代码1[1,2,3,4].forEach(function (i) &#123; console.log(i)&#125;)代码2[1,2,3,4].forEach(function (i) &#123; setTimeout(function (i) &#123; console.log(i) &#125;, 0, i)&#125;) 分析代码1中打印1，2，3，4 很明显它们都是直接在栈内执行console.log()输出的代码2页打印相同的结果，但是不同的是每次console.log的执行都是通过setTImeout放入队列(queue)内再推入栈内执行的，这就通过浏览器资源和V8资源的区别实现了一段异步执行的代码我们可以第二段代码改写成这样, 制作一个异步执行的forEach 12345678function asyncForEach(arr, cb) &#123; arr.forEach(function (i) &#123; setTimeout(cb, 0, i) &#125;)&#125;asyncForEach([1,2,3,4], function(i) &#123; console.log(i)&#125;)","categories":[{"name":"Font-End Basis","slug":"Font-End-Basis","permalink":"http://yoursite.com/categories/Font-End-Basis/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"http 缓存","slug":"http缓存","date":"2018-01-22T04:27:35.000Z","updated":"2023-09-12T16:54:43.911Z","comments":true,"path":"2018/01/22/http缓存/","link":"","permalink":"http://yoursite.com/2018/01/22/http%E7%BC%93%E5%AD%98/","excerpt":"","text":"4种缓存方式HTTP缓存控制参考 分类和区别规定了过期时间： 响应header 描述 常用响应返回内容 推荐 特点 缺点 场景 Cache-Control 在多少秒内进行缓存 public, max-age&#x3D;秒 是 固定时间 Expires 在此时间前进行缓存 格林威治时间 否 绝对时间 受客户端时间影响 兼容http1.0 需进行比较，会返回304状态码： 响应header 请求header 描述 常用响应返回内容 推荐 特点 缺点 场景 ETag If-None-Match 固定字符串 md5 是 检测文件完整性 Last-Modified If-Modified-Since 在某时间后没再更改 格林威治时间 否 浏览器根据返回的时间自己决定缓存 浏览器差异 Tips：Cache-Control与Expires一样，都是在某个时间未到来前进行缓存默认第一个请求(主页)的请求头里会自动加上Cache-Control: max-age=0，这个请求无论响应头的Cache-Control是什么设置都不会缓存，减少请求次数同时减少下载次数ETag方式通过检查request.headers里的if-None-Match里的32位md5字符串来检测文件完整性决定是否更新, 如果md5匹配成功则返回304，只减少下载次数 Cache-Control 与 Last-Modified &#x2F; if-Modified-Since 比较 对于所有可以缓存的资源都可以同时使用这两种策略进行缓存Cache-Control&#x2F;Expires的优先级要高于Last-Modified&#x2F;ETag Cache-Control:1设置固定过期时间2文件在过期时间没到之前都不进行请求也不进行下载更新3解决方法只能通过加时间戳改变文件名解决 Last-Modified &#x2F; if-Modified-Since:1通过给文件内容进行哈希算法来确定文件内容版本2通过对请求头if-Modified-Since的字符串来检测文件内容有没改变3文件内容没改变则不更新资源，跟请求资源的文件名关系不大但每次都需要请求4可以通过标识文件版本名、加长缓存时间的方式来减少304响应。 结论 1需要兼容HTTP1.0的时候需要使用Expires，不然可以考虑直接使用Cache-Control2需要处理一秒内多次修改的情况，或者其他Last-Modified处理不了的情况，才使用ETag，否则使用Last-Modified。3对于所有可缓存资源，需要指定一个Expires或Cache-Control，同时指定Last-Modified或者Etag。4可以通过标识文件版本名、加长缓存时间的方式来减少304响应。HTTP缓存控制参考 MD5hash算法任何文件或数据都可以通过MD5算法转化成一个32位的固定字符串场景：1检查缓存的文件内容是否有变化2检查下载文件是否下载完毕(cat xxx.mp4 | md5)","categories":[{"name":"http","slug":"http","permalink":"http://yoursite.com/categories/http/"}],"tags":[{"name":"http","slug":"http","permalink":"http://yoursite.com/tags/http/"}]},{"title":"flex布局","slug":"flex","date":"2018-01-22T04:02:11.000Z","updated":"2023-09-12T16:44:11.418Z","comments":true,"path":"2018/01/22/flex/","link":"","permalink":"http://yoursite.com/2018/01/22/flex/","excerpt":"","text":"flex之前 文档流布局 float + clear 相对定位 + 绝对定位 display inline-block 负margin flex特点 布局与方向无关 空间自动分配、自动对齐 适用于简单的线性布局 基本概念基本flex flex container的六个属性(父元素) 在下面demo的父元素里审查元素加上各种属性试试1flex-direction2flex-wrap &amp; flex-direction3缩写flex-flow: [direction] [wrap] 4justify-content5align-items6align-content flex item的六个属性1flex-grow2flex-shrink3flex-basis4缩写flex: [grow] [shrink] [basis]5order6align-self demo1手机页面布局topbar+main+tabs上下固定2产品列表ul&gt;li*9抛弃负margin3PC页面布局中间自适应抛弃双飞翼4完美居中 参考css-tricksflex布局-阮一峰","categories":[{"name":"css","slug":"css","permalink":"http://yoursite.com/categories/css/"}],"tags":[{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"}]},{"title":"Hello World","slug":"hello-world","date":"2018-01-21T14:02:59.000Z","updated":"2018-01-21T14:02:59.000Z","comments":true,"path":"2018/01/21/hello-world/","link":"","permalink":"http://yoursite.com/2018/01/21/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"react","slug":"react","permalink":"http://yoursite.com/categories/react/"},{"name":"http","slug":"http","permalink":"http://yoursite.com/categories/http/"},{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/categories/webpack/"},{"name":"nodejs","slug":"nodejs","permalink":"http://yoursite.com/categories/nodejs/"},{"name":"React","slug":"React","permalink":"http://yoursite.com/categories/React/"},{"name":"Font-End Basis","slug":"Font-End-Basis","permalink":"http://yoursite.com/categories/Font-End-Basis/"},{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/categories/Vue/"},{"name":"css","slug":"css","permalink":"http://yoursite.com/categories/css/"},{"name":"network","slug":"network","permalink":"http://yoursite.com/categories/network/"}],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"},{"name":"http","slug":"http","permalink":"http://yoursite.com/tags/http/"},{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/tags/webpack/"},{"name":"nodejs","slug":"nodejs","permalink":"http://yoursite.com/tags/nodejs/"},{"name":"React","slug":"React","permalink":"http://yoursite.com/tags/React/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/tags/Vue/"},{"name":"Redux","slug":"Redux","permalink":"http://yoursite.com/tags/Redux/"},{"name":"React Tips","slug":"React-Tips","permalink":"http://yoursite.com/tags/React-Tips/"},{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"},{"name":"dom","slug":"dom","permalink":"http://yoursite.com/tags/dom/"},{"name":"sftp","slug":"sftp","permalink":"http://yoursite.com/tags/sftp/"}]}
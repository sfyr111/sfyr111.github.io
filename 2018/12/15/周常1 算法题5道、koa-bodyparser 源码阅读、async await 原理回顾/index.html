<!doctype html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge">
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    
    <title>周常1 算法题5道、koa-bodyparser 源码阅读、async / await 原理回顾 | Minimalist</title>
    
    <link rel="alternative" href="/atom.xml" title="Minimalist" type="application/atom+xml">
    
    
<link rel="stylesheet" href="/css/style.css">

    
    <link rel="stylesheet" href="/libs/fancybox/jquery.fancybox.css" charset="utf-8">
    
    <!--[if lt IE 9]>
    <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
    <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
<meta name="generator" content="Hexo 6.3.0"></head>
<body class="site">
    <header class="site-header">
        <h1 class="site-title"><a href="/">Minimalist</a></h1>
        <nav class="site-nav">
            <ul class="nav">
                
                <li><a href="/archives">Archives</a></li>
                
                
                <li><a target="_blank" rel="noopener" href="https://github.com/sfyr111" title="git">GITHUB</a></li>
                
                <li><a class="toggle-search" href="#search">search</a></li>
            </ul>
        </nav>
        <div class="site-search" id="search">
            <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
        </div>
        
            <div class="site-header-background" style="background-image:url(http://reumia.github.io/hexo-theme-zzoman2015/images/background-zzoman2015.jpg)"></div>
        
    </header>
    <div class="site-body">
        <div class="global-width">
    <article class="article" data-layout="post" data-slug="周常1 算法题5道、koa-bodyparser 源码阅读、async await 原理回顾">
        <div class="article-content">
            
            
            <header class="article-header">
                <div class="article-meta">
                    <a href="/2018/12/15/%E5%91%A8%E5%B8%B81%20%E7%AE%97%E6%B3%95%E9%A2%985%E9%81%93%E3%80%81koa-bodyparser%20%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E3%80%81async%20await%20%E5%8E%9F%E7%90%86%E5%9B%9E%E9%A1%BE/" class="article-date">
  <time datetime="2018-12-15T14:42:00.000Z">2018-12-15</time>
</a>
                    
                    
                </div>
                
    <h1 class="article-title" itemprop="name">
      <a href="/2018/12/15/%E5%91%A8%E5%B8%B81%20%E7%AE%97%E6%B3%95%E9%A2%985%E9%81%93%E3%80%81koa-bodyparser%20%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E3%80%81async%20await%20%E5%8E%9F%E7%90%86%E5%9B%9E%E9%A1%BE/">周常1 算法题5道、koa-bodyparser 源码阅读、async / await 原理回顾</a>
    </h1>

            </header>
            
            <div class="article-body">
                <h2 id="周常"><a href="#周常" class="headerlink" title="周常"></a>周常</h2><ul>
<li><p>五道算法题 java 实现<br>1.二维数组搜索<br>2.二分查找最小值<br>3.从尾到头打印链表<br>4.用栈表示队列<br>5.重建二叉树</p>
</li>
<li><p>koa-bodyparser 源码解析</p>
</li>
<li><p>async &#x2F; await 原理解析</p>
</li>
</ul>
<h2 id="算法题"><a href="#算法题" class="headerlink" title="算法题"></a>算法题</h2><h3 id="二维数组中查找"><a href="#二维数组中查找" class="headerlink" title="二维数组中查找"></a>二维数组中查找</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">matrix = [</span><br><span class="line">  [1,   3,  5,  7],</span><br><span class="line">  [10, 11, 16, 20],</span><br><span class="line">  [23, 30, 34, 50]</span><br><span class="line">]</span><br><span class="line">target = 3</span><br><span class="line">输出: true</span><br><span class="line">---</span><br><span class="line">输入:</span><br><span class="line">matrix = [</span><br><span class="line">  [1,   3,  5,  7],</span><br><span class="line">  [10, 11, 16, 20],</span><br><span class="line">  [23, 30, 34, 50]</span><br><span class="line">]</span><br><span class="line">target = 13</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure>
<h5 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h5><ul>
<li>此二维数组是按顺序排列</li>
<li>每一行数组的最后一位都是此行数组的最大值</li>
<li>target 如果比当前数组最后一位大，那 target 肯定在下面的几行数组内</li>
<li>target 如果比当前数组最后一位小，那 target 可能在当前数组内</li>
<li>用 target 与二维数组内的每个数组最后一位比较，在最后一位比 target 大的那一行数组内进行 target 查找<br><img src="/images/imagemogr2_auto_orient_strip_7cimageview2_2_w_1240_12401694866193130.png"></li>
</ul>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class SearchMatrix &#123;</span><br><span class="line">	public boolean searchMatrix(int[][] matrix, int target) &#123;</span><br><span class="line">		if (matrix.length == 0)</span><br><span class="line">			return false;</span><br><span class="line"></span><br><span class="line">		int i = 0; // 第一行</span><br><span class="line">		int j = matrix[0].length - 1; // 最后一个点</span><br><span class="line"></span><br><span class="line">		while (i &lt; matrix.length &amp;&amp; j &gt;= 0) &#123;</span><br><span class="line">			if (matrix[i][j] == target) // 第一排最后一个</span><br><span class="line">				return true;</span><br><span class="line">			else if (matrix[i][j] &lt; target) // 如果小，就移动到下一排最后一个</span><br><span class="line">				i++;</span><br><span class="line">			else // matrix[i][j] &gt; target // 如果大，i 就是当前排，在当前排搜索</span><br><span class="line">				j--;</span><br><span class="line">		&#125;</span><br><span class="line">		return false;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/search-a-2d-matrix/">搜索二维矩阵</a></p>
<h3 id="寻找旋转排序数组中的最小值"><a href="#寻找旋转排序数组中的最小值" class="headerlink" title="寻找旋转排序数组中的最小值"></a>寻找旋转排序数组中的最小值</h3><p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。<br>( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。<br>请找出其中最小的元素。<br>你可以假设数组中不存在重复元素。</p>
<h5 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h5><ul>
<li>查找某个值比较合适的解法是二分搜索</li>
<li>此题数组已经是排序数组，变化后有以下几个结果,<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[1,2,3,4,5] // 顺序不变，直接取数组 arr[0]</span><br><span class="line">// 中值 arr[mid]  是数组最大值或最小值</span><br><span class="line">[3,4,5,1,2] // arr[mid] 是 5 arr[mid] &gt; arr[mid+1] 最小值是 arr[mid+1]</span><br><span class="line">[4,5,1,2,3] // arr[mid] 是 1 arr[mid-1] &gt; arr[mid] 最小值是 arr[mid]</span><br><span class="line">// 中值 arr[mid] 是数组最大值或最小值以外的值</span><br><span class="line">[2,3,4,5,1] // arr[mid] 是 4 最小值在数组右侧，left = mid + 1 继续查找</span><br><span class="line">[5,1,2,3,4] // arr[mid] 是 2 最小值在数组左侧，right = mid - 1 继续查找</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">public class BinarySearch &#123;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * 找到最小数</span><br><span class="line">	 * nums [3,4,5,1,2], 一定是按顺序排列的数组，只是进行了旋转</span><br><span class="line">	 * 旋转后=[3,4,5,1,2]， 原数组=[1,2,3,4,5]</span><br><span class="line">	 */</span><br><span class="line">	public int findMin(int[] nums) &#123;</span><br><span class="line"></span><br><span class="line">		// 一个数</span><br><span class="line">		if (nums.length == 1)</span><br><span class="line">			return nums[0];</span><br><span class="line"></span><br><span class="line">		int left = 0, right = nums.length - 1;</span><br><span class="line"></span><br><span class="line">		// [1,2,3,4,5] 为没旋转的原数组</span><br><span class="line">		if (nums[right] &gt; nums[0])</span><br><span class="line">			return nums[0];</span><br><span class="line"></span><br><span class="line">		// 进行二分搜索</span><br><span class="line">		while (right &gt;= left) &#123;</span><br><span class="line">			// 找到中点防止溢出</span><br><span class="line">			int mid = left + ((right - left) &gt;&gt; 1);</span><br><span class="line"></span><br><span class="line">			// [3,4,5,1,2] midVal = 5</span><br><span class="line">			if (nums[mid] &gt; nums[mid + 1])</span><br><span class="line">				return nums[mid + 1];</span><br><span class="line"></span><br><span class="line">			// [4,5,1,2,3] midVal = 1</span><br><span class="line">			if (nums[mid - 1] &gt; nums[mid])</span><br><span class="line">				return nums[mid];</span><br><span class="line"></span><br><span class="line">			// [2,3,4,5,1]</span><br><span class="line">			if (nums[mid] &gt; nums[0])</span><br><span class="line">				left = mid + 1;</span><br><span class="line">			// [5,1,2,3,4]</span><br><span class="line">			else // nums[mid] &lt; nums[0]</span><br><span class="line">				right = mid - 1;</span><br><span class="line">		&#125;</span><br><span class="line">		return -1;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/">寻找旋转排序数组中的最小值</a></p>
<h3 id="使用栈实现队列"><a href="#使用栈实现队列" class="headerlink" title="使用栈实现队列"></a>使用栈实现队列</h3><h4 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h4><ul>
<li>队列有 push 添加元素， pop 删除并返回队列头元素，peek 查看队列头的元素, empty 是否为空</li>
<li>实现 Queue 的 push 可以直接使用 Stack 的 push，而队列的头部元素可以用 Front 变量来保存。<img src="/images/imagemogr2_auto_orient_strip_7cimageview2_2_w_620_6201694866193751.png"></li>
<li>实现 Queue 的 pop 需要删除掉 队列的头元素并返回，而 Stack 的 pop 只能返回最后进入的元素，这时候需要 Stack2 协助完成</li>
<li>Stack1 的元素 pop() 出来 push() 到 Stack2 中，这时 Stack2.pop() 出的就是 队列的头部元素<img src="/images/imagemogr2_auto_orient_strip_7cimageview2_2_w_620_6201694866194377.png"></li>
<li>实现队列 peek 方法要考虑两种情况<ol>
<li>Stack2 是空的，此时 Queue 队列还没进行 pop() 操作或者 Stack2 已经排空，只有 Stack1 有元素,  此时 front 变量就是 peek() 出的元素<img src="/images/imagemogr2_auto_orient_strip_7cimageview2_2_w_620_6201694866194981.png"></li>
<li>Stack2 有元素，此时 Queue 队列已经进行 pop() 操作，Stack2 的栈顶就是队列头，只需要进行 Stack2.peek() 就行了。<img src="/images/imagemogr2_auto_orient_strip_7cimageview2_2_w_620_6201694866196053.png"></li>
</ol>
</li>
</ul>
<h4 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">public class ImplementQueueUsingStacks &#123;</span><br><span class="line">	private int front;</span><br><span class="line"></span><br><span class="line">	private Stack&lt;Integer&gt; s1 = new Stack&lt;&gt;();</span><br><span class="line">	private Stack&lt;Integer&gt; s2 = new Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">	/** Initialize your data structure here. */</span><br><span class="line">	public MyQueue() &#123;&#125;</span><br><span class="line"></span><br><span class="line">	/** Push element x to the back of queue. */</span><br><span class="line">	public void push(int x) &#123;</span><br><span class="line">		if (s1.isEmpty())</span><br><span class="line">			front = x;</span><br><span class="line">		s1.push(x);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/** Removes the element from in front of queue and returns that element. */</span><br><span class="line">	public int pop() &#123;</span><br><span class="line">		while (s2.isEmpty()) &#123;</span><br><span class="line">			if (!s1.isEmpty())</span><br><span class="line">				s2.push(s1.pop());</span><br><span class="line">		&#125;</span><br><span class="line">		return s2.pop();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/** Get the front element. */</span><br><span class="line">	public int peek() &#123;</span><br><span class="line">		if (!s2.isEmpty())</span><br><span class="line">			return s2.peek();</span><br><span class="line">		return front;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/** Returns whether the queue is empty. */</span><br><span class="line">	public boolean empty() &#123;</span><br><span class="line">		return s1.isEmpty() &amp;&amp; s2.isEmpty();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/implement-queue-using-stacks/">使用栈实现队列</a></p>
<h3 id="从尾到头打印链表的值"><a href="#从尾到头打印链表的值" class="headerlink" title="从尾到头打印链表的值"></a>从尾到头打印链表的值</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 链表节点结构</span><br><span class="line">   private class ListNode &#123;</span><br><span class="line">       int val;</span><br><span class="line">       ListNode next;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h4 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h4><ul>
<li>使用 Stack 保存所有链表的值</li>
<li>再使用 List 保存 Stack.pop() 出来的值<img src="/images/imagemogr2_auto_orient_strip_7cimageview2_2_w_620_6201694866196645.png"></li>
</ul>
<h4 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class PrintListFromTailToHead &#123;</span><br><span class="line"></span><br><span class="line">	public List&lt;Integer&gt; printListFromTailToHead(ListNode listNode) &#123;</span><br><span class="line">		Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();</span><br><span class="line">		while (listNode != null) &#123;</span><br><span class="line">			stack.push(listNode.val);</span><br><span class="line">			listNode = listNode.next;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		ArrayList&lt;Integer&gt; arrayList = new ArrayList&lt;&gt;();</span><br><span class="line">		while (!stack.isEmpty()) &#123;</span><br><span class="line">			arrayList.add(stack.pop());</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		return arrayList;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="根据中序排列、前序排列重建二叉树"><a href="#根据中序排列、前序排列重建二叉树" class="headerlink" title="根据中序排列、前序排列重建二叉树"></a>根据中序排列、前序排列重建二叉树</h3><h3 id="实现思路-1"><a href="#实现思路-1" class="headerlink" title="实现思路"></a>实现思路</h3><ul>
<li><p>前序遍历顺序为 [ 根 左 右 ]</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 前序遍历的序号顺序</span><br><span class="line">		           0</span><br><span class="line">		      /          \</span><br><span class="line">             1            9</span><br><span class="line">		  /   \         /    \</span><br><span class="line">		 2     6       10     13</span><br><span class="line">        / \   / \     / \    /  \</span><br><span class="line">       3   5 7   8   11  12 14  15 </span><br><span class="line">      /</span><br><span class="line">     4</span><br></pre></td></tr></table></figure>
</li>
<li><p>中序遍历顺序为 [ 左 根 右 ]</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 中序遍历的序号顺序</span><br><span class="line">		           8</span><br><span class="line">		     /          \</span><br><span class="line">		    4            12</span><br><span class="line">		  /   \        /    \</span><br><span class="line">		 2     6      10     14</span><br><span class="line">        / \   / \    / \   /  \</span><br><span class="line">       1   3 5   7  9  11 13  15</span><br><span class="line">	  /</span><br><span class="line">     0</span><br></pre></td></tr></table></figure></li>
<li><p>使用一个函数递归重建二叉树</p>
</li>
<li><p>函数中先确定重建的当前节点树的根节点，前序遍历的第一位 preStart 就是当前树结构的根节点 root &#x3D; preorder[preStart]</p>
</li>
<li><p>确定 root.left 的位置，root.left 为 root 节点的 在前序遍历的位置 preStart + 1 的位置</p>
</li>
<li><p>确定 root.right 的位置, root.right 为 root 节点在前序遍历中 preStart + (所有左子树元素个数) + 1 的位置。</p>
</li>
<li><p>确定 root.right 的位置需要知道 root 所有左子树元素个数，这时只依靠前序遍历的结果是无法得到的，而中序遍历的结果顺序为 [ 左 根 右 ], 我们已经根据前序遍历 preorder[preStart] 确定了 根 root 的值，找到 root 在中序遍历结果中的位置后，此位置在中序遍历中的所有左侧元素就是我们要的结果。</p>
</li>
<li><p>查找当前 root 节点在 inorder 中的位置，已知 root，需要提供此段节点 inStart, inEnd 的位置。这时我们的函数 可写为 <code>public TreeNode helper(int preStart, int inStart, int inEnd, int[] preorder, int[] inorder) &#123;&#125;</code></p>
</li>
<li><p>找到 root 在 inorder 中的位置 inIndex，inIndex - inStart 为 root 节点所有左子树元素个数， root.right 的 preStart 就为 preStart + inIndex - inStart + 1</p>
</li>
<li><p>在递归函数参数中，通过 inIndex 再来确定 root.left、root.right 的 inStart 和 inEnd</p>
</li>
</ul>
<h4 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public class ReConstructBinaryTreeBak2 &#123;</span><br><span class="line">	 // Definition for a binary tree node.</span><br><span class="line">	 public class TreeNode &#123;</span><br><span class="line">	     int val;</span><br><span class="line">	     TreeNode left;</span><br><span class="line">	     TreeNode right;</span><br><span class="line">	     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="line">	 &#125;</span><br><span class="line"></span><br><span class="line">	public TreeNode buildTree(int [] preorder, int [] inorder) &#123;</span><br><span class="line">		return helper(0, 0, inorder.length - 1, preorder, inorder);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public TreeNode helper(int preStart, int inStart, int inEnd, int[] preorder, int[] inorder) &#123;</span><br><span class="line">	 	if (preStart &gt; preorder.length - 1 || inStart &gt; inEnd)</span><br><span class="line">			return null;</span><br><span class="line"></span><br><span class="line">		TreeNode root = new TreeNode(preorder[preStart]);</span><br><span class="line"></span><br><span class="line">		int inIndex = 0;</span><br><span class="line">		for (int i = inStart; i &lt;= inEnd; i++) &#123;</span><br><span class="line">			if (root.val == inorder[i])</span><br><span class="line">				inIndex = i;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		root.left = helper(preStart + 1, inStart, inIndex - 1, preorder, inorder);</span><br><span class="line">		root.right = helper(preStart + (inIndex - inStart + 1), inIndex + 1, inEnd, preorder, inorder);</span><br><span class="line"></span><br><span class="line">	 	return root;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="koa-bodyparser-源码解析"><a href="#koa-bodyparser-源码解析" class="headerlink" title="koa-bodyparser 源码解析"></a>koa-bodyparser 源码解析</h2><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>将 http POST 请求的数据解析成对象挂载到 ctx.request.body 对象上进行使用。<br>koa-bodyparser 中间件默认支持表单格式 <code>application/x-www-form-urlencoded</code> 和 JSON 格式 <code>application/json</code></p>
<h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><p>bodyParser 中间件把请求的使用 parseBody(ctx) 解析成对象进行挂载</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">return async function bodyParser(ctx, next) &#123;</span><br><span class="line">  if (ctx.request.body !== undefined) return await next();</span><br><span class="line">  if (ctx.disableBodyParser) return await next();</span><br><span class="line">  try &#123;</span><br><span class="line">    const res = await parseBody(ctx); // 解析 ctx 数据，默认 from json 两种格式</span><br><span class="line">    ctx.request.body = &#x27;parsed&#x27; in res ? res.parsed : &#123;&#125;; // 解析成功把结果挂载到 ctx.request.body 上</span><br><span class="line">    if (ctx.request.rawBody === undefined) ctx.request.rawBody = res.raw;</span><br><span class="line">  &#125; catch (err) &#123;</span><br><span class="line">    if (onerror) &#123;</span><br><span class="line">      onerror(err, ctx);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      throw err;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  await next();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>parseBody 函数使用 co-body 模块进行解析。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var parse = require(&#x27;co-body&#x27;);</span><br><span class="line">// ...</span><br><span class="line">  async function parseBody(ctx) &#123;</span><br><span class="line">    if (enableJson &amp;&amp; ((detectJSON &amp;&amp; detectJSON(ctx)) || ctx.request.is(jsonTypes))) &#123;</span><br><span class="line">      return await parse.json(ctx, jsonOpts); // 解析 json 类型</span><br><span class="line">    &#125;</span><br><span class="line">    if (enableForm &amp;&amp; ctx.request.is(formTypes)) &#123;</span><br><span class="line">      return await parse.form(ctx, formOpts); // 解析表单类型</span><br><span class="line">    &#125;</span><br><span class="line">    if (enableText &amp;&amp; ctx.request.is(textTypes)) &#123;</span><br><span class="line">      return await parse.text(ctx, textOpts) || &#x27;&#x27;; // 解析文本类型</span><br><span class="line">    &#125;</span><br><span class="line">    return &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>co-body 模块解析 json, 把请求解析成字符串后进行 JSON.parse(str) 然后返回</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">const raw = require(&#x27;raw-body&#x27;);</span><br><span class="line">const inflate = require(&#x27;inflation&#x27;);</span><br><span class="line"></span><br><span class="line">module.exports = async function(req, opts) &#123;</span><br><span class="line">  req = req.req || req;</span><br><span class="line">  opts = utils.clone(opts);</span><br><span class="line">  // ...</span><br><span class="line"></span><br><span class="line">  const str = await raw(inflate(req), opts);</span><br><span class="line">  try &#123;</span><br><span class="line">    const parsed = parse(str); // JSON.parse</span><br><span class="line">    return opts.returnRawBody ? &#123; parsed, raw: str &#125; : parsed;</span><br><span class="line">  &#125; catch (err) &#123;</span><br><span class="line">    err.status = 400;</span><br><span class="line">    err.body = str;</span><br><span class="line">    throw err;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>co-body 模块解析 from, 把表单请求解析成字符串后使用 qs.parse 解析后返回</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">const raw = require(&#x27;raw-body&#x27;);</span><br><span class="line">const inflate = require(&#x27;inflation&#x27;);</span><br><span class="line"></span><br><span class="line">module.exports = async function(req, opts) &#123;</span><br><span class="line">  req = req.req || req;</span><br><span class="line">  opts = utils.clone(opts);</span><br><span class="line">  const queryString = opts.queryString || &#123;&#125;;</span><br><span class="line">  // ...</span><br><span class="line"></span><br><span class="line">  const str = await raw(inflate(req), opts);</span><br><span class="line">  try &#123;</span><br><span class="line">    const parsed = opts.qs.parse(str, queryString); // 使用 qs.parse 解析</span><br><span class="line">    return opts.returnRawBody ? &#123; parsed, raw: str &#125; : parsed;</span><br><span class="line">  &#125; catch (err) &#123;</span><br><span class="line">    err.status = 400;</span><br><span class="line">    err.body = str;</span><br><span class="line">    throw err;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>nodejs 的 http 模块接收的 post 请求为可读流内容，co-body 通过使用 raw-body 来解析成 str 供 co-body 来生成返回对象。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var inflate = require(&#x27;inflation&#x27;)</span><br><span class="line">var raw     = require(&#x27;raw-body&#x27;)</span><br><span class="line"></span><br><span class="line">const str = await raw(inflate(req), opts);</span><br></pre></td></tr></table></figure>
<p>这里使用了 inflate 库，库里返回 http 可读流的解压后 Stream， <code>stream.pip(zip.Unzip(opts))</code> ，作为参数传给 raw-body 来解析</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">var zlib = require(&#x27;zlib&#x27;)</span><br><span class="line">function inflate(stream, options) &#123;</span><br><span class="line">  // ...</span><br><span class="line">  switch (encoding) &#123;</span><br><span class="line">  case &#x27;gzip&#x27;:</span><br><span class="line">  case &#x27;deflate&#x27;:</span><br><span class="line">    break</span><br><span class="line">  case &#x27;identity&#x27;:</span><br><span class="line">    return stream</span><br><span class="line">  default:</span><br><span class="line">    var err = new Error(&#x27;Unsupported Content-Encoding: &#x27; + encoding)</span><br><span class="line">    err.status = 415</span><br><span class="line">    throw err</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // no not pass-through encoding</span><br><span class="line">  delete options.encoding</span><br><span class="line"></span><br><span class="line">  return stream.pipe(zlib.Unzip(options))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>raw-body 模块通过 readStream 方法返回解析出来的 buf 字符串数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function getRawBody (stream, options, callback) &#123;</span><br><span class="line">   // ...</span><br><span class="line">  return new Promise(function executor (resolve, reject) &#123;</span><br><span class="line">    readStream(stream, encoding, length, limit, function onRead (err, buf) &#123;</span><br><span class="line">      if (err) return reject(err)</span><br><span class="line">      resolve(buf)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>readStream 方法注册 http stream 的事件进行处理，onData 来处理 POST 请求的 Stream 数据， onEnd 用 done 函数处理事件结束。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">function readStream (stream, encoding, length, limit, callback) &#123;</span><br><span class="line">  // ...</span><br><span class="line">  var buffer = decoder</span><br><span class="line">      ? &#x27;&#x27;</span><br><span class="line">      : []</span><br><span class="line"></span><br><span class="line">  stream.on(&#x27;aborted&#x27;, onAborted)</span><br><span class="line">  stream.on(&#x27;close&#x27;, cleanup)</span><br><span class="line">  stream.on(&#x27;data&#x27;, onData)</span><br><span class="line">  stream.on(&#x27;end&#x27;, onEnd)</span><br><span class="line">  stream.on(&#x27;error&#x27;, onEnd)</span><br><span class="line"></span><br><span class="line">  // ...</span><br><span class="line">  function onData (chunk) &#123;</span><br><span class="line">    if (complete) return</span><br><span class="line"></span><br><span class="line">    received += chunk.length</span><br><span class="line"></span><br><span class="line">    if (limit !== null &amp;&amp; received &gt; limit) &#123;</span><br><span class="line">      done(createError(413, &#x27;request entity too large&#x27;, &#123;</span><br><span class="line">        limit: limit,</span><br><span class="line">        received: received,</span><br><span class="line">        type: &#x27;entity.too.large&#x27;</span><br><span class="line">      &#125;))</span><br><span class="line">    &#125; else if (decoder) &#123;</span><br><span class="line">      buffer += decoder.write(chunk)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      buffer.push(chunk)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function onEnd (err) &#123;</span><br><span class="line">    if (complete) return</span><br><span class="line">    if (err) return done(err)</span><br><span class="line"></span><br><span class="line">    if (length !== null &amp;&amp; received !== length) &#123;</span><br><span class="line">      done(createError(400, &#x27;request size did not match content length&#x27;, &#123;</span><br><span class="line">        expected: length,</span><br><span class="line">        length: length,</span><br><span class="line">        received: received,</span><br><span class="line">        type: &#x27;request.size.invalid&#x27;</span><br><span class="line">      &#125;))</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      var string = decoder</span><br><span class="line">        ? buffer + (decoder.end() || &#x27;&#x27;)</span><br><span class="line">        : Buffer.concat(buffer)</span><br><span class="line">      done(null, string)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="body-parser-总结"><a href="#body-parser-总结" class="headerlink" title="body-parser 总结"></a>body-parser 总结</h3><p>koa-bodyparser 通过使用 raw-body 模块解析 http 请求的 stream buffer 数据成字符串格式，再根据请求头中的 MIME 来解析字符串成对应的对象，最后挂载到 ctx.request.body 对象上。</p>
<h2 id="async-await-方法解析"><a href="#async-await-方法解析" class="headerlink" title="async &#x2F; await 方法解析"></a>async &#x2F; await 方法解析</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">async function async1() &#123;</span><br><span class="line">  console.log(&#x27;async1 start&#x27;);</span><br><span class="line">  await async2();</span><br><span class="line">  console.log(&#x27;async1 end&#x27;);</span><br><span class="line">&#125;</span><br><span class="line">async function async2() &#123;</span><br><span class="line">  console.log(&#x27;async2&#x27;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>async 函数通过 babel 后为一个自执行函数，返回另一个函数, 而原 async 函数里所要执行的内容将由 <code>function*() &#123; // 执行内容 &#125;</code> 包裹传入 <code>_asyncToGenerator</code>  里</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">let async1 = (() =&gt; &#123;</span><br><span class="line">  var _ref = _asyncToGenerator(function*() &#123;</span><br><span class="line">    console.log(&quot;async1 start&quot;);</span><br><span class="line">    yield async2();</span><br><span class="line">    console.log(&quot;async1 end&quot;);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  return function async1() &#123;</span><br><span class="line">    return _ref.apply(this, arguments);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">let async2 = (() =&gt; &#123;</span><br><span class="line">  var _ref2 = _asyncToGenerator(function*() &#123;</span><br><span class="line">    console.log(&quot;async2&quot;);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  return function async2() &#123;</span><br><span class="line">    return _ref2.apply(this, arguments);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<h3 id="解析-asyncToGenerator"><a href="#解析-asyncToGenerator" class="headerlink" title="解析 _asyncToGenerator"></a>解析 _asyncToGenerator</h3><ul>
<li>_asyncToGenerator 的执行<br>1.会先执行传入的 generator 函数<br>2.然后返回一个 new Promise()<br>3.在 new Promise 里执行 step(“next”) 来检查当前函数是否 有 yield 可执行<br>4.有 yield 可执行就通过 Promise.resolve(value).then(&#x2F;&#x2F; 继续执行 step(‘“next”, value))<br>5.一直到当前 generator 函数执行完毕，next() 返回 done 为 true 时才最终返回 resolve(value) 并把执行的结果带出，也就是 await 出来的值。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">function _asyncToGenerator(fn) &#123;</span><br><span class="line">  return function() &#123;</span><br><span class="line">    var gen = fn.apply(this, arguments); // 先执行传入 generator 函数</span><br><span class="line">    return new Promise(function(resolve, reject) &#123;</span><br><span class="line">      function step(key, arg) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">          var info = gen[key](arg);</span><br><span class="line">          var value = info.value;</span><br><span class="line">        &#125; catch (error) &#123;</span><br><span class="line">          reject(error);</span><br><span class="line">          return;</span><br><span class="line">        &#125;</span><br><span class="line">        if (info.done) &#123;</span><br><span class="line">          resolve(value);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          return Promise.resolve(value).then(</span><br><span class="line">            function(value) &#123;</span><br><span class="line">              step(&quot;next&quot;, value);</span><br><span class="line">            &#125;,</span><br><span class="line">            function(err) &#123;</span><br><span class="line">              step(&quot;throw&quot;, err);</span><br><span class="line">            &#125;</span><br><span class="line">          );</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      return step(&quot;next&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="async-await-总结"><a href="#async-await-总结" class="headerlink" title="async &#x2F; await 总结"></a>async &#x2F; await 总结</h3><p>当 async 函数执行时，经过内部自执行函数的将会把需要执行的内容直接传入 _asyncToGenerator 中执行，同时直接返回的 new Promise(&#x2F;&#x2F; .. step(“next”)), 而返回的 new Promise 回调中 step(“next”) 函数会一直执行直到 resolve(value) 带出 await 后的执行结果</p>

            </div>
        </div>
    </article>

    
    
<nav class="article-nav">
  
    <a href="/2018/12/23/%E5%91%A8%E5%B8%B82%20%E7%AE%97%E6%B3%95%E9%A2%984%E9%81%93%E3%80%81react%20ssr%20%E5%8E%9F%E7%90%86%E5%AE%9E%E8%B7%B5%E3%80%81koa-router%20%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/" id="article-nav-newer" class="article-nav-link-wrap prev">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          周常2 算法题4道、react ssr 原理实践、koa-router 源码阅读
        
      </div>
    </a>
  
  
    <a href="/2018/10/29/Nodejs%20%E4%B8%AD%E7%9A%84%20Stream/" id="article-nav-older" class="article-nav-link-wrap next">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Nodejs 中的 Stream</div>
    </a>
  
</nav>

    

    
</div>
    </div>
    <footer class="site-footer">
        <div class="global-width">
            <ul class="site-widget">
                
                <li class="widget widget-tag">
                    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget-body">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/JavaScript/" rel="tag">JavaScript</a><span class="tag-list-count">6</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/React/" rel="tag">React</a><span class="tag-list-count">5</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/React-Tips/" rel="tag">React Tips</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Redux/" rel="tag">Redux</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Vue/" rel="tag">Vue</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/css/" rel="tag">css</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/dom/" rel="tag">dom</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/http/" rel="tag">http</a><span class="tag-list-count">5</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/nodejs/" rel="tag">nodejs</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/sftp/" rel="tag">sftp</a><span class="tag-list-count">1</span></li></ul>
    </div>
  </div>

                </li>
                
                <li class="widget widget-category">
                    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget-body">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Font-End-Basis/">Font-End Basis</a><span class="category-list-count">11</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/React/">React</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Vue/">Vue</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/css/">css</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/http/">http</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/network/">network</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/nodejs/">nodejs</a><span class="category-list-count">2</span></li></ul>
    </div>
  </div>

                </li>
                
                <li class="widget widget-recent_posts">
                    
  <div class="widget-wrap">
    <h3 class="widget-title">Recents</h3>
    <div class="widget-body">
      <ul>
        
          <li>
            <a href="/2019/01/02/%E5%91%A8%E5%B8%B83%20%E7%AE%97%E6%B3%95%E9%A2%985%E9%81%93%E3%80%81react%20ssr%20%E8%A1%A5%E5%85%85%20/">周常3 算法题5道、react ssr 补充</a>
          </li>
        
          <li>
            <a href="/2018/12/23/%E5%91%A8%E5%B8%B82%20%E7%AE%97%E6%B3%95%E9%A2%984%E9%81%93%E3%80%81react%20ssr%20%E5%8E%9F%E7%90%86%E5%AE%9E%E8%B7%B5%E3%80%81koa-router%20%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/">周常2 算法题4道、react ssr 原理实践、koa-router 源码阅读</a>
          </li>
        
          <li>
            <a href="/2018/12/15/%E5%91%A8%E5%B8%B81%20%E7%AE%97%E6%B3%95%E9%A2%985%E9%81%93%E3%80%81koa-bodyparser%20%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E3%80%81async%20await%20%E5%8E%9F%E7%90%86%E5%9B%9E%E9%A1%BE/">周常1 算法题5道、koa-bodyparser 源码阅读、async / await 原理回顾</a>
          </li>
        
          <li>
            <a href="/2018/10/29/Nodejs%20%E4%B8%AD%E7%9A%84%20Stream/">Nodejs 中的 Stream</a>
          </li>
        
          <li>
            <a href="/2018/10/28/%E7%BC%96%E5%86%99React%E7%BB%84%E4%BB%B6%E8%A6%81%E7%82%B9-%E5%8D%95%E4%B8%80%E8%B4%A3%E4%BB%BB%E5%8E%9F%E5%88%99/">编写React组件要点-单一责任原则</a>
          </li>
        
      </ul>
    </div>
  </div>

                </li>
                
            </ul>
        </div>
        <div class="site-info">
            <address>
                &copy; 2014 <a href="http://yoursite.com">Minimalist</a> All Right Reserved. <br/>
                Powered by <a target="_blank" rel="noopener" href="http://hexo.io">Hexo</a>. Theme by <a target="_blank" rel="noopener" href="http://zzoman.com">ZZOMAN</a>
            </address>
        </div>
    </footer>
    
    <script src="/libs/jquery-1.11.3.min.js" type="text/javascript"></script>
    
    <script src="/libs/fancybox/jquery.fancybox.js" type="text/javascript"></script>
    
    <script src="/js/site_init.js" type="text/javascript"></script>
    
</body>
</html>